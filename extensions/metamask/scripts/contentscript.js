(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (Buffer){
'use strict';


var path = _dereq_('path');
var pump = _dereq_('pump');
var LocalMessageDuplexStream = _dereq_('post-message-stream');
var PongStream = _dereq_('ping-pong-stream/pong');
var ObjectMultiplex = _dereq_('obj-multiplex');
var extension = _dereq_('extensionizer');
var PortStream = _dereq_('./lib/port-stream.js');

var inpageContent = Buffer("KGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT0iZnVuY3Rpb24iJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKCJDYW5ub3QgZmluZCBtb2R1bGUgJyIrbysiJyIpO3Rocm93IGYuY29kZT0iTU9EVUxFX05PVF9GT1VORCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT0iZnVuY3Rpb24iJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAoZ2xvYmFsKXsKJ3VzZSBzdHJpY3QnOwoKLypnbG9iYWwgV2ViMyovCmNsZWFuQ29udGV4dEZvckltcG9ydHMoKTsKX2RlcmVxXygnd2ViMy9kaXN0L3dlYjMubWluLmpzJyk7CnZhciBsb2cgPSBfZGVyZXFfKCdsb2dsZXZlbCcpOwp2YXIgTG9jYWxNZXNzYWdlRHVwbGV4U3RyZWFtID0gX2RlcmVxXygncG9zdC1tZXNzYWdlLXN0cmVhbScpOwovLyBjb25zdCBQaW5nU3RyZWFtID0gcmVxdWlyZSgncGluZy1wb25nLXN0cmVhbS9waW5nJykKLy8gY29uc3QgZW5kT2ZTdHJlYW0gPSByZXF1aXJlKCdlbmQtb2Ytc3RyZWFtJykKdmFyIHNldHVwRGFwcEF1dG9SZWxvYWQgPSBfZGVyZXFfKCcuL2xpYi9hdXRvLXJlbG9hZC5qcycpOwp2YXIgTWV0YW1hc2tJbnBhZ2VQcm92aWRlciA9IF9kZXJlcV8oJy4vbGliL2lucGFnZS1wcm92aWRlci5qcycpOwpyZXN0b3JlQ29udGV4dEFmdGVySW1wb3J0cygpOwoKdmFyIE1FVEFNQVNLX0RFQlVHID0gdW5kZWZpbmVkOwp3aW5kb3cubG9nID0gbG9nOwpsb2cuc2V0RGVmYXVsdExldmVsKE1FVEFNQVNLX0RFQlVHID8gJ2RlYnVnJyA6ICd3YXJuJyk7CgovLwovLyBzZXR1cCBwbHVnaW4gY29tbXVuaWNhdGlvbgovLwoKLy8gc2V0dXAgYmFja2dyb3VuZCBjb25uZWN0aW9uCnZhciBtZXRhbWFza1N0cmVhbSA9IG5ldyBMb2NhbE1lc3NhZ2VEdXBsZXhTdHJlYW0oewogIG5hbWU6ICdpbnBhZ2UnLAogIHRhcmdldDogJ2NvbnRlbnRzY3JpcHQnCn0pOwoKLy8gY29tcG9zZSB0aGUgaW5wYWdlIHByb3ZpZGVyCnZhciBpbnBhZ2VQcm92aWRlciA9IG5ldyBNZXRhbWFza0lucGFnZVByb3ZpZGVyKG1ldGFtYXNrU3RyZWFtKTsKCi8vCi8vIHNldHVwIHdlYjMKLy8KCmlmICh0eXBlb2Ygd2luZG93LndlYjMgIT09ICd1bmRlZmluZWQnKSB7CiAgdGhyb3cgbmV3IEVycm9yKCdNZXRhTWFzayBkZXRlY3RlZCBhbm90aGVyIHdlYjMuXG4gICAgIE1ldGFNYXNrIHdpbGwgbm90IHdvcmsgcmVsaWFibHkgd2l0aCBhbm90aGVyIHdlYjMgZXh0ZW5zaW9uLlxuICAgICBUaGlzIHVzdWFsbHkgaGFwcGVucyBpZiB5b3UgaGF2ZSB0d28gTWV0YU1hc2tzIGluc3RhbGxlZCxcbiAgICAgb3IgTWV0YU1hc2sgYW5kIGFub3RoZXIgd2ViMyBleHRlbnNpb24uIFBsZWFzZSByZW1vdmUgb25lXG4gICAgIGFuZCB0cnkgYWdhaW4uJyk7Cn0KdmFyIHdlYjMgPSBuZXcgV2ViMyhpbnBhZ2VQcm92aWRlcik7CndlYjMuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAoKSB7CiAgbG9nLmRlYnVnKCdNZXRhTWFzayAtIG92ZXJyb2RlIHdlYjMuc2V0UHJvdmlkZXInKTsKfTsKbG9nLmRlYnVnKCdNZXRhTWFzayAtIGluamVjdGVkIHdlYjMnKTsKLy8gZXhwb3J0IGdsb2JhbCB3ZWIzLCB3aXRoIHVzYWdlLWRldGVjdGlvbgpzZXR1cERhcHBBdXRvUmVsb2FkKHdlYjMsIGlucGFnZVByb3ZpZGVyLnB1YmxpY0NvbmZpZ1N0b3JlKTsKCi8vIHNldCB3ZWIzIGRlZmF1bHRBY2NvdW50CgppbnBhZ2VQcm92aWRlci5wdWJsaWNDb25maWdTdG9yZS5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0YXRlKSB7CiAgd2ViMy5ldGguZGVmYXVsdEFjY291bnQgPSBzdGF0ZS5zZWxlY3RlZEFkZHJlc3M7Cn0pOwoKLy8KLy8gdXRpbAovLwoKLy8gbmVlZCB0byBtYWtlIHN1cmUgd2UgYXJlbid0IGFmZmVjdGVkIGJ5IG92ZXJsYXBwaW5nIG5hbWVzcGFjZXMKLy8gYW5kIHRoYXQgd2UgZG9udCBhZmZlY3QgdGhlIGFwcCB3aXRoIG91ciBuYW1lc3BhY2UKLy8gbW9zdGx5IGEgZml4IGZvciB3ZWIzJ3MgQmlnTnVtYmVyIGlmIEFNRCdzICJkZWZpbmUiIGlzIGRlZmluZWQuLi4KdmFyIF9fZGVmaW5lOwoKZnVuY3Rpb24gY2xlYW5Db250ZXh0Rm9ySW1wb3J0cygpIHsKICBfX2RlZmluZSA9IGdsb2JhbC5kZWZpbmU7CiAgdHJ5IHsKICAgIGdsb2JhbC5kZWZpbmUgPSB1bmRlZmluZWQ7CiAgfSBjYXRjaCAoXykgewogICAgY29uc29sZS53YXJuKCdNZXRhTWFzayAtIGdsb2JhbC5kZWZpbmUgY291bGQgbm90IGJlIGRlbGV0ZWQuJyk7CiAgfQp9CgpmdW5jdGlvbiByZXN0b3JlQ29udGV4dEFmdGVySW1wb3J0cygpIHsKICB0cnkgewogICAgZ2xvYmFsLmRlZmluZSA9IF9fZGVmaW5lOwogIH0gY2F0Y2ggKF8pIHsKICAgIGNvbnNvbGUud2FybignTWV0YU1hc2sgLSBnbG9iYWwuZGVmaW5lIGNvdWxkIG5vdCBiZSBvdmVyd3JpdHRlbi4nKTsKICB9Cn0KCn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9KQp9LHsiLi9saWIvYXV0by1yZWxvYWQuanMiOjIsIi4vbGliL2lucGFnZS1wcm92aWRlci5qcyI6MywibG9nbGV2ZWwiOjExMSwicG9zdC1tZXNzYWdlLXN0cmVhbSI6MTE2LCJ3ZWIzL2Rpc3Qvd2ViMy5taW4uanMiOjEzOX1dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKGdsb2JhbCl7Cid1c2Ugc3RyaWN0JzsKCm1vZHVsZS5leHBvcnRzID0gc2V0dXBEYXBwQXV0b1JlbG9hZDsKCmZ1bmN0aW9uIHNldHVwRGFwcEF1dG9SZWxvYWQod2ViMywgb2JzZXJ2YWJsZSkgewogIC8vIGV4cG9ydCB3ZWIzIGFzIGEgZ2xvYmFsLCBjaGVja2luZyBmb3IgdXNhZ2UKICB2YXIgaGFzQmVlbldhcm5lZCA9IGZhbHNlOwogIHZhciByZWxvYWRJblByb2dyZXNzID0gZmFsc2U7CiAgdmFyIGxhc3RUaW1lVXNlZCA9IHZvaWQgMDsKICB2YXIgbGFzdFNlZW5OZXR3b3JrID0gdm9pZCAwOwoKICBnbG9iYWwud2ViMyA9IG5ldyBQcm94eSh3ZWIzLCB7CiAgICBnZXQ6IGZ1bmN0aW9uIGdldChfd2ViMywga2V5KSB7CiAgICAgIC8vIHNob3cgd2FybmluZyBvbmNlIG9uIHdlYjMgYWNjZXNzCiAgICAgIGlmICghaGFzQmVlbldhcm5lZCAmJiBrZXkgIT09ICdjdXJyZW50UHJvdmlkZXInKSB7CiAgICAgICAgY29uc29sZS53YXJuKCdNZXRhTWFzazogd2ViMyB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlIG5lYXIgZnV0dXJlIGluIGZhdm9yIG9mIHRoZSBldGhlcmV1bVByb3ZpZGVyIFxuaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL2ZhcS9ibG9iL21hc3Rlci9kZXRlY3RpbmdfbWV0YW1hc2subWQjd2ViMy1kZXByZWNhdGlvbicpOwogICAgICAgIGhhc0JlZW5XYXJuZWQgPSB0cnVlOwogICAgICB9CiAgICAgIC8vIGdldCB0aGUgdGltZSBvZiB1c2UKICAgICAgbGFzdFRpbWVVc2VkID0gRGF0ZS5ub3coKTsKICAgICAgLy8gcmV0dXJuIHZhbHVlIG5vcm1hbGx5CiAgICAgIHJldHVybiBfd2ViM1trZXldOwogICAgfSwKICAgIHNldDogZnVuY3Rpb24gc2V0KF93ZWIzLCBrZXksIHZhbHVlKSB7CiAgICAgIC8vIHNldCB2YWx1ZSBub3JtYWxseQogICAgICBfd2ViM1trZXldID0gdmFsdWU7CiAgICB9CiAgfSk7CgogIG9ic2VydmFibGUuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdGF0ZSkgewogICAgLy8gaWYgcmVsb2FkIGluIHByb2dyZXNzLCBubyBuZWVkIHRvIGNoZWNrIHJlbG9hZCBsb2dpYwogICAgaWYgKHJlbG9hZEluUHJvZ3Jlc3MpIHJldHVybjsKCiAgICB2YXIgY3VycmVudE5ldHdvcmsgPSBzdGF0ZS5uZXR3b3JrVmVyc2lvbjsKCiAgICAvLyBzZXQgdGhlIGluaXRpYWwgbmV0d29yawogICAgaWYgKCFsYXN0U2Vlbk5ldHdvcmspIHsKICAgICAgbGFzdFNlZW5OZXR3b3JrID0gY3VycmVudE5ldHdvcms7CiAgICAgIHJldHVybjsKICAgIH0KCiAgICAvLyBza2lwIHJlbG9hZCBsb2dpYyBpZiB3ZWIzIG5vdCB1c2VkCiAgICBpZiAoIWxhc3RUaW1lVXNlZCkgcmV0dXJuOwoKICAgIC8vIGlmIG5ldHdvcmsgZGlkIG5vdCBjaGFuZ2UsIGV4aXQKICAgIGlmIChjdXJyZW50TmV0d29yayA9PT0gbGFzdFNlZW5OZXR3b3JrKSByZXR1cm47CgogICAgLy8gaW5pdGlhdGUgcGFnZSByZWxvYWQKICAgIHJlbG9hZEluUHJvZ3Jlc3MgPSB0cnVlOwogICAgdmFyIHRpbWVTaW5jZVVzZSA9IERhdGUubm93KCkgLSBsYXN0VGltZVVzZWQ7CiAgICAvLyBpZiB3ZWIzIHdhcyByZWNlbnRseSB1c2VkIHRoZW4gZGVsYXkgdGhlIHJlbG9hZGluZyBvZiB0aGUgcGFnZQogICAgaWYgKHRpbWVTaW5jZVVzZSA+IDUwMCkgewogICAgICB0cmlnZ2VyUmVzZXQoKTsKICAgIH0gZWxzZSB7CiAgICAgIHNldFRpbWVvdXQodHJpZ2dlclJlc2V0LCA1MDApOwogICAgfQogIH0pOwp9CgovLyByZWxvYWQgdGhlIHBhZ2UKZnVuY3Rpb24gdHJpZ2dlclJlc2V0KCkgewogIGdsb2JhbC5sb2NhdGlvbi5yZWxvYWQoKTsKfQoKfSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDoge30pCn0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7Cgp2YXIgcHVtcCA9IF9kZXJlcV8oJ3B1bXAnKTsKdmFyIFJwY0VuZ2luZSA9IF9kZXJlcV8oJ2pzb24tcnBjLWVuZ2luZScpOwp2YXIgY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUgPSBfZGVyZXFfKCdqc29uLXJwYy1lbmdpbmUvc3JjL2lkUmVtYXBNaWRkbGV3YXJlJyk7CnZhciBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlID0gX2RlcmVxXygnanNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0nKTsKdmFyIExvY2FsU3RvcmFnZVN0b3JlID0gX2RlcmVxXygnb2JzLXN0b3JlJyk7CnZhciBhc1N0cmVhbSA9IF9kZXJlcV8oJ29icy1zdG9yZS9saWIvYXNTdHJlYW0nKTsKdmFyIE9iamVjdE11bHRpcGxleCA9IF9kZXJlcV8oJ29iai1tdWx0aXBsZXgnKTsKCm1vZHVsZS5leHBvcnRzID0gTWV0YW1hc2tJbnBhZ2VQcm92aWRlcjsKCmZ1bmN0aW9uIE1ldGFtYXNrSW5wYWdlUHJvdmlkZXIoY29ubmVjdGlvblN0cmVhbSkgewogIHZhciBzZWxmID0gdGhpczsKCiAgLy8gc2V0dXAgY29ubmVjdGlvblN0cmVhbSBtdWx0aXBsZXhpbmcKICB2YXIgbXV4ID0gc2VsZi5tdXggPSBuZXcgT2JqZWN0TXVsdGlwbGV4KCk7CiAgcHVtcChjb25uZWN0aW9uU3RyZWFtLCBtdXgsIGNvbm5lY3Rpb25TdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHsKICAgIHJldHVybiBsb2dTdHJlYW1EaXNjb25uZWN0V2FybmluZygnTWV0YU1hc2snLCBlcnIpOwogIH0pOwoKICAvLyBzdWJzY3JpYmUgdG8gbWV0YW1hc2sgcHVibGljIGNvbmZpZyAob25lLXdheSkKICBzZWxmLnB1YmxpY0NvbmZpZ1N0b3JlID0gbmV3IExvY2FsU3RvcmFnZVN0b3JlKHsgc3RvcmFnZUtleTogJ01ldGFNYXNrLUNvbmZpZycgfSk7CgogIHB1bXAobXV4LmNyZWF0ZVN0cmVhbSgncHVibGljQ29uZmlnJyksIGFzU3RyZWFtKHNlbGYucHVibGljQ29uZmlnU3RvcmUpLCBmdW5jdGlvbiAoZXJyKSB7CiAgICByZXR1cm4gbG9nU3RyZWFtRGlzY29ubmVjdFdhcm5pbmcoJ01ldGFNYXNrIFB1YmxpY0NvbmZpZ1N0b3JlJywgZXJyKTsKICB9KTsKCiAgLy8gaWdub3JlIHBoaXNoaW5nIHdhcm5pbmcgbWVzc2FnZSAoaGFuZGxlZCBlbHNld2hlcmUpCiAgbXV4Lmlnbm9yZVN0cmVhbSgncGhpc2hpbmcnKTsKCiAgLy8gY29ubmVjdCB0byBhc3luYyBwcm92aWRlcgogIHZhciBzdHJlYW1NaWRkbGV3YXJlID0gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpOwogIHB1bXAoc3RyZWFtTWlkZGxld2FyZS5zdHJlYW0sIG11eC5jcmVhdGVTdHJlYW0oJ3Byb3ZpZGVyJyksIHN0cmVhbU1pZGRsZXdhcmUuc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7CiAgICByZXR1cm4gbG9nU3RyZWFtRGlzY29ubmVjdFdhcm5pbmcoJ01ldGFNYXNrIFJwY1Byb3ZpZGVyJywgZXJyKTsKICB9KTsKCiAgLy8gaGFuZGxlIHNlbmRBc3luYyByZXF1ZXN0cyB2aWEgZGFwcC1zaWRlIHJwYyBlbmdpbmUKICB2YXIgcnBjRW5naW5lID0gbmV3IFJwY0VuZ2luZSgpOwogIHJwY0VuZ2luZS5wdXNoKGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkpOwogIHJwY0VuZ2luZS5wdXNoKHN0cmVhbU1pZGRsZXdhcmUpOwogIHNlbGYucnBjRW5naW5lID0gcnBjRW5naW5lOwp9CgovLyBoYW5kbGUgc2VuZEFzeW5jIHJlcXVlc3RzIHZpYSBhc3luY1Byb3ZpZGVyCi8vIGFsc28gcmVtYXAgaWRzIGluYm91bmQgYW5kIG91dGJvdW5kCk1ldGFtYXNrSW5wYWdlUHJvdmlkZXIucHJvdG90eXBlLnNlbmRBc3luYyA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYikgewogIHZhciBzZWxmID0gdGhpczsKICBzZWxmLnJwY0VuZ2luZS5oYW5kbGUocGF5bG9hZCwgY2IpOwp9OwoKTWV0YW1hc2tJbnBhZ2VQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7CiAgdmFyIHNlbGYgPSB0aGlzOwoKICB2YXIgc2VsZWN0ZWRBZGRyZXNzID0gdm9pZCAwOwogIHZhciByZXN1bHQgPSBudWxsOwogIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHsKCiAgICBjYXNlICdldGhfYWNjb3VudHMnOgogICAgICAvLyByZWFkIGZyb20gbG9jYWxTdG9yYWdlCiAgICAgIHNlbGVjdGVkQWRkcmVzcyA9IHNlbGYucHVibGljQ29uZmlnU3RvcmUuZ2V0U3RhdGUoKS5zZWxlY3RlZEFkZHJlc3M7CiAgICAgIHJlc3VsdCA9IHNlbGVjdGVkQWRkcmVzcyA/IFtzZWxlY3RlZEFkZHJlc3NdIDogW107CiAgICAgIGJyZWFrOwoKICAgIGNhc2UgJ2V0aF9jb2luYmFzZSc6CiAgICAgIC8vIHJlYWQgZnJvbSBsb2NhbFN0b3JhZ2UKICAgICAgc2VsZWN0ZWRBZGRyZXNzID0gc2VsZi5wdWJsaWNDb25maWdTdG9yZS5nZXRTdGF0ZSgpLnNlbGVjdGVkQWRkcmVzczsKICAgICAgcmVzdWx0ID0gc2VsZWN0ZWRBZGRyZXNzIHx8IG51bGw7CiAgICAgIGJyZWFrOwoKICAgIGNhc2UgJ2V0aF91bmluc3RhbGxGaWx0ZXInOgogICAgICBzZWxmLnNlbmRBc3luYyhwYXlsb2FkLCBub29wKTsKICAgICAgcmVzdWx0ID0gdHJ1ZTsKICAgICAgYnJlYWs7CgogICAgY2FzZSAnbmV0X3ZlcnNpb24nOgogICAgICB2YXIgbmV0d29ya1ZlcnNpb24gPSBzZWxmLnB1YmxpY0NvbmZpZ1N0b3JlLmdldFN0YXRlKCkubmV0d29ya1ZlcnNpb247CiAgICAgIHJlc3VsdCA9IG5ldHdvcmtWZXJzaW9uIHx8IG51bGw7CiAgICAgIGJyZWFrOwoKICAgIC8vIHRocm93IG5vdC1zdXBwb3J0ZWQgRXJyb3IKICAgIGRlZmF1bHQ6CiAgICAgIHZhciBsaW5rID0gJ2h0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9mYXEvYmxvYi9tYXN0ZXIvREVWRUxPUEVSUy5tZCNkaXp6eS1hbGwtYXN5bmMtLS10aGluay1vZi1tZXRhbWFzay1hcy1hLWxpZ2h0LWNsaWVudCc7CiAgICAgIHZhciBtZXNzYWdlID0gJ1RoZSBNZXRhTWFzayBXZWIzIG9iamVjdCBkb2VzIG5vdCBzdXBwb3J0IHN5bmNocm9ub3VzIG1ldGhvZHMgbGlrZSAnICsgcGF5bG9hZC5tZXRob2QgKyAnIHdpdGhvdXQgYSBjYWxsYmFjayBwYXJhbWV0ZXIuIFNlZSAnICsgbGluayArICcgZm9yIGRldGFpbHMuJzsKICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpOwoKICB9CgogIC8vIHJldHVybiB0aGUgcmVzdWx0CiAgcmV0dXJuIHsKICAgIGlkOiBwYXlsb2FkLmlkLAogICAganNvbnJwYzogcGF5bG9hZC5qc29ucnBjLAogICAgcmVzdWx0OiByZXN1bHQKICB9Owp9OwoKTWV0YW1hc2tJbnBhZ2VQcm92aWRlci5wcm90b3R5cGUuaXNDb25uZWN0ZWQgPSBmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIHRydWU7Cn07CgpNZXRhbWFza0lucGFnZVByb3ZpZGVyLnByb3RvdHlwZS5pc01ldGFNYXNrID0gdHJ1ZTsKCi8vIHV0aWwKCmZ1bmN0aW9uIGxvZ1N0cmVhbURpc2Nvbm5lY3RXYXJuaW5nKHJlbW90ZUxhYmVsLCBlcnIpIHsKICB2YXIgd2FybmluZ01zZyA9ICdNZXRhbWFza0lucGFnZVByb3ZpZGVyIC0gbG9zdCBjb25uZWN0aW9uIHRvICcgKyByZW1vdGVMYWJlbDsKICBpZiAoZXJyKSB3YXJuaW5nTXNnICs9ICdcbicgKyBlcnIuc3RhY2s7CiAgY29uc29sZS53YXJuKHdhcm5pbmdNc2cpOwp9CgpmdW5jdGlvbiBub29wKCkge30KCn0seyJqc29uLXJwYy1lbmdpbmUiOjEwNywianNvbi1ycGMtZW5naW5lL3NyYy9pZFJlbWFwTWlkZGxld2FyZSI6MTA2LCJqc29uLXJwYy1taWRkbGV3YXJlLXN0cmVhbSI6MTEwLCJvYmotbXVsdGlwbGV4IjoxMTIsIm9icy1zdG9yZSI6MTEzLCJvYnMtc3RvcmUvbGliL2FzU3RyZWFtIjoxMTQsInB1bXAiOjExOH1dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXsKKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHsKICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDoKICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDoKICAoZmFjdG9yeSgoZ2xvYmFsLmFzeW5jID0gZ2xvYmFsLmFzeW5jIHx8IHt9KSkpOwp9KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7CgpmdW5jdGlvbiBzbGljZShhcnJheUxpa2UsIHN0YXJ0KSB7CiAgICBzdGFydCA9IHN0YXJ0fDA7CiAgICB2YXIgbmV3TGVuID0gTWF0aC5tYXgoYXJyYXlMaWtlLmxlbmd0aCAtIHN0YXJ0LCAwKTsKICAgIHZhciBuZXdBcnIgPSBBcnJheShuZXdMZW4pOwogICAgZm9yKHZhciBpZHggPSAwOyBpZHggPCBuZXdMZW47IGlkeCsrKSAgewogICAgICAgIG5ld0FycltpZHhdID0gYXJyYXlMaWtlW3N0YXJ0ICsgaWR4XTsKICAgIH0KICAgIHJldHVybiBuZXdBcnI7Cn0KCi8qKgogKiBDcmVhdGVzIGEgY29udGludWF0aW9uIGZ1bmN0aW9uIHdpdGggc29tZSBhcmd1bWVudHMgYWxyZWFkeSBhcHBsaWVkLgogKgogKiBVc2VmdWwgYXMgYSBzaG9ydGhhbmQgd2hlbiBjb21iaW5lZCB3aXRoIG90aGVyIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMuIEFueQogKiBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSByZXR1cm5lZCBmdW5jdGlvbiBhcmUgYWRkZWQgdG8gdGhlIGFyZ3VtZW50cwogKiBvcmlnaW5hbGx5IHBhc3NlZCB0byBhcHBseS4KICoKICogQG5hbWUgYXBwbHkKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseSBhbGwKICogYXJndW1lbnRzIHRvLiBJbnZva2VzIHdpdGggKGFyZ3VtZW50cy4uLikuCiAqIEBwYXJhbSB7Li4uKn0gYXJndW1lbnRzLi4uIC0gQW55IG51bWJlciBvZiBhcmd1bWVudHMgdG8gYXV0b21hdGljYWxseSBhcHBseQogKiB3aGVuIHRoZSBjb250aW51YXRpb24gaXMgY2FsbGVkLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IHRoZSBwYXJ0aWFsbHktYXBwbGllZCBmdW5jdGlvbgogKiBAZXhhbXBsZQogKgogKiAvLyB1c2luZyBhcHBseQogKiBhc3luYy5wYXJhbGxlbChbCiAqICAgICBhc3luYy5hcHBseShmcy53cml0ZUZpbGUsICd0ZXN0ZmlsZTEnLCAndGVzdDEnKSwKICogICAgIGFzeW5jLmFwcGx5KGZzLndyaXRlRmlsZSwgJ3Rlc3RmaWxlMicsICd0ZXN0MicpCiAqIF0pOwogKgogKgogKiAvLyB0aGUgc2FtZSBwcm9jZXNzIHdpdGhvdXQgdXNpbmcgYXBwbHkKICogYXN5bmMucGFyYWxsZWwoWwogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBmcy53cml0ZUZpbGUoJ3Rlc3RmaWxlMScsICd0ZXN0MScsIGNhbGxiYWNrKTsKICogICAgIH0sCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIGZzLndyaXRlRmlsZSgndGVzdGZpbGUyJywgJ3Rlc3QyJywgY2FsbGJhY2spOwogKiAgICAgfQogKiBdKTsKICoKICogLy8gSXQncyBwb3NzaWJsZSB0byBwYXNzIGFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBhcmd1bWVudHMgd2hlbiBjYWxsaW5nIHRoZQogKiAvLyBjb250aW51YXRpb246CiAqCiAqIG5vZGU+IHZhciBmbiA9IGFzeW5jLmFwcGx5KHN5cy5wdXRzLCAnb25lJyk7CiAqIG5vZGU+IGZuKCd0d28nLCAndGhyZWUnKTsKICogb25lCiAqIHR3bwogKiB0aHJlZQogKi8KdmFyIGFwcGx5ID0gZnVuY3Rpb24oZm4vKiwgLi4uYXJncyovKSB7CiAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICByZXR1cm4gZnVuY3Rpb24oLypjYWxsQXJncyovKSB7CiAgICAgICAgdmFyIGNhbGxBcmdzID0gc2xpY2UoYXJndW1lbnRzKTsKICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoY2FsbEFyZ3MpKTsKICAgIH07Cn07Cgp2YXIgaW5pdGlhbFBhcmFtcyA9IGZ1bmN0aW9uIChmbikgewogICAgcmV0dXJuIGZ1bmN0aW9uICgvKi4uLmFyZ3MsIGNhbGxiYWNrKi8pIHsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cyk7CiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJncy5wb3AoKTsKICAgICAgICBmbi5jYWxsKHRoaXMsIGFyZ3MsIGNhbGxiYWNrKTsKICAgIH07Cn07CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlCiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcykKICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKQogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAwLjEuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNPYmplY3Qoe30pOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzT2JqZWN0KF8ubm9vcCk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc09iamVjdChudWxsKTsKICogLy8gPT4gZmFsc2UKICovCmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7CiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7CiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTsKfQoKdmFyIGhhc1NldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgc2V0SW1tZWRpYXRlOwp2YXIgaGFzTmV4dFRpY2sgPSB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09ICdmdW5jdGlvbic7CgpmdW5jdGlvbiBmYWxsYmFjayhmbikgewogICAgc2V0VGltZW91dChmbiwgMCk7Cn0KCmZ1bmN0aW9uIHdyYXAoZGVmZXIpIHsKICAgIHJldHVybiBmdW5jdGlvbiAoZm4vKiwgLi4uYXJncyovKSB7CiAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgIGRlZmVyKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7CiAgICAgICAgfSk7CiAgICB9Owp9Cgp2YXIgX2RlZmVyOwoKaWYgKGhhc1NldEltbWVkaWF0ZSkgewogICAgX2RlZmVyID0gc2V0SW1tZWRpYXRlOwp9IGVsc2UgaWYgKGhhc05leHRUaWNrKSB7CiAgICBfZGVmZXIgPSBwcm9jZXNzLm5leHRUaWNrOwp9IGVsc2UgewogICAgX2RlZmVyID0gZmFsbGJhY2s7Cn0KCnZhciBzZXRJbW1lZGlhdGUkMSA9IHdyYXAoX2RlZmVyKTsKCi8qKgogKiBUYWtlIGEgc3luYyBmdW5jdGlvbiBhbmQgbWFrZSBpdCBhc3luYywgcGFzc2luZyBpdHMgcmV0dXJuIHZhbHVlIHRvIGEKICogY2FsbGJhY2suIFRoaXMgaXMgdXNlZnVsIGZvciBwbHVnZ2luZyBzeW5jIGZ1bmN0aW9ucyBpbnRvIGEgd2F0ZXJmYWxsLAogKiBzZXJpZXMsIG9yIG90aGVyIGFzeW5jIGZ1bmN0aW9ucy4gQW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGdlbmVyYXRlZAogKiBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCB0byB0aGUgd3JhcHBlZCBmdW5jdGlvbiAoZXhjZXB0IGZvciB0aGUgZmluYWwKICogY2FsbGJhY2sgYXJndW1lbnQpLiBFcnJvcnMgdGhyb3duIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBjYWxsYmFjay4KICoKICogSWYgdGhlIGZ1bmN0aW9uIHBhc3NlZCB0byBgYXN5bmNpZnlgIHJldHVybnMgYSBQcm9taXNlLCB0aGF0IHByb21pc2VzJ3MKICogcmVzb2x2ZWQvcmVqZWN0ZWQgc3RhdGUgd2lsbCBiZSB1c2VkIHRvIGNhbGwgdGhlIGNhbGxiYWNrLCByYXRoZXIgdGhhbiBzaW1wbHkKICogdGhlIHN5bmNocm9ub3VzIHJldHVybiB2YWx1ZS4KICoKICogVGhpcyBhbHNvIG1lYW5zIHlvdSBjYW4gYXN5bmNpZnkgRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25zLgogKgogKiBAbmFtZSBhc3luY2lmeQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAYWxpYXMgd3JhcFN5bmMKICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAtIFRoZSBzeW5jaHJvbm91cyBmdW5jdGlvbiwgb3IgUHJvbWlzZS1yZXR1cm5pbmcKICogZnVuY3Rpb24gdG8gY29udmVydCB0byBhbiB7QGxpbmsgQXN5bmNGdW5jdGlvbn0uCiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBBbiBhc3luY2hyb25vdXMgd3JhcHBlciBvZiB0aGUgYGZ1bmNgLiBUbyBiZQogKiBpbnZva2VkIHdpdGggYChhcmdzLi4uLCBjYWxsYmFjaylgLgogKiBAZXhhbXBsZQogKgogKiAvLyBwYXNzaW5nIGEgcmVndWxhciBzeW5jaHJvbm91cyBmdW5jdGlvbgogKiBhc3luYy53YXRlcmZhbGwoWwogKiAgICAgYXN5bmMuYXBwbHkoZnMucmVhZEZpbGUsIGZpbGVuYW1lLCAidXRmOCIpLAogKiAgICAgYXN5bmMuYXN5bmNpZnkoSlNPTi5wYXJzZSksCiAqICAgICBmdW5jdGlvbiAoZGF0YSwgbmV4dCkgewogKiAgICAgICAgIC8vIGRhdGEgaXMgdGhlIHJlc3VsdCBvZiBwYXJzaW5nIHRoZSB0ZXh0LgogKiAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHBhcnNpbmcgZXJyb3IsIGl0IHdvdWxkIGhhdmUgYmVlbiBjYXVnaHQuCiAqICAgICB9CiAqIF0sIGNhbGxiYWNrKTsKICoKICogLy8gcGFzc2luZyBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHByb21pc2UKICogYXN5bmMud2F0ZXJmYWxsKFsKICogICAgIGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCBmaWxlbmFtZSwgInV0ZjgiKSwKICogICAgIGFzeW5jLmFzeW5jaWZ5KGZ1bmN0aW9uIChjb250ZW50cykgewogKiAgICAgICAgIHJldHVybiBkYi5tb2RlbC5jcmVhdGUoY29udGVudHMpOwogKiAgICAgfSksCiAqICAgICBmdW5jdGlvbiAobW9kZWwsIG5leHQpIHsKICogICAgICAgICAvLyBgbW9kZWxgIGlzIHRoZSBpbnN0YW50aWF0ZWQgbW9kZWwgb2JqZWN0LgogKiAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciwgdGhpcyBmdW5jdGlvbiB3b3VsZCBiZSBza2lwcGVkLgogKiAgICAgfQogKiBdLCBjYWxsYmFjayk7CiAqCiAqIC8vIGVzMjAxNyBleGFtcGxlLCB0aG91Z2ggYGFzeW5jaWZ5YCBpcyBub3QgbmVlZGVkIGlmIHlvdXIgSlMgZW52aXJvbm1lbnQKICogLy8gc3VwcG9ydHMgYXN5bmMgZnVuY3Rpb25zIG91dCBvZiB0aGUgYm94CiAqIHZhciBxID0gYXN5bmMucXVldWUoYXN5bmMuYXN5bmNpZnkoYXN5bmMgZnVuY3Rpb24oZmlsZSkgewogKiAgICAgdmFyIGludGVybWVkaWF0ZVN0ZXAgPSBhd2FpdCBwcm9jZXNzRmlsZShmaWxlKTsKICogICAgIHJldHVybiBhd2FpdCBzb21lUHJvbWlzZShpbnRlcm1lZGlhdGVTdGVwKQogKiB9KSk7CiAqCiAqIHEucHVzaChmaWxlcyk7CiAqLwpmdW5jdGlvbiBhc3luY2lmeShmdW5jKSB7CiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHsKICAgICAgICB2YXIgcmVzdWx0OwogICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7CiAgICAgICAgfQogICAgICAgIC8vIGlmIHJlc3VsdCBpcyBQcm9taXNlIG9iamVjdAogICAgICAgIGlmIChpc09iamVjdChyZXN1bHQpICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICByZXN1bHQudGhlbihmdW5jdGlvbih2YWx1ZSkgewogICAgICAgICAgICAgICAgaW52b2tlQ2FsbGJhY2soY2FsbGJhY2ssIG51bGwsIHZhbHVlKTsKICAgICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7CiAgICAgICAgICAgICAgICBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgZXJyLm1lc3NhZ2UgPyBlcnIgOiBuZXcgRXJyb3IoZXJyKSk7CiAgICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7CiAgICAgICAgfQogICAgfSk7Cn0KCmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnJvciwgdmFsdWUpIHsKICAgIHRyeSB7CiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHZhbHVlKTsKICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBzZXRJbW1lZGlhdGUkMShyZXRocm93LCBlKTsKICAgIH0KfQoKZnVuY3Rpb24gcmV0aHJvdyhlcnJvcikgewogICAgdGhyb3cgZXJyb3I7Cn0KCnZhciBzdXBwb3J0c1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbic7CgpmdW5jdGlvbiBpc0FzeW5jKGZuKSB7CiAgICByZXR1cm4gc3VwcG9ydHNTeW1ib2wgJiYgZm5bU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0FzeW5jRnVuY3Rpb24nOwp9CgpmdW5jdGlvbiB3cmFwQXN5bmMoYXN5bmNGbikgewogICAgcmV0dXJuIGlzQXN5bmMoYXN5bmNGbikgPyBhc3luY2lmeShhc3luY0ZuKSA6IGFzeW5jRm47Cn0KCmZ1bmN0aW9uIGFwcGx5RWFjaCQxKGVhY2hmbikgewogICAgcmV0dXJuIGZ1bmN0aW9uKGZucy8qLCAuLi5hcmdzKi8pIHsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgdmFyIGdvID0gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbihhcmdzLCBjYWxsYmFjaykgewogICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7CiAgICAgICAgICAgIHJldHVybiBlYWNoZm4oZm5zLCBmdW5jdGlvbiAoZm4sIGNiKSB7CiAgICAgICAgICAgICAgICB3cmFwQXN5bmMoZm4pLmFwcGx5KHRoYXQsIGFyZ3MuY29uY2F0KGNiKSk7CiAgICAgICAgICAgIH0sIGNhbGxiYWNrKTsKICAgICAgICB9KTsKICAgICAgICBpZiAoYXJncy5sZW5ndGgpIHsKICAgICAgICAgICAgcmV0dXJuIGdvLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgICAgIH0KICAgICAgICBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGdvOwogICAgICAgIH0KICAgIH07Cn0KCi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovCnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDsKCi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovCnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmOwoKLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovCnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpOwoKLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovCnZhciBTeW1ib2wkMSA9IHJvb3QuU3ltYm9sOwoKLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqLwp2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlOwoKLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovCnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5OwoKLyoqCiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUKICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpCiAqIG9mIHZhbHVlcy4KICovCnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nOwoKLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovCnZhciBzeW1Ub1N0cmluZ1RhZyQxID0gU3ltYm9sJDEgPyBTeW1ib2wkMS50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDsKCi8qKgogKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuCiAqLwpmdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHsKICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyQxKSwKICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWckMV07CgogIHRyeSB7CiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZyQxXSA9IHVuZGVmaW5lZDsKICAgIHZhciB1bm1hc2tlZCA9IHRydWU7CiAgfSBjYXRjaCAoZSkge30KCiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpOwogIGlmICh1bm1hc2tlZCkgewogICAgaWYgKGlzT3duKSB7CiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdID0gdGFnOwogICAgfSBlbHNlIHsKICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnJDFdOwogICAgfQogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovCnZhciBvYmplY3RQcm90byQxID0gT2JqZWN0LnByb3RvdHlwZTsKCi8qKgogKiBVc2VkIHRvIHJlc29sdmUgdGhlCiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKQogKiBvZiB2YWx1ZXMuCiAqLwp2YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmckMSA9IG9iamVjdFByb3RvJDEudG9TdHJpbmc7CgovKioKICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuCiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuCiAqLwpmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkgewogIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZyQxLmNhbGwodmFsdWUpOwp9CgovKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovCnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nOwp2YXIgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7CgovKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi8KdmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sJDEgPyBTeW1ib2wkMS50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC4KICovCmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHsKICBpZiAodmFsdWUgPT0gbnVsbCkgewogICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnOwogIH0KICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpCiAgICA/IGdldFJhd1RhZyh2YWx1ZSkKICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpOwp9CgovKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovCnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJzsKdmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nOwp2YXIgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJzsKdmFyIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJzsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDAuMS4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNGdW5jdGlvbihfKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzRnVuY3Rpb24oL2FiYy8pOwogKiAvLyA9PiBmYWxzZQogKi8KZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkgewogIGlmICghaXNPYmplY3QodmFsdWUpKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvcgogIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLgogIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTsKICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnOwp9CgovKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi8KdmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxOwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguCiAqCiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uCiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDQuMC4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzTGVuZ3RoKDMpOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7CiAqIC8vID0+IGZhbHNlCiAqCiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpOwogKiAvLyA9PiBmYWxzZQogKgogKiBfLmlzTGVuZ3RoKCczJyk7CiAqIC8vID0+IGZhbHNlCiAqLwpmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkgewogIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYKICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjsKfQoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3MKICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvcgogKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSA0LjAuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7CiAqIC8vID0+IGZhbHNlCiAqLwpmdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkgewogIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpOwp9CgovLyBBIHRlbXBvcmFyeSB2YWx1ZSB1c2VkIHRvIGlkZW50aWZ5IGlmIHRoZSBsb29wIHNob3VsZCBiZSBicm9rZW4uCi8vIFNlZSAjMTA2NCwgIzEyOTMKdmFyIGJyZWFrTG9vcCA9IHt9OwoKLyoqCiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDIuMy4wCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBleGFtcGxlCiAqCiAqIF8udGltZXMoMiwgXy5ub29wKTsKICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXQogKi8KZnVuY3Rpb24gbm9vcCgpIHsKICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLgp9CgpmdW5jdGlvbiBvbmNlKGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgIGlmIChmbiA9PT0gbnVsbCkgcmV0dXJuOwogICAgICAgIHZhciBjYWxsRm4gPSBmbjsKICAgICAgICBmbiA9IG51bGw7CiAgICAgICAgY2FsbEZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICB9Owp9Cgp2YXIgaXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjsKCnZhciBnZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChjb2xsKSB7CiAgICByZXR1cm4gaXRlcmF0b3JTeW1ib2wgJiYgY29sbFtpdGVyYXRvclN5bWJvbF0gJiYgY29sbFtpdGVyYXRvclN5bWJvbF0oKTsKfTsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzCiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuCiAqLwpmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgcmVzdWx0ID0gQXJyYXkobik7CgogIHdoaWxlICgrK2luZGV4IDwgbikgewogICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTsKICB9CiAgcmV0dXJuIHJlc3VsdDsKfQoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYAogKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mICJvYmplY3QiLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSA0LjAuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc09iamVjdExpa2Uoe30pOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7CiAqIC8vID0+IHRydWUKICoKICogXy5pc09iamVjdExpa2UoXy5ub29wKTsKICogLy8gPT4gZmFsc2UKICoKICogXy5pc09iamVjdExpa2UobnVsbCk7CiAqIC8vID0+IGZhbHNlCiAqLwpmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHsKICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7Cn0KCi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi8KdmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJzsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsCiAqLwpmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHsKICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnOwp9CgovKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovCnZhciBvYmplY3RQcm90byQzID0gT2JqZWN0LnByb3RvdHlwZTsKCi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqLwp2YXIgaGFzT3duUHJvcGVydHkkMiA9IG9iamVjdFByb3RvJDMuaGFzT3duUHJvcGVydHk7CgovKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi8KdmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8kMy5wcm9wZXJ0eUlzRW51bWVyYWJsZTsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAwLjEuMAogKiBAY2F0ZWdvcnkgTGFuZwogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LAogKiAgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTsKICogLy8gPT4gZmFsc2UKICovCnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7CiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkkMi5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiYKICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7Cn07CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgMC4xLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNBcnJheShbMSwgMiwgM10pOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTsKICogLy8gPT4gZmFsc2UKICoKICogXy5pc0FycmF5KCdhYmMnKTsKICogLy8gPT4gZmFsc2UKICoKICogXy5pc0FycmF5KF8ubm9vcCk7CiAqIC8vID0+IGZhbHNlCiAqLwp2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7CgovKioKICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSA0LjEzLjAKICogQGNhdGVnb3J5IFV0aWwKICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7CiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdCiAqLwpmdW5jdGlvbiBzdHViRmFsc2UoKSB7CiAgcmV0dXJuIGZhbHNlOwp9CgovKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqLwp2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7CgovKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovCnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CgovKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqLwp2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0czsKCi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqLwp2YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkOwoKLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqLwp2YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDQuMy4wCiAqIEBjYXRlZ29yeSBMYW5nCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLgogKiBAZXhhbXBsZQogKgogKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpOwogKiAvLyA9PiBmYWxzZQogKi8KdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlOwoKLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovCnZhciBNQVhfU0FGRV9JTlRFR0VSJDEgPSA5MDA3MTk5MjU0NzQwOTkxOwoKLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqLwp2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cZCopJC87CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay4KICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuCiAqLwpmdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHsKICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIkMSA6IGxlbmd0aDsKICByZXR1cm4gISFsZW5ndGggJiYKICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmCiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7Cn0KCi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi8KdmFyIGFyZ3NUYWckMSA9ICdbb2JqZWN0IEFyZ3VtZW50c10nOwp2YXIgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nOwp2YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJzsKdmFyIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXSc7CnZhciBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXSc7CnZhciBmdW5jVGFnJDEgPSAnW29iamVjdCBGdW5jdGlvbl0nOwp2YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7CnZhciBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJzsKdmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nOwp2YXIgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXSc7CnZhciBzZXRUYWcgPSAnW29iamVjdCBTZXRdJzsKdmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nOwp2YXIgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJzsKCnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7CnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7CnZhciBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XSc7CnZhciBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc7CnZhciBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XSc7CnZhciBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJzsKdmFyIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nOwp2YXIgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XSc7CnZhciB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOwp2YXIgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJzsKdmFyIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7CgovKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovCnZhciB0eXBlZEFycmF5VGFncyA9IHt9Owp0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID0KdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPQp0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPQp0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9CnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlOwp0eXBlZEFycmF5VGFnc1thcmdzVGFnJDFdID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID0KdHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPQp0eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9CnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWckMV0gPQp0eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9CnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID0KdHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPQp0eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlOwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuCiAqLwpmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7CiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYKICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07Cn0KCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci4KICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLgogKi8KZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHsKICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHsKICAgIHJldHVybiBmdW5jKHZhbHVlKTsKICB9Owp9CgovKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqLwp2YXIgZnJlZUV4cG9ydHMkMSA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0czsKCi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi8KdmFyIGZyZWVNb2R1bGUkMSA9IGZyZWVFeHBvcnRzJDEgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7CgovKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqLwp2YXIgbW9kdWxlRXhwb3J0cyQxID0gZnJlZU1vZHVsZSQxICYmIGZyZWVNb2R1bGUkMS5leHBvcnRzID09PSBmcmVlRXhwb3J0cyQxOwoKLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovCnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMkMSAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7CgovKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi8KdmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkgewogIHRyeSB7CiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7CiAgfSBjYXRjaCAoZSkge30KfSgpKTsKCi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovCnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5OwoKLyoqCiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgMy4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC4KICogQGV4YW1wbGUKICoKICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpOwogKiAvLyA9PiB0cnVlCiAqCiAqIF8uaXNUeXBlZEFycmF5KFtdKTsKICogLy8gPT4gZmFsc2UKICovCnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTsKCi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi8KdmFyIG9iamVjdFByb3RvJDIgPSBPYmplY3QucHJvdG90eXBlOwoKLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovCnZhciBoYXNPd25Qcm9wZXJ0eSQxID0gb2JqZWN0UHJvdG8kMi5oYXNPd25Qcm9wZXJ0eTsKCi8qKgogKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LgogKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuCiAqLwpmdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHsKICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSwKICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLAogICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSwKICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksCiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSwKICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sCiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7CgogIGZvciAodmFyIGtleSBpbiB2YWx1ZSkgewogICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkkMS5jYWxsKHZhbHVlLCBrZXkpKSAmJgogICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKAogICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS4KICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHwKICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy4KICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHwKICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuCiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8CiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLgogICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpCiAgICAgICAgKSkpIHsKICAgICAgcmVzdWx0LnB1c2goa2V5KTsKICAgIH0KICB9CiAgcmV0dXJuIHJlc3VsdDsKfQoKLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqLwp2YXIgb2JqZWN0UHJvdG8kNSA9IE9iamVjdC5wcm90b3R5cGU7CgovKioKICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuCiAqLwpmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkgewogIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsCiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvJDU7CgogIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87Cn0KCi8qKgogKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC4KICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLgogKi8KZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHsKICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7CiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7CiAgfTsKfQoKLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqLwp2YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7CgovKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovCnZhciBvYmplY3RQcm90byQ0ID0gT2JqZWN0LnByb3RvdHlwZTsKCi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqLwp2YXIgaGFzT3duUHJvcGVydHkkMyA9IG9iamVjdFByb3RvJDQuaGFzT3duUHJvcGVydHk7CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuCiAqLwpmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHsKICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHsKICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7CiAgfQogIHZhciByZXN1bHQgPSBbXTsKICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHsKICAgIGlmIChoYXNPd25Qcm9wZXJ0eSQzLmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7CiAgICAgIHJlc3VsdC5wdXNoKGtleSk7CiAgICB9CiAgfQogIHJldHVybiByZXN1bHQ7Cn0KCi8qKgogKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC4KICoKICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGUKICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKQogKiBmb3IgbW9yZSBkZXRhaWxzLgogKgogKiBAc3RhdGljCiAqIEBzaW5jZSAwLjEuMAogKiBAbWVtYmVyT2YgXwogKiBAY2F0ZWdvcnkgT2JqZWN0CiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy4KICogQGV4YW1wbGUKICoKICogZnVuY3Rpb24gRm9vKCkgewogKiAgIHRoaXMuYSA9IDE7CiAqICAgdGhpcy5iID0gMjsKICogfQogKgogKiBGb28ucHJvdG90eXBlLmMgPSAzOwogKgogKiBfLmtleXMobmV3IEZvbyk7CiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkKICoKICogXy5rZXlzKCdoaScpOwogKiAvLyA9PiBbJzAnLCAnMSddCiAqLwpmdW5jdGlvbiBrZXlzKG9iamVjdCkgewogIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTsKfQoKZnVuY3Rpb24gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKSB7CiAgICB2YXIgaSA9IC0xOwogICAgdmFyIGxlbiA9IGNvbGwubGVuZ3RoOwogICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7CiAgICAgICAgcmV0dXJuICsraSA8IGxlbiA/IHt2YWx1ZTogY29sbFtpXSwga2V5OiBpfSA6IG51bGw7CiAgICB9Cn0KCmZ1bmN0aW9uIGNyZWF0ZUVTMjAxNUl0ZXJhdG9yKGl0ZXJhdG9yKSB7CiAgICB2YXIgaSA9IC0xOwogICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7CiAgICAgICAgdmFyIGl0ZW0gPSBpdGVyYXRvci5uZXh0KCk7CiAgICAgICAgaWYgKGl0ZW0uZG9uZSkKICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgaSsrOwogICAgICAgIHJldHVybiB7dmFsdWU6IGl0ZW0udmFsdWUsIGtleTogaX07CiAgICB9Cn0KCmZ1bmN0aW9uIGNyZWF0ZU9iamVjdEl0ZXJhdG9yKG9iaikgewogICAgdmFyIG9rZXlzID0ga2V5cyhvYmopOwogICAgdmFyIGkgPSAtMTsKICAgIHZhciBsZW4gPSBva2V5cy5sZW5ndGg7CiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHsKICAgICAgICB2YXIga2V5ID0gb2tleXNbKytpXTsKICAgICAgICByZXR1cm4gaSA8IGxlbiA/IHt2YWx1ZTogb2JqW2tleV0sIGtleToga2V5fSA6IG51bGw7CiAgICB9Owp9CgpmdW5jdGlvbiBpdGVyYXRvcihjb2xsKSB7CiAgICBpZiAoaXNBcnJheUxpa2UoY29sbCkpIHsKICAgICAgICByZXR1cm4gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKTsKICAgIH0KCiAgICB2YXIgaXRlcmF0b3IgPSBnZXRJdGVyYXRvcihjb2xsKTsKICAgIHJldHVybiBpdGVyYXRvciA/IGNyZWF0ZUVTMjAxNUl0ZXJhdG9yKGl0ZXJhdG9yKSA6IGNyZWF0ZU9iamVjdEl0ZXJhdG9yKGNvbGwpOwp9CgpmdW5jdGlvbiBvbmx5T25jZShmbikgewogICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgIGlmIChmbiA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCJDYWxsYmFjayB3YXMgYWxyZWFkeSBjYWxsZWQuIik7CiAgICAgICAgdmFyIGNhbGxGbiA9IGZuOwogICAgICAgIGZuID0gbnVsbDsKICAgICAgICBjYWxsRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgIH07Cn0KCmZ1bmN0aW9uIF9lYWNoT2ZMaW1pdChsaW1pdCkgewogICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgICAgICBpZiAobGltaXQgPD0gMCB8fCAhb2JqKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTsKICAgICAgICB9CiAgICAgICAgdmFyIG5leHRFbGVtID0gaXRlcmF0b3Iob2JqKTsKICAgICAgICB2YXIgZG9uZSA9IGZhbHNlOwogICAgICAgIHZhciBydW5uaW5nID0gMDsKCiAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZWVDYWxsYmFjayhlcnIsIHZhbHVlKSB7CiAgICAgICAgICAgIHJ1bm5pbmcgLT0gMTsKICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7CiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBicmVha0xvb3AgfHwgKGRvbmUgJiYgcnVubmluZyA8PSAwKSkgewogICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7CiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICByZXBsZW5pc2goKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gcmVwbGVuaXNoICgpIHsKICAgICAgICAgICAgd2hpbGUgKHJ1bm5pbmcgPCBsaW1pdCAmJiAhZG9uZSkgewogICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBuZXh0RWxlbSgpOwogICAgICAgICAgICAgICAgaWYgKGVsZW0gPT09IG51bGwpIHsKICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZyA8PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBydW5uaW5nICs9IDE7CiAgICAgICAgICAgICAgICBpdGVyYXRlZShlbGVtLnZhbHVlLCBlbGVtLmtleSwgb25seU9uY2UoaXRlcmF0ZWVDYWxsYmFjaykpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXBsZW5pc2goKTsKICAgIH07Cn0KCi8qKgogKiBUaGUgc2FtZSBhcyBbYGVhY2hPZmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYQogKiB0aW1lLgogKgogKiBAbmFtZSBlYWNoT2ZMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5lYWNoT2Zde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNoT2Z9CiAqIEBhbGlhcyBmb3JFYWNoT2ZMaW1pdAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2gKICogaXRlbSBpbiBgY29sbGAuIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW4KICogYXJyYXkuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS4KICovCmZ1bmN0aW9uIGVhY2hPZkxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIF9lYWNoT2ZMaW1pdChsaW1pdCkoY29sbCwgd3JhcEFzeW5jKGl0ZXJhdGVlKSwgY2FsbGJhY2spOwp9CgpmdW5jdGlvbiBkb0xpbWl0KGZuLCBsaW1pdCkgewogICAgcmV0dXJuIGZ1bmN0aW9uIChpdGVyYWJsZSwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICAgICAgcmV0dXJuIGZuKGl0ZXJhYmxlLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTsKICAgIH07Cn0KCi8vIGVhY2hPZiBpbXBsZW1lbnRhdGlvbiBvcHRpbWl6ZWQgZm9yIGFycmF5LWxpa2VzCmZ1bmN0aW9uIGVhY2hPZkFycmF5TGlrZShjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBpbmRleCA9IDAsCiAgICAgICAgY29tcGxldGVkID0gMCwKICAgICAgICBsZW5ndGggPSBjb2xsLmxlbmd0aDsKICAgIGlmIChsZW5ndGggPT09IDApIHsKICAgICAgICBjYWxsYmFjayhudWxsKTsKICAgIH0KCiAgICBmdW5jdGlvbiBpdGVyYXRvckNhbGxiYWNrKGVyciwgdmFsdWUpIHsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgIGNhbGxiYWNrKGVycik7CiAgICAgICAgfSBlbHNlIGlmICgoKytjb21wbGV0ZWQgPT09IGxlbmd0aCkgfHwgdmFsdWUgPT09IGJyZWFrTG9vcCkgewogICAgICAgICAgICBjYWxsYmFjayhudWxsKTsKICAgICAgICB9CiAgICB9CgogICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7CiAgICAgICAgaXRlcmF0ZWUoY29sbFtpbmRleF0sIGluZGV4LCBvbmx5T25jZShpdGVyYXRvckNhbGxiYWNrKSk7CiAgICB9Cn0KCi8vIGEgZ2VuZXJpYyB2ZXJzaW9uIG9mIGVhY2hPZiB3aGljaCBjYW4gaGFuZGxlIGFycmF5LCBvYmplY3QsIGFuZCBpdGVyYXRvciBjYXNlcy4KdmFyIGVhY2hPZkdlbmVyaWMgPSBkb0xpbWl0KGVhY2hPZkxpbWl0LCBJbmZpbml0eSk7CgovKioKICogTGlrZSBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0sIGV4Y2VwdCB0aGF0IGl0IHBhc3NlcyB0aGUga2V5IChvciBpbmRleCkgYXMgdGhlIHNlY29uZCBhcmd1bWVudAogKiB0byB0aGUgaXRlcmF0ZWUuCiAqCiAqIEBuYW1lIGVhY2hPZgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAYWxpYXMgZm9yRWFjaE9mCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBzZWUgW2FzeW5jLmVhY2hde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofQogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2gKICogaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBga2V5YCBpcyB0aGUgaXRlbSdzIGtleSwgb3IgaW5kZXggaW4gdGhlIGNhc2Ugb2YgYW4gYXJyYXkuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS4KICogQGV4YW1wbGUKICoKICogdmFyIG9iaiA9IHtkZXY6ICIvZGV2Lmpzb24iLCB0ZXN0OiAiL3Rlc3QuanNvbiIsIHByb2Q6ICIvcHJvZC5qc29uIn07CiAqIHZhciBjb25maWdzID0ge307CiAqCiAqIGFzeW5jLmZvckVhY2hPZihvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBjYWxsYmFjaykgewogKiAgICAgZnMucmVhZEZpbGUoX19kaXJuYW1lICsgdmFsdWUsICJ1dGY4IiwgZnVuY3Rpb24gKGVyciwgZGF0YSkgewogKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogKiAgICAgICAgIHRyeSB7CiAqICAgICAgICAgICAgIGNvbmZpZ3Nba2V5XSA9IEpTT04ucGFyc2UoZGF0YSk7CiAqICAgICAgICAgfSBjYXRjaCAoZSkgewogKiAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7CiAqICAgICAgICAgfQogKiAgICAgICAgIGNhbGxiYWNrKCk7CiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24gKGVycikgewogKiAgICAgaWYgKGVycikgY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSk7CiAqICAgICAvLyBjb25maWdzIGlzIG5vdyBhIG1hcCBvZiBKU09OIGRhdGEKICogICAgIGRvU29tZXRoaW5nV2l0aChjb25maWdzKTsKICogfSk7CiAqLwp2YXIgZWFjaE9mID0gZnVuY3Rpb24oY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICB2YXIgZWFjaE9mSW1wbGVtZW50YXRpb24gPSBpc0FycmF5TGlrZShjb2xsKSA/IGVhY2hPZkFycmF5TGlrZSA6IGVhY2hPZkdlbmVyaWM7CiAgICBlYWNoT2ZJbXBsZW1lbnRhdGlvbihjb2xsLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7Cn07CgpmdW5jdGlvbiBkb1BhcmFsbGVsKGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICAgICAgcmV0dXJuIGZuKGVhY2hPZiwgb2JqLCB3cmFwQXN5bmMoaXRlcmF0ZWUpLCBjYWxsYmFjayk7CiAgICB9Owp9CgpmdW5jdGlvbiBfYXN5bmNNYXAoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wOwogICAgYXJyID0gYXJyIHx8IFtdOwogICAgdmFyIHJlc3VsdHMgPSBbXTsKICAgIHZhciBjb3VudGVyID0gMDsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwoKICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh2YWx1ZSwgXywgY2FsbGJhY2spIHsKICAgICAgICB2YXIgaW5kZXggPSBjb3VudGVyKys7CiAgICAgICAgX2l0ZXJhdGVlKHZhbHVlLCBmdW5jdGlvbiAoZXJyLCB2KSB7CiAgICAgICAgICAgIHJlc3VsdHNbaW5kZXhdID0gdjsKICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdHMpOwogICAgfSk7Cn0KCi8qKgogKiBQcm9kdWNlcyBhIG5ldyBjb2xsZWN0aW9uIG9mIHZhbHVlcyBieSBtYXBwaW5nIGVhY2ggdmFsdWUgaW4gYGNvbGxgIHRocm91Z2gKICogdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb24uIFRoZSBgaXRlcmF0ZWVgIGlzIGNhbGxlZCB3aXRoIGFuIGl0ZW0gZnJvbSBgY29sbGAKICogYW5kIGEgY2FsbGJhY2sgZm9yIHdoZW4gaXQgaGFzIGZpbmlzaGVkIHByb2Nlc3NpbmcuIEVhY2ggb2YgdGhlc2UgY2FsbGJhY2sKICogdGFrZXMgMiBhcmd1bWVudHM6IGFuIGBlcnJvcmAsIGFuZCB0aGUgdHJhbnNmb3JtZWQgaXRlbSBmcm9tIGBjb2xsYC4gSWYKICogYGl0ZXJhdGVlYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIChmb3IgdGhlCiAqIGBtYXBgIGZ1bmN0aW9uKSBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuCiAqCiAqIE5vdGUsIHRoYXQgc2luY2UgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIHRoZSBgaXRlcmF0ZWVgIHRvIGVhY2ggaXRlbSBpbgogKiBwYXJhbGxlbCwgdGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIHdpbGwgY29tcGxldGUKICogaW4gb3JkZXIuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIGFycmF5IHdpbGwgYmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlCiAqIG9yaWdpbmFsIGBjb2xsYC4KICoKICogSWYgYG1hcGAgaXMgcGFzc2VkIGFuIE9iamVjdCwgdGhlIHJlc3VsdHMgd2lsbCBiZSBhbiBBcnJheS4gIFRoZSByZXN1bHRzCiAqIHdpbGwgcm91Z2hseSBiZSBpbiB0aGUgb3JkZXIgb2YgdGhlIG9yaWdpbmFsIE9iamVjdHMnIGtleXMgKGJ1dCB0aGlzIGNhbgogKiB2YXJ5IGFjcm9zcyBKYXZhU2NyaXB0IGVuZ2luZXMpLgogKgogKiBAbmFtZSBtYXAKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBpdGVtLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBBcnJheSBvZiB0aGUKICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLm1hcChbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmcy5zdGF0LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHN0YXRzIGZvciBlYWNoIGZpbGUKICogfSk7CiAqLwp2YXIgbWFwID0gZG9QYXJhbGxlbChfYXN5bmNNYXApOwoKLyoqCiAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIGFyZ3VtZW50cyB0byBlYWNoIGZ1bmN0aW9uIGluIHRoZSBhcnJheSwgY2FsbGluZwogKiBgY2FsbGJhY2tgIGFmdGVyIGFsbCBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQuIElmIHlvdSBvbmx5IHByb3ZpZGUgdGhlIGZpcnN0CiAqIGFyZ3VtZW50LCBgZm5zYCwgdGhlbiBpdCB3aWxsIHJldHVybiBhIGZ1bmN0aW9uIHdoaWNoIGxldHMgeW91IHBhc3MgaW4gdGhlCiAqIGFyZ3VtZW50cyBhcyBpZiBpdCB3ZXJlIGEgc2luZ2xlIGZ1bmN0aW9uIGNhbGwuIElmIG1vcmUgYXJndW1lbnRzIGFyZQogKiBwcm92aWRlZCwgYGNhbGxiYWNrYCBpcyByZXF1aXJlZCB3aGlsZSBgYXJnc2AgaXMgc3RpbGwgb3B0aW9uYWwuCiAqCiAqIEBuYW1lIGFwcGx5RWFjaAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBmbnMgLSBBIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFzeW5jRnVuY3Rpb259cwogKiB0byBhbGwgY2FsbCB3aXRoIHRoZSBzYW1lIGFyZ3VtZW50cwogKiBAcGFyYW0gey4uLip9IFthcmdzXSAtIGFueSBudW1iZXIgb2Ygc2VwYXJhdGUgYXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlCiAqIGZ1bmN0aW9uLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gdGhlIGZpbmFsIGFyZ3VtZW50IHNob3VsZCBiZSB0aGUgY2FsbGJhY2ssCiAqIGNhbGxlZCB3aGVuIGFsbCBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgcHJvY2Vzc2luZy4KICogQHJldHVybnMge0Z1bmN0aW9ufSAtIElmIG9ubHkgdGhlIGZpcnN0IGFyZ3VtZW50LCBgZm5zYCwgaXMgcHJvdmlkZWQsIGl0IHdpbGwKICogcmV0dXJuIGEgZnVuY3Rpb24gd2hpY2ggbGV0cyB5b3UgcGFzcyBpbiB0aGUgYXJndW1lbnRzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGUKICogZnVuY3Rpb24gY2FsbC4gVGhlIHNpZ25hdHVyZSBpcyBgKC4uYXJncywgY2FsbGJhY2spYC4gSWYgaW52b2tlZCB3aXRoIGFueQogKiBhcmd1bWVudHMsIGBjYWxsYmFja2AgaXMgcmVxdWlyZWQuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmFwcGx5RWFjaChbZW5hYmxlU2VhcmNoLCB1cGRhdGVTY2hlbWFdLCAnYnVja2V0JywgY2FsbGJhY2spOwogKgogKiAvLyBwYXJ0aWFsIGFwcGxpY2F0aW9uIGV4YW1wbGU6CiAqIGFzeW5jLmVhY2goCiAqICAgICBidWNrZXRzLAogKiAgICAgYXN5bmMuYXBwbHlFYWNoKFtlbmFibGVTZWFyY2gsIHVwZGF0ZVNjaGVtYV0pLAogKiAgICAgY2FsbGJhY2sKICogKTsKICovCnZhciBhcHBseUVhY2ggPSBhcHBseUVhY2gkMShtYXApOwoKZnVuY3Rpb24gZG9QYXJhbGxlbExpbWl0KGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgICAgIHJldHVybiBmbihfZWFjaE9mTGltaXQobGltaXQpLCBvYmosIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrKTsKICAgIH07Cn0KCi8qKgogKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKgogKiBAbmFtZSBtYXBMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBpdGVtLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheSBvZiB0aGUKICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgbWFwTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2FzeW5jTWFwKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYG1hcGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgbWFwU2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLm1hcF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCBpdGVtLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheSBvZiB0aGUKICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgbWFwU2VyaWVzID0gZG9MaW1pdChtYXBMaW1pdCwgMSk7CgovKioKICogVGhlIHNhbWUgYXMgW2BhcHBseUVhY2hgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXBwbHlFYWNofSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGFwcGx5RWFjaFNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5hcHBseUVhY2hde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5hcHBseUVhY2h9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGZucyAtIEEgY29sbGVjdGlvbiBvZiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIHRvIGFsbAogKiBjYWxsIHdpdGggdGhlIHNhbWUgYXJndW1lbnRzCiAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIC0gYW55IG51bWJlciBvZiBzZXBhcmF0ZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUKICogZnVuY3Rpb24uCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSB0aGUgZmluYWwgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSBjYWxsYmFjaywKICogY2FsbGVkIHdoZW4gYWxsIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBwcm9jZXNzaW5nLgogKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gSWYgb25seSB0aGUgZmlyc3QgYXJndW1lbnQgaXMgcHJvdmlkZWQsIGl0IHdpbGwgcmV0dXJuCiAqIGEgZnVuY3Rpb24gd2hpY2ggbGV0cyB5b3UgcGFzcyBpbiB0aGUgYXJndW1lbnRzIGFzIGlmIGl0IHdlcmUgYSBzaW5nbGUKICogZnVuY3Rpb24gY2FsbC4KICovCnZhciBhcHBseUVhY2hTZXJpZXMgPSBhcHBseUVhY2gkMShtYXBTZXJpZXMpOwoKLyoqCiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IKICogaXRlcmF0ZWUgc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC4KICovCmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7CgogIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkgewogICAgICBicmVhazsKICAgIH0KICB9CiAgcmV0dXJuIGFycmF5Owp9CgovKioKICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LgogKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLgogKi8KZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHsKICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHsKICAgIHZhciBpbmRleCA9IC0xLAogICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksCiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLAogICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDsKCiAgICB3aGlsZSAobGVuZ3RoLS0pIHsKICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdOwogICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBvYmplY3Q7CiAgfTsKfQoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgCiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LgogKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uCiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuCiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuCiAqLwp2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTsKCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi4KICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC4KICovCmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkgewogIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTsKfQoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXQKICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuCiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS4KICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuCiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuCiAqLwpmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7CiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwKICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTsKCiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHsKICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7CiAgICAgIHJldHVybiBpbmRleDsKICAgIH0KICB9CiAgcmV0dXJuIC0xOwp9CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLgogKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgTmFOYCwgZWxzZSBgZmFsc2VgLgogKi8KZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7CiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTsKfQoKLyoqCiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHkKICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC4KICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci4KICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uCiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuCiAqLwpmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7CiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSwKICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwoKICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkgewogICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHsKICAgICAgcmV0dXJuIGluZGV4OwogICAgfQogIH0KICByZXR1cm4gLTE7Cn0KCi8qKgogKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LgogKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLgogKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS4KICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC4KICovCmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7CiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZQogICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KQogICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7Cn0KCi8qKgogKiBEZXRlcm1pbmVzIHRoZSBiZXN0IG9yZGVyIGZvciBydW5uaW5nIHRoZSB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGluIGB0YXNrc2AsIGJhc2VkIG9uCiAqIHRoZWlyIHJlcXVpcmVtZW50cy4gRWFjaCBmdW5jdGlvbiBjYW4gb3B0aW9uYWxseSBkZXBlbmQgb24gb3RoZXIgZnVuY3Rpb25zCiAqIGJlaW5nIGNvbXBsZXRlZCBmaXJzdCwgYW5kIGVhY2ggZnVuY3Rpb24gaXMgcnVuIGFzIHNvb24gYXMgaXRzIHJlcXVpcmVtZW50cwogKiBhcmUgc2F0aXNmaWVkLgogKgogKiBJZiBhbnkgb2YgdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufXMgcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjaywgdGhlIGBhdXRvYCBzZXF1ZW5jZQogKiB3aWxsIHN0b3AuIEZ1cnRoZXIgdGFza3Mgd2lsbCBub3QgZXhlY3V0ZSAoc28gYW55IG90aGVyIGZ1bmN0aW9ucyBkZXBlbmRpbmcKICogb24gaXQgd2lsbCBub3QgcnVuKSwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlCiAqIGVycm9yLgogKgogKiB7QGxpbmsgQXN5bmNGdW5jdGlvbn1zIGFsc28gcmVjZWl2ZSBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVzdWx0cyBvZiBmdW5jdGlvbnMgd2hpY2gKICogaGF2ZSBjb21wbGV0ZWQgc28gZmFyIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgaWYgdGhleSBoYXZlIGRlcGVuZGVuY2llcy4gSWYgYQogKiB0YXNrIGZ1bmN0aW9uIGhhcyBubyBkZXBlbmRlbmNpZXMsIGl0IHdpbGwgb25seSBiZSBwYXNzZWQgYSBjYWxsYmFjay4KICoKICogQG5hbWUgYXV0bwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7T2JqZWN0fSB0YXNrcyAtIEFuIG9iamVjdC4gRWFjaCBvZiBpdHMgcHJvcGVydGllcyBpcyBlaXRoZXIgYQogKiBmdW5jdGlvbiBvciBhbiBhcnJheSBvZiByZXF1aXJlbWVudHMsIHdpdGggdGhlIHtAbGluayBBc3luY0Z1bmN0aW9ufSBpdHNlbGYgdGhlIGxhc3QgaXRlbQogKiBpbiB0aGUgYXJyYXkuIFRoZSBvYmplY3QncyBrZXkgb2YgYSBwcm9wZXJ0eSBzZXJ2ZXMgYXMgdGhlIG5hbWUgb2YgdGhlIHRhc2sKICogZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yCiAqIG90aGVyIHRhc2tzLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgb25lIG9yIHR3byBhcmd1bWVudHM6CiAqICogYSBgcmVzdWx0c2Agb2JqZWN0LCBjb250YWluaW5nIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91c2x5IGV4ZWN1dGVkCiAqICAgZnVuY3Rpb25zLCBvbmx5IHBhc3NlZCBpZiB0aGUgdGFzayBoYXMgYW55IGRlcGVuZGVuY2llcywKICogKiBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGZ1bmN0aW9uLCB3aGljaCBtdXN0IGJlIGNhbGxlZCB3aGVuIGZpbmlzaGVkLAogKiAgIHBhc3NpbmcgYW4gYGVycm9yYCAod2hpY2ggY2FuIGJlIGBudWxsYCkgYW5kIHRoZSByZXN1bHQgb2YgdGhlIGZ1bmN0aW9uJ3MKICogICBleGVjdXRpb24uCiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uY3VycmVuY3k9SW5maW5pdHldIC0gQW4gb3B0aW9uYWwgYGludGVnZXJgIGZvcgogKiBkZXRlcm1pbmluZyB0aGUgbWF4aW11bSBudW1iZXIgb2YgdGFza3MgdGhhdCBjYW4gYmUgcnVuIGluIHBhcmFsbGVsLiBCeQogKiBkZWZhdWx0LCBhcyBtYW55IGFzIHBvc3NpYmxlLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsCiAqIHRoZSB0YXNrcyBoYXZlIGJlZW4gY29tcGxldGVkLiBJdCByZWNlaXZlcyB0aGUgYGVycmAgYXJndW1lbnQgaWYgYW55IGB0YXNrc2AKICogcGFzcyBhbiBlcnJvciB0byB0aGVpciBjYWxsYmFjay4gUmVzdWx0cyBhcmUgYWx3YXlzIHJldHVybmVkOyBob3dldmVyLCBpZiBhbgogKiBlcnJvciBvY2N1cnMsIG5vIGZ1cnRoZXIgYHRhc2tzYCB3aWxsIGJlIHBlcmZvcm1lZCwgYW5kIHRoZSByZXN1bHRzIG9iamVjdAogKiB3aWxsIG9ubHkgY29udGFpbiBwYXJ0aWFsIHJlc3VsdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICogQHJldHVybnMgdW5kZWZpbmVkCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmF1dG8oewogKiAgICAgLy8gdGhpcyBmdW5jdGlvbiB3aWxsIGp1c3QgYmUgcGFzc2VkIGEgY2FsbGJhY2sKICogICAgIHJlYWREYXRhOiBhc3luYy5hcHBseShmcy5yZWFkRmlsZSwgJ2RhdGEudHh0JywgJ3V0Zi04JyksCiAqICAgICBzaG93RGF0YTogWydyZWFkRGF0YScsIGZ1bmN0aW9uKHJlc3VsdHMsIGNiKSB7CiAqICAgICAgICAgLy8gcmVzdWx0cy5yZWFkRGF0YSBpcyB0aGUgZmlsZSdzIGNvbnRlbnRzCiAqICAgICAgICAgLy8gLi4uCiAqICAgICB9XQogKiB9LCBjYWxsYmFjayk7CiAqCiAqIGFzeW5jLmF1dG8oewogKiAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgY29uc29sZS5sb2coJ2luIGdldF9kYXRhJyk7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7CiAqICAgICB9LAogKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgY29uc29sZS5sb2coJ2luIG1ha2VfZm9sZGVyJyk7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluCiAqICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpOwogKiAgICAgfSwKICogICAgIHdyaXRlX2ZpbGU6IFsnZ2V0X2RhdGEnLCAnbWFrZV9mb2xkZXInLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiB3cml0ZV9maWxlJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0cykpOwogKiAgICAgICAgIC8vIG9uY2UgdGhlcmUgaXMgc29tZSBkYXRhIGFuZCB0aGUgZGlyZWN0b3J5IGV4aXN0cywKICogICAgICAgICAvLyB3cml0ZSB0aGUgZGF0YSB0byBhIGZpbGUgaW4gdGhlIGRpcmVjdG9yeQogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpOwogKiAgICAgfV0sCiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbihyZXN1bHRzLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNvbnNvbGUubG9nKCdpbiBlbWFpbF9saW5rJywgSlNPTi5zdHJpbmdpZnkocmVzdWx0cykpOwogKiAgICAgICAgIC8vIG9uY2UgdGhlIGZpbGUgaXMgd3JpdHRlbiBsZXQncyBlbWFpbCBhIGxpbmsgdG8gaXQuLi4KICogICAgICAgICAvLyByZXN1bHRzLndyaXRlX2ZpbGUgY29udGFpbnMgdGhlIGZpbGVuYW1lIHJldHVybmVkIGJ5IHdyaXRlX2ZpbGUuCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgeydmaWxlJzpyZXN1bHRzLndyaXRlX2ZpbGUsICdlbWFpbCc6J3VzZXJAZXhhbXBsZS5jb20nfSk7CiAqICAgICB9XQogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIGNvbnNvbGUubG9nKCdlcnIgPSAnLCBlcnIpOwogKiAgICAgY29uc29sZS5sb2coJ3Jlc3VsdHMgPSAnLCByZXN1bHRzKTsKICogfSk7CiAqLwp2YXIgYXV0byA9IGZ1bmN0aW9uICh0YXNrcywgY29uY3VycmVuY3ksIGNhbGxiYWNrKSB7CiAgICBpZiAodHlwZW9mIGNvbmN1cnJlbmN5ID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgLy8gY29uY3VycmVuY3kgaXMgb3B0aW9uYWwsIHNoaWZ0IHRoZSBhcmdzLgogICAgICAgIGNhbGxiYWNrID0gY29uY3VycmVuY3k7CiAgICAgICAgY29uY3VycmVuY3kgPSBudWxsOwogICAgfQogICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIGtleXMkJDEgPSBrZXlzKHRhc2tzKTsKICAgIHZhciBudW1UYXNrcyA9IGtleXMkJDEubGVuZ3RoOwogICAgaWYgKCFudW1UYXNrcykgewogICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKTsKICAgIH0KICAgIGlmICghY29uY3VycmVuY3kpIHsKICAgICAgICBjb25jdXJyZW5jeSA9IG51bVRhc2tzOwogICAgfQoKICAgIHZhciByZXN1bHRzID0ge307CiAgICB2YXIgcnVubmluZ1Rhc2tzID0gMDsKICAgIHZhciBoYXNFcnJvciA9IGZhbHNlOwoKICAgIHZhciBsaXN0ZW5lcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOwoKICAgIHZhciByZWFkeVRhc2tzID0gW107CgogICAgLy8gZm9yIGN5Y2xlIGRldGVjdGlvbjoKICAgIHZhciByZWFkeVRvQ2hlY2sgPSBbXTsgLy8gdGFza3MgdGhhdCBoYXZlIGJlZW4gaWRlbnRpZmllZCBhcyByZWFjaGFibGUKICAgIC8vIHdpdGhvdXQgdGhlIHBvc3NpYmlsaXR5IG9mIHJldHVybmluZyB0byBhbiBhbmNlc3RvciB0YXNrCiAgICB2YXIgdW5jaGVja2VkRGVwZW5kZW5jaWVzID0ge307CgogICAgYmFzZUZvck93bih0YXNrcywgZnVuY3Rpb24gKHRhc2ssIGtleSkgewogICAgICAgIGlmICghaXNBcnJheSh0YXNrKSkgewogICAgICAgICAgICAvLyBubyBkZXBlbmRlbmNpZXMKICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCBbdGFza10pOwogICAgICAgICAgICByZWFkeVRvQ2hlY2sucHVzaChrZXkpOwogICAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gdGFzay5zbGljZSgwLCB0YXNrLmxlbmd0aCAtIDEpOwogICAgICAgIHZhciByZW1haW5pbmdEZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMubGVuZ3RoOwogICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHsKICAgICAgICAgICAgZW5xdWV1ZVRhc2soa2V5LCB0YXNrKTsKICAgICAgICAgICAgcmVhZHlUb0NoZWNrLnB1c2goa2V5KTsKICAgICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICB1bmNoZWNrZWREZXBlbmRlbmNpZXNba2V5XSA9IHJlbWFpbmluZ0RlcGVuZGVuY2llczsKCiAgICAgICAgYXJyYXlFYWNoKGRlcGVuZGVuY2llcywgZnVuY3Rpb24gKGRlcGVuZGVuY3lOYW1lKSB7CiAgICAgICAgICAgIGlmICghdGFza3NbZGVwZW5kZW5jeU5hbWVdKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jLmF1dG8gdGFzayBgJyArIGtleSArCiAgICAgICAgICAgICAgICAgICAgJ2AgaGFzIGEgbm9uLWV4aXN0ZW50IGRlcGVuZGVuY3kgYCcgKwogICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3lOYW1lICsgJ2AgaW4gJyArCiAgICAgICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmpvaW4oJywgJykpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGFkZExpc3RlbmVyKGRlcGVuZGVuY3lOYW1lLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICByZW1haW5pbmdEZXBlbmRlbmNpZXMtLTsKICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdEZXBlbmRlbmNpZXMgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICBlbnF1ZXVlVGFzayhrZXksIHRhc2spOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICB9KTsKICAgIH0pOwoKICAgIGNoZWNrRm9yRGVhZGxvY2tzKCk7CiAgICBwcm9jZXNzUXVldWUoKTsKCiAgICBmdW5jdGlvbiBlbnF1ZXVlVGFzayhrZXksIHRhc2spIHsKICAgICAgICByZWFkeVRhc2tzLnB1c2goZnVuY3Rpb24gKCkgewogICAgICAgICAgICBydW5UYXNrKGtleSwgdGFzayk7CiAgICAgICAgfSk7CiAgICB9CgogICAgZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkgewogICAgICAgIGlmIChyZWFkeVRhc2tzLmxlbmd0aCA9PT0gMCAmJiBydW5uaW5nVGFza3MgPT09IDApIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpOwogICAgICAgIH0KICAgICAgICB3aGlsZShyZWFkeVRhc2tzLmxlbmd0aCAmJiBydW5uaW5nVGFza3MgPCBjb25jdXJyZW5jeSkgewogICAgICAgICAgICB2YXIgcnVuID0gcmVhZHlUYXNrcy5zaGlmdCgpOwogICAgICAgICAgICBydW4oKTsKICAgICAgICB9CgogICAgfQoKICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKHRhc2tOYW1lLCBmbikgewogICAgICAgIHZhciB0YXNrTGlzdGVuZXJzID0gbGlzdGVuZXJzW3Rhc2tOYW1lXTsKICAgICAgICBpZiAoIXRhc2tMaXN0ZW5lcnMpIHsKICAgICAgICAgICAgdGFza0xpc3RlbmVycyA9IGxpc3RlbmVyc1t0YXNrTmFtZV0gPSBbXTsKICAgICAgICB9CgogICAgICAgIHRhc2tMaXN0ZW5lcnMucHVzaChmbik7CiAgICB9CgogICAgZnVuY3Rpb24gdGFza0NvbXBsZXRlKHRhc2tOYW1lKSB7CiAgICAgICAgdmFyIHRhc2tMaXN0ZW5lcnMgPSBsaXN0ZW5lcnNbdGFza05hbWVdIHx8IFtdOwogICAgICAgIGFycmF5RWFjaCh0YXNrTGlzdGVuZXJzLCBmdW5jdGlvbiAoZm4pIHsKICAgICAgICAgICAgZm4oKTsKICAgICAgICB9KTsKICAgICAgICBwcm9jZXNzUXVldWUoKTsKICAgIH0KCgogICAgZnVuY3Rpb24gcnVuVGFzayhrZXksIHRhc2spIHsKICAgICAgICBpZiAoaGFzRXJyb3IpIHJldHVybjsKCiAgICAgICAgdmFyIHRhc2tDYWxsYmFjayA9IG9ubHlPbmNlKGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAgICAgICAgICAgIHJ1bm5pbmdUYXNrcy0tOwogICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgdmFyIHNhZmVSZXN1bHRzID0ge307CiAgICAgICAgICAgICAgICBiYXNlRm9yT3duKHJlc3VsdHMsIGZ1bmN0aW9uKHZhbCwgcmtleSkgewogICAgICAgICAgICAgICAgICAgIHNhZmVSZXN1bHRzW3JrZXldID0gdmFsOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBzYWZlUmVzdWx0c1trZXldID0gcmVzdWx0OwogICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlOwogICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKCiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIsIHNhZmVSZXN1bHRzKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHJlc3VsdDsKICAgICAgICAgICAgICAgIHRhc2tDb21wbGV0ZShrZXkpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CgogICAgICAgIHJ1bm5pbmdUYXNrcysrOwogICAgICAgIHZhciB0YXNrRm4gPSB3cmFwQXN5bmModGFza1t0YXNrLmxlbmd0aCAtIDFdKTsKICAgICAgICBpZiAodGFzay5sZW5ndGggPiAxKSB7CiAgICAgICAgICAgIHRhc2tGbihyZXN1bHRzLCB0YXNrQ2FsbGJhY2spOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRhc2tGbih0YXNrQ2FsbGJhY2spOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBjaGVja0ZvckRlYWRsb2NrcygpIHsKICAgICAgICAvLyBLYWhuJ3MgYWxnb3JpdGhtCiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9wb2xvZ2ljYWxfc29ydGluZyNLYWhuLjI3c19hbGdvcml0aG0KICAgICAgICAvLyBodHRwOi8vY29ubmFsbGUuYmxvZ3Nwb3QuY29tLzIwMTMvMTAvdG9wb2xvZ2ljYWwtc29ydGluZ2thaG4tYWxnb3JpdGhtLmh0bWwKICAgICAgICB2YXIgY3VycmVudFRhc2s7CiAgICAgICAgdmFyIGNvdW50ZXIgPSAwOwogICAgICAgIHdoaWxlIChyZWFkeVRvQ2hlY2subGVuZ3RoKSB7CiAgICAgICAgICAgIGN1cnJlbnRUYXNrID0gcmVhZHlUb0NoZWNrLnBvcCgpOwogICAgICAgICAgICBjb3VudGVyKys7CiAgICAgICAgICAgIGFycmF5RWFjaChnZXREZXBlbmRlbnRzKGN1cnJlbnRUYXNrKSwgZnVuY3Rpb24gKGRlcGVuZGVudCkgewogICAgICAgICAgICAgICAgaWYgKC0tdW5jaGVja2VkRGVwZW5kZW5jaWVzW2RlcGVuZGVudF0gPT09IDApIHsKICAgICAgICAgICAgICAgICAgICByZWFkeVRvQ2hlY2sucHVzaChkZXBlbmRlbnQpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICB9CgogICAgICAgIGlmIChjb3VudGVyICE9PSBudW1UYXNrcykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgICAgICAgICAnYXN5bmMuYXV0byBjYW5ub3QgZXhlY3V0ZSB0YXNrcyBkdWUgdG8gYSByZWN1cnNpdmUgZGVwZW5kZW5jeScKICAgICAgICAgICAgKTsKICAgICAgICB9CiAgICB9CgogICAgZnVuY3Rpb24gZ2V0RGVwZW5kZW50cyh0YXNrTmFtZSkgewogICAgICAgIHZhciByZXN1bHQgPSBbXTsKICAgICAgICBiYXNlRm9yT3duKHRhc2tzLCBmdW5jdGlvbiAodGFzaywga2V5KSB7CiAgICAgICAgICAgIGlmIChpc0FycmF5KHRhc2spICYmIGJhc2VJbmRleE9mKHRhc2ssIHRhc2tOYW1lLCAwKSA+PSAwKSB7CiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChrZXkpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0KfTsKCi8qKgogKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUKICogc2hvcnRoYW5kcy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuCiAqLwpmdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsCiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7CgogIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7CiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovCnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJzsKCi8qKgogKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuCiAqIEBleGFtcGxlCiAqCiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTsKICogLy8gPT4gdHJ1ZQogKgogKiBfLmlzU3ltYm9sKCdhYmMnKTsKICogLy8gPT4gZmFsc2UKICovCmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7CiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fAogICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTsKfQoKLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovCnZhciBJTkZJTklUWSA9IDEgLyAwOwoKLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovCnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCQxID8gU3ltYm9sJDEucHJvdG90eXBlIDogdW5kZWZpbmVkOwp2YXIgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkOwoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaAogKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLgogKi8KZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7CiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy4KICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7CiAgICByZXR1cm4gdmFsdWU7CiAgfQogIGlmIChpc0FycmF5KHZhbHVlKSkgewogICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS4KICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnOwogIH0KICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7CiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnOwogIH0KICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpOwogIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDsKfQoKLyoqCiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNsaWNlYCB3aXRob3V0IGFuIGl0ZXJhdGVlIGNhbGwgZ3VhcmQuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzbGljZS4KICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uCiAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLgogKi8KZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7CiAgdmFyIGluZGV4ID0gLTEsCiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsKCiAgaWYgKHN0YXJ0IDwgMCkgewogICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTsKICB9CiAgZW5kID0gZW5kID4gbGVuZ3RoID8gbGVuZ3RoIDogZW5kOwogIGlmIChlbmQgPCAwKSB7CiAgICBlbmQgKz0gbGVuZ3RoOwogIH0KICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7CiAgc3RhcnQgPj4+PSAwOwoKICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTsKICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkgewogICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKioKICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC4KICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBwb3NpdGlvbi4KICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuCiAqLwpmdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHsKICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOwogIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogZW5kOwogIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpOwp9CgovKioKICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBzdHJpbmcgc3ltYm9sCiAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC4KICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC4KICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuCiAqLwpmdW5jdGlvbiBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHsKICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDsKCiAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9CiAgcmV0dXJuIGluZGV4Owp9CgovKioKICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbVN0YXJ0YCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBzdHJpbmcgc3ltYm9sCiAqIHRoYXQgaXMgbm90IGZvdW5kIGluIHRoZSBjaGFyYWN0ZXIgc3ltYm9scy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtBcnJheX0gc3RyU3ltYm9scyBUaGUgc3RyaW5nIHN5bWJvbHMgdG8gaW5zcGVjdC4KICogQHBhcmFtIHtBcnJheX0gY2hyU3ltYm9scyBUaGUgY2hhcmFjdGVyIHN5bWJvbHMgdG8gZmluZC4KICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHVubWF0Y2hlZCBzdHJpbmcgc3ltYm9sLgogKi8KZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgbGVuZ3RoID0gc3RyU3ltYm9scy5sZW5ndGg7CgogIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fQogIHJldHVybiBpbmRleDsKfQoKLyoqCiAqIENvbnZlcnRzIGFuIEFTQ0lJIGBzdHJpbmdgIHRvIGFuIGFycmF5LgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuCiAqLwpmdW5jdGlvbiBhc2NpaVRvQXJyYXkoc3RyaW5nKSB7CiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7Cn0KCi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi8KdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFx1ZDgwMC1cXHVkZmZmJzsKdmFyIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcdTAzMDAtXFx1MDM2Zic7CnZhciByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFx1ZmUyMC1cXHVmZTJmJzsKdmFyIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFx1MjBkMC1cXHUyMGZmJzsKdmFyIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZTsKdmFyIHJzVmFyUmFuZ2UgPSAnXFx1ZmUwZVxcdWZlMGYnOwoKLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqLwp2YXIgcnNaV0ogPSAnXFx1MjAwZCc7CgovKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi8KdmFyIHJlSGFzVW5pY29kZSA9IFJlZ0V4cCgnWycgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgICsgcnNDb21ib1JhbmdlICsgcnNWYXJSYW5nZSArICddJyk7CgovKioKICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIFVuaWNvZGUgc3ltYm9scy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuCiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhIHN5bWJvbCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLgogKi8KZnVuY3Rpb24gaGFzVW5pY29kZShzdHJpbmcpIHsKICByZXR1cm4gcmVIYXNVbmljb2RlLnRlc3Qoc3RyaW5nKTsKfQoKLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqLwp2YXIgcnNBc3RyYWxSYW5nZSQxID0gJ1xcdWQ4MDAtXFx1ZGZmZic7CnZhciByc0NvbWJvTWFya3NSYW5nZSQxID0gJ1xcdTAzMDAtXFx1MDM2Zic7CnZhciByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSA9ICdcXHVmZTIwLVxcdWZlMmYnOwp2YXIgcnNDb21ib1N5bWJvbHNSYW5nZSQxID0gJ1xcdTIwZDAtXFx1MjBmZic7CnZhciByc0NvbWJvUmFuZ2UkMSA9IHJzQ29tYm9NYXJrc1JhbmdlJDEgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UkMSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UkMTsKdmFyIHJzVmFyUmFuZ2UkMSA9ICdcXHVmZTBlXFx1ZmUwZic7CgovKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovCnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UkMSArICddJzsKdmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UkMSArICddJzsKdmFyIHJzRml0eiA9ICdcXHVkODNjW1xcdWRmZmItXFx1ZGZmZl0nOwp2YXIgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJzsKdmFyIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UkMSArICddJzsKdmFyIHJzUmVnaW9uYWwgPSAnKD86XFx1ZDgzY1tcXHVkZGU2LVxcdWRkZmZdKXsyfSc7CnZhciByc1N1cnJQYWlyID0gJ1tcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0nOwp2YXIgcnNaV0okMSA9ICdcXHUyMDBkJzsKCi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqLwp2YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nOwp2YXIgcnNPcHRWYXIgPSAnWycgKyByc1ZhclJhbmdlJDEgKyAnXT8nOwp2YXIgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiQxICsgJyg/OicgKyBbcnNOb25Bc3RyYWwsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzT3B0VmFyICsgcmVPcHRNb2QgKyAnKSonOwp2YXIgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luOwp2YXIgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7CgovKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqLwp2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7CgovKioKICogQ29udmVydHMgYSBVbmljb2RlIGBzdHJpbmdgIHRvIGFuIGFycmF5LgogKgogKiBAcHJpdmF0ZQogKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC4KICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuCiAqLwpmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHsKICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZSkgfHwgW107Cn0KCi8qKgogKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LgogKi8KZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHsKICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpCiAgICA/IHVuaWNvZGVUb0FycmF5KHN0cmluZykKICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7Cn0KCi8qKgogKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYAogKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC4KICoKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgXwogKiBAc2luY2UgNC4wLjAKICogQGNhdGVnb3J5IExhbmcKICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy4KICogQGV4YW1wbGUKICoKICogXy50b1N0cmluZyhudWxsKTsKICogLy8gPT4gJycKICoKICogXy50b1N0cmluZygtMCk7CiAqIC8vID0+ICctMCcKICoKICogXy50b1N0cmluZyhbMSwgMiwgM10pOwogKiAvLyA9PiAnMSwyLDMnCiAqLwpmdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkgewogIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpOwp9CgovKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqLwp2YXIgcmVUcmltID0gL15ccyt8XHMrJC9nOwoKLyoqCiAqIFJlbW92ZXMgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLgogKgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBfCiAqIEBzaW5jZSAzLjAuMAogKiBAY2F0ZWdvcnkgU3RyaW5nCiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uCiAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS4KICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC4KICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuCiAqIEBleGFtcGxlCiAqCiAqIF8udHJpbSgnICBhYmMgICcpOwogKiAvLyA9PiAnYWJjJwogKgogKiBfLnRyaW0oJy1fLWFiYy1fLScsICdfLScpOwogKiAvLyA9PiAnYWJjJwogKgogKiBfLm1hcChbJyAgZm9vICAnLCAnICBiYXIgICddLCBfLnRyaW0pOwogKiAvLyA9PiBbJ2ZvbycsICdiYXInXQogKi8KZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkgewogIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7CiAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHsKICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW0sICcnKTsKICB9CiAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7CiAgICByZXR1cm4gc3RyaW5nOwogIH0KICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwKICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLAogICAgICBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSwKICAgICAgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7CgogIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgc3RhcnQsIGVuZCkuam9pbignJyk7Cn0KCnZhciBGTl9BUkdTID0gL14oPzphc3luY1xzKyk/KGZ1bmN0aW9uKT9ccypbXlwoXSpcKFxzKihbXlwpXSopXCkvbTsKdmFyIEZOX0FSR19TUExJVCA9IC8sLzsKdmFyIEZOX0FSRyA9IC8oPS4rKT8oXHMqKSQvOwp2YXIgU1RSSVBfQ09NTUVOVFMgPSAvKChcL1wvLiokKXwoXC9cKltcc1xTXSo/XCpcLykpL21nOwoKZnVuY3Rpb24gcGFyc2VQYXJhbXMoZnVuYykgewogICAgZnVuYyA9IGZ1bmMudG9TdHJpbmcoKS5yZXBsYWNlKFNUUklQX0NPTU1FTlRTLCAnJyk7CiAgICBmdW5jID0gZnVuYy5tYXRjaChGTl9BUkdTKVsyXS5yZXBsYWNlKCcgJywgJycpOwogICAgZnVuYyA9IGZ1bmMgPyBmdW5jLnNwbGl0KEZOX0FSR19TUExJVCkgOiBbXTsKICAgIGZ1bmMgPSBmdW5jLm1hcChmdW5jdGlvbiAoYXJnKXsKICAgICAgICByZXR1cm4gdHJpbShhcmcucmVwbGFjZShGTl9BUkcsICcnKSk7CiAgICB9KTsKICAgIHJldHVybiBmdW5jOwp9CgovKioKICogQSBkZXBlbmRlbmN5LWluamVjdGVkIHZlcnNpb24gb2YgdGhlIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30gZnVuY3Rpb24uIERlcGVuZGVudAogKiB0YXNrcyBhcmUgc3BlY2lmaWVkIGFzIHBhcmFtZXRlcnMgdG8gdGhlIGZ1bmN0aW9uLCBhZnRlciB0aGUgdXN1YWwgY2FsbGJhY2sKICogcGFyYW1ldGVyLCB3aXRoIHRoZSBwYXJhbWV0ZXIgbmFtZXMgbWF0Y2hpbmcgdGhlIG5hbWVzIG9mIHRoZSB0YXNrcyBpdAogKiBkZXBlbmRzIG9uLiBUaGlzIGNhbiBwcm92aWRlIGV2ZW4gbW9yZSByZWFkYWJsZSB0YXNrIGdyYXBocyB3aGljaCBjYW4gYmUKICogZWFzaWVyIHRvIG1haW50YWluLgogKgogKiBJZiBhIGZpbmFsIGNhbGxiYWNrIGlzIHNwZWNpZmllZCwgdGhlIHRhc2sgcmVzdWx0cyBhcmUgc2ltaWxhcmx5IGluamVjdGVkLAogKiBzcGVjaWZpZWQgYXMgbmFtZWQgcGFyYW1ldGVycyBhZnRlciB0aGUgaW5pdGlhbCBlcnJvciBwYXJhbWV0ZXIuCiAqCiAqIFRoZSBhdXRvSW5qZWN0IGZ1bmN0aW9uIGlzIHB1cmVseSBzeW50YWN0aWMgc3VnYXIgYW5kIGl0cyBzZW1hbnRpY3MgYXJlCiAqIG90aGVyd2lzZSBlcXVpdmFsZW50IHRvIFthc3luYy5hdXRvXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuYXV0b30uCiAqCiAqIEBuYW1lIGF1dG9JbmplY3QKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuYXV0b117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtPYmplY3R9IHRhc2tzIC0gQW4gb2JqZWN0LCBlYWNoIG9mIHdob3NlIHByb3BlcnRpZXMgaXMgYW4ge0BsaW5rIEFzeW5jRnVuY3Rpb259IG9mCiAqIHRoZSBmb3JtICdmdW5jKFtkZXBlbmRlbmNpZXMuLi5dLCBjYWxsYmFjaykuIFRoZSBvYmplY3QncyBrZXkgb2YgYSBwcm9wZXJ0eQogKiBzZXJ2ZXMgYXMgdGhlIG5hbWUgb2YgdGhlIHRhc2sgZGVmaW5lZCBieSB0aGF0IHByb3BlcnR5LCBpLmUuIGNhbiBiZSB1c2VkCiAqIHdoZW4gc3BlY2lmeWluZyByZXF1aXJlbWVudHMgZm9yIG90aGVyIHRhc2tzLgogKiAqIFRoZSBgY2FsbGJhY2tgIHBhcmFtZXRlciBpcyBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIHdoaWNoIG11c3QgYmUgY2FsbGVkCiAqICAgd2hlbiBmaW5pc2hlZCwgcGFzc2luZyBhbiBgZXJyb3JgICh3aGljaCBjYW4gYmUgYG51bGxgKSBhbmQgdGhlIHJlc3VsdCBvZgogKiAgIHRoZSBmdW5jdGlvbidzIGV4ZWN1dGlvbi4gVGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzIG5hbWUgb3RoZXIgdGFza3Mgb24KICogICB3aGljaCB0aGUgdGFzayBpcyBkZXBlbmRlbnQsIGFuZCB0aGUgcmVzdWx0cyBmcm9tIHRob3NlIHRhc2tzIGFyZSB0aGUKICogICBhcmd1bWVudHMgb2YgdGhvc2UgcGFyYW1ldGVycy4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiB0aGUgdGFza3MgaGF2ZSBiZWVuIGNvbXBsZXRlZC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgIGFyZ3VtZW50IGlmIGFueSBgdGFza3NgCiAqIHBhc3MgYW4gZXJyb3IgdG8gdGhlaXIgY2FsbGJhY2ssIGFuZCBhIGByZXN1bHRzYCBvYmplY3Qgd2l0aCBhbnkgY29tcGxldGVkCiAqIHRhc2sgcmVzdWx0cywgc2ltaWxhciB0byBgYXV0b2AuCiAqIEBleGFtcGxlCiAqCiAqIC8vICBUaGUgZXhhbXBsZSBmcm9tIGBhdXRvYCBjYW4gYmUgcmV3cml0dGVuIGFzIGZvbGxvd3M6CiAqIGFzeW5jLmF1dG9JbmplY3QoewogKiAgICAgZ2V0X2RhdGE6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBnZXQgc29tZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RhdGEnLCAnY29udmVydGVkIHRvIGFycmF5Jyk7CiAqICAgICB9LAogKiAgICAgbWFrZV9mb2xkZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gYXN5bmMgY29kZSB0byBjcmVhdGUgYSBkaXJlY3RvcnkgdG8gc3RvcmUgYSBmaWxlIGluCiAqICAgICAgICAgLy8gdGhpcyBpcyBydW4gYXQgdGhlIHNhbWUgdGltZSBhcyBnZXR0aW5nIHRoZSBkYXRhCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2ZvbGRlcicpOwogKiAgICAgfSwKICogICAgIHdyaXRlX2ZpbGU6IGZ1bmN0aW9uKGdldF9kYXRhLCBtYWtlX2ZvbGRlciwgY2FsbGJhY2spIHsKICogICAgICAgICAvLyBvbmNlIHRoZXJlIGlzIHNvbWUgZGF0YSBhbmQgdGhlIGRpcmVjdG9yeSBleGlzdHMsCiAqICAgICAgICAgLy8gd3JpdGUgdGhlIGRhdGEgdG8gYSBmaWxlIGluIHRoZSBkaXJlY3RvcnkKICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZmlsZW5hbWUnKTsKICogICAgIH0sCiAqICAgICBlbWFpbF9saW5rOiBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykgewogKiAgICAgICAgIC8vIG9uY2UgdGhlIGZpbGUgaXMgd3JpdHRlbiBsZXQncyBlbWFpbCBhIGxpbmsgdG8gaXQuLi4KICogICAgICAgICAvLyB3cml0ZV9maWxlIGNvbnRhaW5zIHRoZSBmaWxlbmFtZSByZXR1cm5lZCBieSB3cml0ZV9maWxlLgogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTsKICogICAgIH0KICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICBjb25zb2xlLmxvZygnZXJyID0gJywgZXJyKTsKICogICAgIGNvbnNvbGUubG9nKCdlbWFpbF9saW5rID0gJywgcmVzdWx0cy5lbWFpbF9saW5rKTsKICogfSk7CiAqCiAqIC8vIElmIHlvdSBhcmUgdXNpbmcgYSBKUyBtaW5pZmllciB0aGF0IG1hbmdsZXMgcGFyYW1ldGVyIG5hbWVzLCBgYXV0b0luamVjdGAKICogLy8gd2lsbCBub3Qgd29yayB3aXRoIHBsYWluIGZ1bmN0aW9ucywgc2luY2UgdGhlIHBhcmFtZXRlciBuYW1lcyB3aWxsIGJlCiAqIC8vIGNvbGxhcHNlZCB0byBhIHNpbmdsZSBsZXR0ZXIgaWRlbnRpZmllci4gIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHlvdSBjYW4KICogLy8gZXhwbGljaXRseSBzcGVjaWZ5IHRoZSBuYW1lcyBvZiB0aGUgcGFyYW1ldGVycyB5b3VyIHRhc2sgZnVuY3Rpb24gbmVlZHMKICogLy8gaW4gYW4gYXJyYXksIHNpbWlsYXIgdG8gQW5ndWxhci5qcyBkZXBlbmRlbmN5IGluamVjdGlvbi4KICoKICogLy8gVGhpcyBzdGlsbCBoYXMgYW4gYWR2YW50YWdlIG92ZXIgcGxhaW4gYGF1dG9gLCBzaW5jZSB0aGUgcmVzdWx0cyBhIHRhc2sKICogLy8gZGVwZW5kcyBvbiBhcmUgc3RpbGwgc3ByZWFkIGludG8gYXJndW1lbnRzLgogKiBhc3luYy5hdXRvSW5qZWN0KHsKICogICAgIC8vLi4uCiAqICAgICB3cml0ZV9maWxlOiBbJ2dldF9kYXRhJywgJ21ha2VfZm9sZGVyJywgZnVuY3Rpb24oZ2V0X2RhdGEsIG1ha2VfZm9sZGVyLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdmaWxlbmFtZScpOwogKiAgICAgfV0sCiAqICAgICBlbWFpbF9saW5rOiBbJ3dyaXRlX2ZpbGUnLCBmdW5jdGlvbih3cml0ZV9maWxlLCBjYWxsYmFjaykgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIHsnZmlsZSc6d3JpdGVfZmlsZSwgJ2VtYWlsJzondXNlckBleGFtcGxlLmNvbSd9KTsKICogICAgIH1dCiAqICAgICAvLy4uLgogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIGNvbnNvbGUubG9nKCdlcnIgPSAnLCBlcnIpOwogKiAgICAgY29uc29sZS5sb2coJ2VtYWlsX2xpbmsgPSAnLCByZXN1bHRzLmVtYWlsX2xpbmspOwogKiB9KTsKICovCmZ1bmN0aW9uIGF1dG9JbmplY3QodGFza3MsIGNhbGxiYWNrKSB7CiAgICB2YXIgbmV3VGFza3MgPSB7fTsKCiAgICBiYXNlRm9yT3duKHRhc2tzLCBmdW5jdGlvbiAodGFza0ZuLCBrZXkpIHsKICAgICAgICB2YXIgcGFyYW1zOwogICAgICAgIHZhciBmbklzQXN5bmMgPSBpc0FzeW5jKHRhc2tGbik7CiAgICAgICAgdmFyIGhhc05vRGVwcyA9CiAgICAgICAgICAgICghZm5Jc0FzeW5jICYmIHRhc2tGbi5sZW5ndGggPT09IDEpIHx8CiAgICAgICAgICAgIChmbklzQXN5bmMgJiYgdGFza0ZuLmxlbmd0aCA9PT0gMCk7CgogICAgICAgIGlmIChpc0FycmF5KHRhc2tGbikpIHsKICAgICAgICAgICAgcGFyYW1zID0gdGFza0ZuLnNsaWNlKDAsIC0xKTsKICAgICAgICAgICAgdGFza0ZuID0gdGFza0ZuW3Rhc2tGbi5sZW5ndGggLSAxXTsKCiAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSBwYXJhbXMuY29uY2F0KHBhcmFtcy5sZW5ndGggPiAwID8gbmV3VGFzayA6IHRhc2tGbik7CiAgICAgICAgfSBlbHNlIGlmIChoYXNOb0RlcHMpIHsKICAgICAgICAgICAgLy8gbm8gZGVwZW5kZW5jaWVzLCB1c2UgdGhlIGZ1bmN0aW9uIGFzLWlzCiAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSB0YXNrRm47CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcGFyYW1zID0gcGFyc2VQYXJhbXModGFza0ZuKTsKICAgICAgICAgICAgaWYgKHRhc2tGbi5sZW5ndGggPT09IDAgJiYgIWZuSXNBc3luYyAmJiBwYXJhbXMubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImF1dG9JbmplY3QgdGFzayBmdW5jdGlvbnMgcmVxdWlyZSBleHBsaWNpdCBwYXJhbWV0ZXJzLiIpOwogICAgICAgICAgICB9CgogICAgICAgICAgICAvLyByZW1vdmUgY2FsbGJhY2sgcGFyYW0KICAgICAgICAgICAgaWYgKCFmbklzQXN5bmMpIHBhcmFtcy5wb3AoKTsKCiAgICAgICAgICAgIG5ld1Rhc2tzW2tleV0gPSBwYXJhbXMuY29uY2F0KG5ld1Rhc2spOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gbmV3VGFzayhyZXN1bHRzLCB0YXNrQ2IpIHsKICAgICAgICAgICAgdmFyIG5ld0FyZ3MgPSBhcnJheU1hcChwYXJhbXMsIGZ1bmN0aW9uIChuYW1lKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1tuYW1lXTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIG5ld0FyZ3MucHVzaCh0YXNrQ2IpOwogICAgICAgICAgICB3cmFwQXN5bmModGFza0ZuKS5hcHBseShudWxsLCBuZXdBcmdzKTsKICAgICAgICB9CiAgICB9KTsKCiAgICBhdXRvKG5ld1Rhc2tzLCBjYWxsYmFjayk7Cn0KCi8vIFNpbXBsZSBkb3VibHkgbGlua2VkIGxpc3QgKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RvdWJseV9saW5rZWRfbGlzdCkgaW1wbGVtZW50YXRpb24KLy8gdXNlZCBmb3IgcXVldWVzLiBUaGlzIGltcGxlbWVudGF0aW9uIGFzc3VtZXMgdGhhdCB0aGUgbm9kZSBwcm92aWRlZCBieSB0aGUgdXNlciBjYW4gYmUgbW9kaWZpZWQKLy8gdG8gYWRqdXN0IHRoZSBuZXh0IGFuZCBsYXN0IHByb3BlcnRpZXMuIFdlIGltcGxlbWVudCBvbmx5IHRoZSBtaW5pbWFsIGZ1bmN0aW9uYWxpdHkKLy8gZm9yIHF1ZXVlIHN1cHBvcnQuCmZ1bmN0aW9uIERMTCgpIHsKICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7CiAgICB0aGlzLmxlbmd0aCA9IDA7Cn0KCmZ1bmN0aW9uIHNldEluaXRpYWwoZGxsLCBub2RlKSB7CiAgICBkbGwubGVuZ3RoID0gMTsKICAgIGRsbC5oZWFkID0gZGxsLnRhaWwgPSBub2RlOwp9CgpETEwucHJvdG90eXBlLnJlbW92ZUxpbmsgPSBmdW5jdGlvbihub2RlKSB7CiAgICBpZiAobm9kZS5wcmV2KSBub2RlLnByZXYubmV4dCA9IG5vZGUubmV4dDsKICAgIGVsc2UgdGhpcy5oZWFkID0gbm9kZS5uZXh0OwogICAgaWYgKG5vZGUubmV4dCkgbm9kZS5uZXh0LnByZXYgPSBub2RlLnByZXY7CiAgICBlbHNlIHRoaXMudGFpbCA9IG5vZGUucHJldjsKCiAgICBub2RlLnByZXYgPSBub2RlLm5leHQgPSBudWxsOwogICAgdGhpcy5sZW5ndGggLT0gMTsKICAgIHJldHVybiBub2RlOwp9OwoKRExMLnByb3RvdHlwZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHsKICAgIHdoaWxlKHRoaXMuaGVhZCkgdGhpcy5zaGlmdCgpOwogICAgcmV0dXJuIHRoaXM7Cn07CgpETEwucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24obm9kZSwgbmV3Tm9kZSkgewogICAgbmV3Tm9kZS5wcmV2ID0gbm9kZTsKICAgIG5ld05vZGUubmV4dCA9IG5vZGUubmV4dDsKICAgIGlmIChub2RlLm5leHQpIG5vZGUubmV4dC5wcmV2ID0gbmV3Tm9kZTsKICAgIGVsc2UgdGhpcy50YWlsID0gbmV3Tm9kZTsKICAgIG5vZGUubmV4dCA9IG5ld05vZGU7CiAgICB0aGlzLmxlbmd0aCArPSAxOwp9OwoKRExMLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbihub2RlLCBuZXdOb2RlKSB7CiAgICBuZXdOb2RlLnByZXYgPSBub2RlLnByZXY7CiAgICBuZXdOb2RlLm5leHQgPSBub2RlOwogICAgaWYgKG5vZGUucHJldikgbm9kZS5wcmV2Lm5leHQgPSBuZXdOb2RlOwogICAgZWxzZSB0aGlzLmhlYWQgPSBuZXdOb2RlOwogICAgbm9kZS5wcmV2ID0gbmV3Tm9kZTsKICAgIHRoaXMubGVuZ3RoICs9IDE7Cn07CgpETEwucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbihub2RlKSB7CiAgICBpZiAodGhpcy5oZWFkKSB0aGlzLmluc2VydEJlZm9yZSh0aGlzLmhlYWQsIG5vZGUpOwogICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpOwp9OwoKRExMLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obm9kZSkgewogICAgaWYgKHRoaXMudGFpbCkgdGhpcy5pbnNlcnRBZnRlcih0aGlzLnRhaWwsIG5vZGUpOwogICAgZWxzZSBzZXRJbml0aWFsKHRoaXMsIG5vZGUpOwp9OwoKRExMLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkgewogICAgcmV0dXJuIHRoaXMuaGVhZCAmJiB0aGlzLnJlbW92ZUxpbmsodGhpcy5oZWFkKTsKfTsKCkRMTC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdGhpcy50YWlsICYmIHRoaXMucmVtb3ZlTGluayh0aGlzLnRhaWwpOwp9OwoKRExMLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkgewogICAgdmFyIGFyciA9IEFycmF5KHRoaXMubGVuZ3RoKTsKICAgIHZhciBjdXJyID0gdGhpcy5oZWFkOwogICAgZm9yKHZhciBpZHggPSAwOyBpZHggPCB0aGlzLmxlbmd0aDsgaWR4KyspIHsKICAgICAgICBhcnJbaWR4XSA9IGN1cnIuZGF0YTsKICAgICAgICBjdXJyID0gY3Vyci5uZXh0OwogICAgfQogICAgcmV0dXJuIGFycjsKfTsKCkRMTC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRlc3RGbikgewogICAgdmFyIGN1cnIgPSB0aGlzLmhlYWQ7CiAgICB3aGlsZSghIWN1cnIpIHsKICAgICAgICB2YXIgbmV4dCA9IGN1cnIubmV4dDsKICAgICAgICBpZiAodGVzdEZuKGN1cnIpKSB7CiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGluayhjdXJyKTsKICAgICAgICB9CiAgICAgICAgY3VyciA9IG5leHQ7CiAgICB9CiAgICByZXR1cm4gdGhpczsKfTsKCmZ1bmN0aW9uIHF1ZXVlKHdvcmtlciwgY29uY3VycmVuY3ksIHBheWxvYWQpIHsKICAgIGlmIChjb25jdXJyZW5jeSA9PSBudWxsKSB7CiAgICAgICAgY29uY3VycmVuY3kgPSAxOwogICAgfQogICAgZWxzZSBpZihjb25jdXJyZW5jeSA9PT0gMCkgewogICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uY3VycmVuY3kgbXVzdCBub3QgYmUgemVybycpOwogICAgfQoKICAgIHZhciBfd29ya2VyID0gd3JhcEFzeW5jKHdvcmtlcik7CiAgICB2YXIgbnVtUnVubmluZyA9IDA7CiAgICB2YXIgd29ya2Vyc0xpc3QgPSBbXTsKCiAgICB2YXIgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IGZhbHNlOwogICAgZnVuY3Rpb24gX2luc2VydChkYXRhLCBpbnNlcnRBdEZyb250LCBjYWxsYmFjaykgewogICAgICAgIGlmIChjYWxsYmFjayAhPSBudWxsICYmIHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rhc2sgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CiAgICAgICAgfQogICAgICAgIHEuc3RhcnRlZCA9IHRydWU7CiAgICAgICAgaWYgKCFpc0FycmF5KGRhdGEpKSB7CiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07CiAgICAgICAgfQogICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCAmJiBxLmlkbGUoKSkgewogICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrcwogICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlJDEoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBxLmRyYWluKCk7CiAgICAgICAgICAgIH0pOwogICAgICAgIH0KCiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICB2YXIgaXRlbSA9IHsKICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFbaV0sCiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2sgfHwgbm9vcAogICAgICAgICAgICB9OwoKICAgICAgICAgICAgaWYgKGluc2VydEF0RnJvbnQpIHsKICAgICAgICAgICAgICAgIHEuX3Rhc2tzLnVuc2hpZnQoaXRlbSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBxLl90YXNrcy5wdXNoKGl0ZW0pOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICBpZiAoIXByb2Nlc3NpbmdTY2hlZHVsZWQpIHsKICAgICAgICAgICAgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IHRydWU7CiAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uKCkgewogICAgICAgICAgICAgICAgcHJvY2Vzc2luZ1NjaGVkdWxlZCA9IGZhbHNlOwogICAgICAgICAgICAgICAgcS5wcm9jZXNzKCk7CiAgICAgICAgICAgIH0pOwogICAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBfbmV4dCh0YXNrcykgewogICAgICAgIHJldHVybiBmdW5jdGlvbihlcnIpewogICAgICAgICAgICBudW1SdW5uaW5nIC09IDE7CgogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRhc2tzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc1tpXTsKCiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlSW5kZXhPZih3b3JrZXJzTGlzdCwgdGFzaywgMCk7CiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHsKICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zaGlmdCgpOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA+IDApIHsKICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5zcGxpY2UoaW5kZXgsIDEpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIHRhc2suY2FsbGJhY2suYXBwbHkodGFzaywgYXJndW1lbnRzKTsKCiAgICAgICAgICAgICAgICBpZiAoZXJyICE9IG51bGwpIHsKICAgICAgICAgICAgICAgICAgICBxLmVycm9yKGVyciwgdGFzay5kYXRhKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgaWYgKG51bVJ1bm5pbmcgPD0gKHEuY29uY3VycmVuY3kgLSBxLmJ1ZmZlcikgKSB7CiAgICAgICAgICAgICAgICBxLnVuc2F0dXJhdGVkKCk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChxLmlkbGUoKSkgewogICAgICAgICAgICAgICAgcS5kcmFpbigpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHEucHJvY2VzcygpOwogICAgICAgIH07CiAgICB9CgogICAgdmFyIGlzUHJvY2Vzc2luZyA9IGZhbHNlOwogICAgdmFyIHEgPSB7CiAgICAgICAgX3Rhc2tzOiBuZXcgRExMKCksCiAgICAgICAgY29uY3VycmVuY3k6IGNvbmN1cnJlbmN5LAogICAgICAgIHBheWxvYWQ6IHBheWxvYWQsCiAgICAgICAgc2F0dXJhdGVkOiBub29wLAogICAgICAgIHVuc2F0dXJhdGVkOm5vb3AsCiAgICAgICAgYnVmZmVyOiBjb25jdXJyZW5jeSAvIDQsCiAgICAgICAgZW1wdHk6IG5vb3AsCiAgICAgICAgZHJhaW46IG5vb3AsCiAgICAgICAgZXJyb3I6IG5vb3AsCiAgICAgICAgc3RhcnRlZDogZmFsc2UsCiAgICAgICAgcGF1c2VkOiBmYWxzZSwKICAgICAgICBwdXNoOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHsKICAgICAgICAgICAgX2luc2VydChkYXRhLCBmYWxzZSwgY2FsbGJhY2spOwogICAgICAgIH0sCiAgICAgICAga2lsbDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICBxLmRyYWluID0gbm9vcDsKICAgICAgICAgICAgcS5fdGFza3MuZW1wdHkoKTsKICAgICAgICB9LAogICAgICAgIHVuc2hpZnQ6IGZ1bmN0aW9uIChkYXRhLCBjYWxsYmFjaykgewogICAgICAgICAgICBfaW5zZXJ0KGRhdGEsIHRydWUsIGNhbGxiYWNrKTsKICAgICAgICB9LAogICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKHRlc3RGbikgewogICAgICAgICAgICBxLl90YXNrcy5yZW1vdmUodGVzdEZuKTsKICAgICAgICB9LAogICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgLy8gQXZvaWQgdHJ5aW5nIHRvIHN0YXJ0IHRvbyBtYW55IHByb2Nlc3Npbmcgb3BlcmF0aW9ucy4gVGhpcyBjYW4gb2NjdXIKICAgICAgICAgICAgLy8gd2hlbiBjYWxsYmFja3MgcmVzb2x2ZSBzeW5jaHJvbm91c2x5ICgjMTI2NykuCiAgICAgICAgICAgIGlmIChpc1Byb2Nlc3NpbmcpIHsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICBpc1Byb2Nlc3NpbmcgPSB0cnVlOwogICAgICAgICAgICB3aGlsZSghcS5wYXVzZWQgJiYgbnVtUnVubmluZyA8IHEuY29uY3VycmVuY3kgJiYgcS5fdGFza3MubGVuZ3RoKXsKICAgICAgICAgICAgICAgIHZhciB0YXNrcyA9IFtdLCBkYXRhID0gW107CiAgICAgICAgICAgICAgICB2YXIgbCA9IHEuX3Rhc2tzLmxlbmd0aDsKICAgICAgICAgICAgICAgIGlmIChxLnBheWxvYWQpIGwgPSBNYXRoLm1pbihsLCBxLnBheWxvYWQpOwogICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHEuX3Rhc2tzLnNoaWZ0KCk7CiAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaChub2RlKTsKICAgICAgICAgICAgICAgICAgICB3b3JrZXJzTGlzdC5wdXNoKG5vZGUpOwogICAgICAgICAgICAgICAgICAgIGRhdGEucHVzaChub2RlLmRhdGEpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIG51bVJ1bm5pbmcgKz0gMTsKCiAgICAgICAgICAgICAgICBpZiAocS5fdGFza3MubGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgcS5lbXB0eSgpOwogICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgIGlmIChudW1SdW5uaW5nID09PSBxLmNvbmN1cnJlbmN5KSB7CiAgICAgICAgICAgICAgICAgICAgcS5zYXR1cmF0ZWQoKTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB2YXIgY2IgPSBvbmx5T25jZShfbmV4dCh0YXNrcykpOwogICAgICAgICAgICAgICAgX3dvcmtlcihkYXRhLCBjYik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gZmFsc2U7CiAgICAgICAgfSwKICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aDsKICAgICAgICB9LAogICAgICAgIHJ1bm5pbmc6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcmV0dXJuIG51bVJ1bm5pbmc7CiAgICAgICAgfSwKICAgICAgICB3b3JrZXJzTGlzdDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICByZXR1cm4gd29ya2Vyc0xpc3Q7CiAgICAgICAgfSwKICAgICAgICBpZGxlOiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIHEuX3Rhc2tzLmxlbmd0aCArIG51bVJ1bm5pbmcgPT09IDA7CiAgICAgICAgfSwKICAgICAgICBwYXVzZTogZnVuY3Rpb24gKCkgewogICAgICAgICAgICBxLnBhdXNlZCA9IHRydWU7CiAgICAgICAgfSwKICAgICAgICByZXN1bWU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgaWYgKHEucGF1c2VkID09PSBmYWxzZSkgeyByZXR1cm47IH0KICAgICAgICAgICAgcS5wYXVzZWQgPSBmYWxzZTsKICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEocS5wcm9jZXNzKTsKICAgICAgICB9CiAgICB9OwogICAgcmV0dXJuIHE7Cn0KCi8qKgogKiBBIGNhcmdvIG9mIHRhc2tzIGZvciB0aGUgd29ya2VyIGZ1bmN0aW9uIHRvIGNvbXBsZXRlLiBDYXJnbyBpbmhlcml0cyBhbGwgb2YKICogdGhlIHNhbWUgbWV0aG9kcyBhbmQgZXZlbnQgY2FsbGJhY2tzIGFzIFtgcXVldWVgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9LgogKiBAdHlwZWRlZiB7T2JqZWN0fSBDYXJnb09iamVjdAogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGxlbmd0aCAtIEEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBudW1iZXIgb2YgaXRlbXMKICogd2FpdGluZyB0byBiZSBwcm9jZXNzZWQuIEludm9rZSBsaWtlIGBjYXJnby5sZW5ndGgoKWAuCiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwYXlsb2FkIC0gQW4gYGludGVnZXJgIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSB0YXNrcwogKiBzaG91bGQgYmUgcHJvY2VzcyBwZXIgcm91bmQuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGNoYW5nZWQgYWZ0ZXIgYSBgY2FyZ29gIGlzCiAqIGNyZWF0ZWQgdG8gYWx0ZXIgdGhlIHBheWxvYWQgb24tdGhlLWZseS4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcHVzaCAtIEFkZHMgYHRhc2tgIHRvIHRoZSBgcXVldWVgLiBUaGUgY2FsbGJhY2sgaXMKICogY2FsbGVkIG9uY2UgdGhlIGB3b3JrZXJgIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZSB0YXNrLiBJbnN0ZWFkIG9mIGEKICogc2luZ2xlIHRhc2ssIGFuIGFycmF5IG9mIGB0YXNrc2AgY2FuIGJlIHN1Ym1pdHRlZC4gVGhlIHJlc3BlY3RpdmUgY2FsbGJhY2sgaXMKICogdXNlZCBmb3IgZXZlcnkgdGFzayBpbiB0aGUgbGlzdC4gSW52b2tlIGxpa2UgYGNhcmdvLnB1c2godGFzaywgW2NhbGxiYWNrXSlgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBzYXR1cmF0ZWQgLSBBIGNhbGxiYWNrIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlCiAqIGBxdWV1ZS5sZW5ndGgoKWAgaGl0cyB0aGUgY29uY3VycmVuY3kgYW5kIGZ1cnRoZXIgdGFza3Mgd2lsbCBiZSBxdWV1ZWQuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVtcHR5IC0gQSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW0KICogZnJvbSB0aGUgYHF1ZXVlYCBpcyBnaXZlbiB0byBhIGB3b3JrZXJgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkcmFpbiAtIEEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtCiAqIGZyb20gdGhlIGBxdWV1ZWAgaGFzIHJldHVybmVkIGZyb20gdGhlIGB3b3JrZXJgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpZGxlIC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgZmFsc2UgaWYgdGhlcmUgYXJlIGl0ZW1zCiAqIHdhaXRpbmcgb3IgYmVpbmcgcHJvY2Vzc2VkLCBvciB0cnVlIGlmIG5vdC4gSW52b2tlIGxpa2UgYGNhcmdvLmlkbGUoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHBhdXNlIC0gYSBmdW5jdGlvbiB0aGF0IHBhdXNlcyB0aGUgcHJvY2Vzc2luZyBvZiB0YXNrcwogKiB1bnRpbCBgcmVzdW1lKClgIGlzIGNhbGxlZC4gSW52b2tlIGxpa2UgYGNhcmdvLnBhdXNlKClgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSByZXN1bWUgLSBhIGZ1bmN0aW9uIHRoYXQgcmVzdW1lcyB0aGUgcHJvY2Vzc2luZyBvZgogKiBxdWV1ZWQgdGFza3Mgd2hlbiB0aGUgcXVldWUgaXMgcGF1c2VkLiBJbnZva2UgbGlrZSBgY2FyZ28ucmVzdW1lKClgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBraWxsIC0gYSBmdW5jdGlvbiB0aGF0IHJlbW92ZXMgdGhlIGBkcmFpbmAgY2FsbGJhY2sgYW5kCiAqIGVtcHRpZXMgcmVtYWluaW5nIHRhc2tzIGZyb20gdGhlIHF1ZXVlIGZvcmNpbmcgaXQgdG8gZ28gaWRsZS4gSW52b2tlIGxpa2UgYGNhcmdvLmtpbGwoKWAuCiAqLwoKLyoqCiAqIENyZWF0ZXMgYSBgY2FyZ29gIG9iamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZC4gVGFza3MgYWRkZWQgdG8gdGhlCiAqIGNhcmdvIHdpbGwgYmUgcHJvY2Vzc2VkIGFsdG9nZXRoZXIgKHVwIHRvIHRoZSBgcGF5bG9hZGAgbGltaXQpLiBJZiB0aGUKICogYHdvcmtlcmAgaXMgaW4gcHJvZ3Jlc3MsIHRoZSB0YXNrIGlzIHF1ZXVlZCB1bnRpbCBpdCBiZWNvbWVzIGF2YWlsYWJsZS4gT25jZQogKiB0aGUgYHdvcmtlcmAgaGFzIGNvbXBsZXRlZCBzb21lIHRhc2tzLCBlYWNoIGNhbGxiYWNrIG9mIHRob3NlIHRhc2tzIGlzCiAqIGNhbGxlZC4gQ2hlY2sgb3V0IFt0aGVzZV0oaHR0cHM6Ly9jYW1vLmdpdGh1YnVzZXJjb250ZW50LmNvbS82YmJkMzZmNGNmNWIzNWEwZjExYTk2ZGNkMmU5NzcxMWZmYzJmYjM3LzY4NzQ3NDcwNzMzYTJmMmY2NjJlNjM2YzZmNzU2NDJlNjc2OTc0Njg3NTYyMmU2MzZmNmQyZjYxNzM3MzY1NzQ3MzJmMzEzNjM3MzYzODM3MzEyZjM2MzgzMTMwMzgyZjYyNjI2MzMwNjM2NjYyMzAyZDM1NjYzMjM5MmQzMTMxNjUzMjJkMzkzNzM0NjYyZDMzMzMzOTM3NjMzNjM0NjQ2MzM4MzUzODJlNjc2OTY2KSBbYW5pbWF0aW9uc10oaHR0cHM6Ly9jYW1vLmdpdGh1YnVzZXJjb250ZW50LmNvbS9mNDgxMGUwMGUxYzVmNWY4YWRkYmUzZTlmNDkwNjRmZDVkMTAyNjk5LzY4NzQ3NDcwNzMzYTJmMmY2NjJlNjM2YzZmNzU2NDJlNjc2OTc0Njg3NTYyMmU2MzZmNmQyZjYxNzM3MzY1NzQ3MzJmMzEzNjM3MzYzODM3MzEyZjM2MzgzMTMwMzEyZjM4MzQ2MzM5MzIzMDM2MzYyZDM1NjYzMjM5MmQzMTMxNjUzMjJkMzgzMTM0NjYyZDM5NjQzMzY0MzAzMjM0MzEzMzYyNjY2NDJlNjc2OTY2KQogKiBmb3IgaG93IGBjYXJnb2AgYW5kIGBxdWV1ZWAgd29yay4KICoKICogV2hpbGUgW2BxdWV1ZWBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX0gcGFzc2VzIG9ubHkgb25lIHRhc2sgdG8gb25lIG9mIGEgZ3JvdXAgb2Ygd29ya2VycwogKiBhdCBhIHRpbWUsIGNhcmdvIHBhc3NlcyBhbiBhcnJheSBvZiB0YXNrcyB0byBhIHNpbmdsZSB3b3JrZXIsIHJlcGVhdGluZwogKiB3aGVuIHRoZSB3b3JrZXIgaXMgZmluaXNoZWQuCiAqCiAqIEBuYW1lIGNhcmdvCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnF1ZXVlXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucXVldWV9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB3b3JrZXIgLSBBbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYW4gYXJyYXkKICogb2YgcXVldWVkIHRhc2tzLiBJbnZva2VkIHdpdGggYCh0YXNrcywgY2FsbGJhY2spYC4KICogQHBhcmFtIHtudW1iZXJ9IFtwYXlsb2FkPUluZmluaXR5XSAtIEFuIG9wdGlvbmFsIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmcKICogaG93IG1hbnkgdGFza3Mgc2hvdWxkIGJlIHByb2Nlc3NlZCBwZXIgcm91bmQ7IGlmIG9taXR0ZWQsIHRoZSBkZWZhdWx0IGlzCiAqIHVubGltaXRlZC4KICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5DYXJnb09iamVjdH0gQSBjYXJnbyBvYmplY3QgdG8gbWFuYWdlIHRoZSB0YXNrcy4gQ2FsbGJhY2tzIGNhbgogKiBhdHRhY2hlZCBhcyBjZXJ0YWluIHByb3BlcnRpZXMgdG8gbGlzdGVuIGZvciBzcGVjaWZpYyBldmVudHMgZHVyaW5nIHRoZQogKiBsaWZlY3ljbGUgb2YgdGhlIGNhcmdvIGFuZCBpbm5lciBxdWV1ZS4KICogQGV4YW1wbGUKICoKICogLy8gY3JlYXRlIGEgY2FyZ28gb2JqZWN0IHdpdGggcGF5bG9hZCAyCiAqIHZhciBjYXJnbyA9IGFzeW5jLmNhcmdvKGZ1bmN0aW9uKHRhc2tzLCBjYWxsYmFjaykgewogKiAgICAgZm9yICh2YXIgaT0wOyBpPHRhc2tzLmxlbmd0aDsgaSsrKSB7CiAqICAgICAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrc1tpXS5uYW1lKTsKICogICAgIH0KICogICAgIGNhbGxiYWNrKCk7CiAqIH0sIDIpOwogKgogKiAvLyBhZGQgc29tZSBpdGVtcwogKiBjYXJnby5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikgewogKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgZm9vJyk7CiAqIH0pOwogKiBjYXJnby5wdXNoKHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uKGVycikgewogKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmFyJyk7CiAqIH0pOwogKiBjYXJnby5wdXNoKHtuYW1lOiAnYmF6J30sIGZ1bmN0aW9uKGVycikgewogKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmF6Jyk7CiAqIH0pOwogKi8KZnVuY3Rpb24gY2FyZ28od29ya2VyLCBwYXlsb2FkKSB7CiAgICByZXR1cm4gcXVldWUod29ya2VyLCAxLCBwYXlsb2FkKTsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZWFjaE9mYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBlYWNoT2ZTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZWFjaE9mXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfQogKiBAYWxpYXMgZm9yRWFjaE9mU2VyaWVzCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS4KICovCnZhciBlYWNoT2ZTZXJpZXMgPSBkb0xpbWl0KGVhY2hPZkxpbWl0LCAxKTsKCi8qKgogKiBSZWR1Y2VzIGBjb2xsYCBpbnRvIGEgc2luZ2xlIHZhbHVlIHVzaW5nIGFuIGFzeW5jIGBpdGVyYXRlZWAgdG8gcmV0dXJuIGVhY2gKICogc3VjY2Vzc2l2ZSBzdGVwLiBgbWVtb2AgaXMgdGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi4gVGhpcyBmdW5jdGlvbgogKiBvbmx5IG9wZXJhdGVzIGluIHNlcmllcy4KICoKICogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGl0IG1heSBtYWtlIHNlbnNlIHRvIHNwbGl0IGEgY2FsbCB0byB0aGlzIGZ1bmN0aW9uCiAqIGludG8gYSBwYXJhbGxlbCBtYXAsIGFuZCB0aGVuIHVzZSB0aGUgbm9ybWFsIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBvbiB0aGUKICogcmVzdWx0cy4gVGhpcyBmdW5jdGlvbiBpcyBmb3Igc2l0dWF0aW9ucyB3aGVyZSBlYWNoIHN0ZXAgaW4gdGhlIHJlZHVjdGlvbgogKiBuZWVkcyB0byBiZSBhc3luYzsgaWYgeW91IGNhbiBnZXQgdGhlIGRhdGEgYmVmb3JlIHJlZHVjaW5nIGl0LCB0aGVuIGl0J3MKICogcHJvYmFibHkgYSBnb29kIGlkZWEgdG8gZG8gc28uCiAqCiAqIEBuYW1lIHJlZHVjZQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAYWxpYXMgaW5qZWN0CiAqIEBhbGlhcyBmb2xkbAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7Kn0gbWVtbyAtIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSByZWR1Y3Rpb24uCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIGFwcGxpZWQgdG8gZWFjaCBpdGVtIGluIHRoZQogKiBhcnJheSB0byBwcm9kdWNlIHRoZSBuZXh0IHN0ZXAgaW4gdGhlIHJlZHVjdGlvbi4KICogVGhlIGBpdGVyYXRlZWAgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIG5leHQgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi4KICogSWYgdGhlIGl0ZXJhdGVlIGNvbXBsZXRlIHdpdGggYW4gZXJyb3IsIHRoZSByZWR1Y3Rpb24gaXMgc3RvcHBlZCBhbmQgdGhlCiAqIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgZXJyb3IuCiAqIEludm9rZWQgd2l0aCAobWVtbywgaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHJlZHVjZWQgdmFsdWUuIEludm9rZWQgd2l0aAogKiAoZXJyLCByZXN1bHQpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5yZWR1Y2UoWzEsMiwzXSwgMCwgZnVuY3Rpb24obWVtbywgaXRlbSwgY2FsbGJhY2spIHsKICogICAgIC8vIHBvaW50bGVzcyBhc3luYzoKICogICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWVtbyArIGl0ZW0pCiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBpcyBub3cgZXF1YWwgdG8gdGhlIGxhc3QgdmFsdWUgb2YgbWVtbywgd2hpY2ggaXMgNgogKiB9KTsKICovCmZ1bmN0aW9uIHJlZHVjZShjb2xsLCBtZW1vLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwogICAgZWFjaE9mU2VyaWVzKGNvbGwsIGZ1bmN0aW9uKHgsIGksIGNhbGxiYWNrKSB7CiAgICAgICAgX2l0ZXJhdGVlKG1lbW8sIHgsIGZ1bmN0aW9uKGVyciwgdikgewogICAgICAgICAgICBtZW1vID0gdjsKICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uKGVycikgewogICAgICAgIGNhbGxiYWNrKGVyciwgbWVtbyk7CiAgICB9KTsKfQoKLyoqCiAqIFZlcnNpb24gb2YgdGhlIGNvbXBvc2UgZnVuY3Rpb24gdGhhdCBpcyBtb3JlIG5hdHVyYWwgdG8gcmVhZC4gRWFjaCBmdW5jdGlvbgogKiBjb25zdW1lcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cyBmdW5jdGlvbi4gSXQgaXMgdGhlIGVxdWl2YWxlbnQgb2YKICogW2NvbXBvc2Vde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5jb21wb3NlfSB3aXRoIHRoZSBhcmd1bWVudHMgcmV2ZXJzZWQuCiAqCiAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLgogKgogKiBAbmFtZSBzZXEKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuY29tcG9zZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmNvbXBvc2V9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHsuLi5Bc3luY0Z1bmN0aW9ufSBmdW5jdGlvbnMgLSB0aGUgYXN5bmNocm9ub3VzIGZ1bmN0aW9ucyB0byBjb21wb3NlCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBmdW5jdGlvbiB0aGF0IGNvbXBvc2VzIHRoZSBgZnVuY3Rpb25zYCBpbiBvcmRlcgogKiBAZXhhbXBsZQogKgogKiAvLyBSZXF1aXJlcyBsb2Rhc2ggKG9yIHVuZGVyc2NvcmUpLCBleHByZXNzMyBhbmQgZHJlc2VuZGUncyBvcm0yLgogKiAvLyBQYXJ0IG9mIGFuIGFwcCwgdGhhdCBmZXRjaGVzIGNhdHMgb2YgdGhlIGxvZ2dlZCB1c2VyLgogKiAvLyBUaGlzIGV4YW1wbGUgdXNlcyBgc2VxYCBmdW5jdGlvbiB0byBhdm9pZCBvdmVybmVzdGluZyBhbmQgZXJyb3IKICogLy8gaGFuZGxpbmcgY2x1dHRlci4KICogYXBwLmdldCgnL2NhdHMnLCBmdW5jdGlvbihyZXF1ZXN0LCByZXNwb25zZSkgewogKiAgICAgdmFyIFVzZXIgPSByZXF1ZXN0Lm1vZGVscy5Vc2VyOwogKiAgICAgYXN5bmMuc2VxKAogKiAgICAgICAgIF8uYmluZChVc2VyLmdldCwgVXNlciksICAvLyAnVXNlci5nZXQnIGhhcyBzaWduYXR1cmUgKGlkLCBjYWxsYmFjayhlcnIsIGRhdGEpKQogKiAgICAgICAgIGZ1bmN0aW9uKHVzZXIsIGZuKSB7CiAqICAgICAgICAgICAgIHVzZXIuZ2V0Q2F0cyhmbik7ICAgICAgLy8gJ2dldENhdHMnIGhhcyBzaWduYXR1cmUgKGNhbGxiYWNrKGVyciwgZGF0YSkpCiAqICAgICAgICAgfQogKiAgICAgKShyZXEuc2Vzc2lvbi51c2VyX2lkLCBmdW5jdGlvbiAoZXJyLCBjYXRzKSB7CiAqICAgICAgICAgaWYgKGVycikgewogKiAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7CiAqICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oeyBzdGF0dXM6ICdlcnJvcicsIG1lc3NhZ2U6IGVyci5tZXNzYWdlIH0pOwogKiAgICAgICAgIH0gZWxzZSB7CiAqICAgICAgICAgICAgIHJlc3BvbnNlLmpzb24oeyBzdGF0dXM6ICdvaycsIG1lc3NhZ2U6ICdDYXRzIGZvdW5kJywgZGF0YTogY2F0cyB9KTsKICogICAgICAgICB9CiAqICAgICB9KTsKICogfSk7CiAqLwpmdW5jdGlvbiBzZXEoLyouLi5mdW5jdGlvbnMqLykgewogICAgdmFyIF9mdW5jdGlvbnMgPSBhcnJheU1hcChhcmd1bWVudHMsIHdyYXBBc3luYyk7CiAgICByZXR1cm4gZnVuY3Rpb24oLyouLi5hcmdzKi8pIHsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cyk7CiAgICAgICAgdmFyIHRoYXQgPSB0aGlzOwoKICAgICAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07CiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIGFyZ3MucG9wKCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY2IgPSBub29wOwogICAgICAgIH0KCiAgICAgICAgcmVkdWNlKF9mdW5jdGlvbnMsIGFyZ3MsIGZ1bmN0aW9uKG5ld2FyZ3MsIGZuLCBjYikgewogICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBuZXdhcmdzLmNvbmNhdChmdW5jdGlvbihlcnIvKiwgLi4ubmV4dGFyZ3MqLykgewogICAgICAgICAgICAgICAgdmFyIG5leHRhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICAgICAgICAgIGNiKGVyciwgbmV4dGFyZ3MpOwogICAgICAgICAgICB9KSk7CiAgICAgICAgfSwKICAgICAgICBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICAgICAgICAgICAgY2IuYXBwbHkodGhhdCwgW2Vycl0uY29uY2F0KHJlc3VsdHMpKTsKICAgICAgICB9KTsKICAgIH07Cn0KCi8qKgogKiBDcmVhdGVzIGEgZnVuY3Rpb24gd2hpY2ggaXMgYSBjb21wb3NpdGlvbiBvZiB0aGUgcGFzc2VkIGFzeW5jaHJvbm91cwogKiBmdW5jdGlvbnMuIEVhY2ggZnVuY3Rpb24gY29uc3VtZXMgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdAogKiBmb2xsb3dzLiBDb21wb3NpbmcgZnVuY3Rpb25zIGBmKClgLCBgZygpYCwgYW5kIGBoKClgIHdvdWxkIHByb2R1Y2UgdGhlIHJlc3VsdAogKiBvZiBgZihnKGgoKSkpYCwgb25seSB0aGlzIHZlcnNpb24gdXNlcyBjYWxsYmFja3MgdG8gb2J0YWluIHRoZSByZXR1cm4gdmFsdWVzLgogKgogKiBFYWNoIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBjb21wb3NlZCBmdW5jdGlvbi4KICoKICogQG5hbWUgY29tcG9zZQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7Li4uQXN5bmNGdW5jdGlvbn0gZnVuY3Rpb25zIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbnMgdG8gY29tcG9zZQogKiBAcmV0dXJucyB7RnVuY3Rpb259IGFuIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0aGF0IGlzIHRoZSBjb21wb3NlZAogKiBhc3luY2hyb25vdXMgYGZ1bmN0aW9uc2AKICogQGV4YW1wbGUKICoKICogZnVuY3Rpb24gYWRkMShuLCBjYWxsYmFjaykgewogKiAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgbiArIDEpOwogKiAgICAgfSwgMTApOwogKiB9CiAqCiAqIGZ1bmN0aW9uIG11bDMobiwgY2FsbGJhY2spIHsKICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsIG4gKiAzKTsKICogICAgIH0sIDEwKTsKICogfQogKgogKiB2YXIgYWRkMW11bDMgPSBhc3luYy5jb21wb3NlKG11bDMsIGFkZDEpOwogKiBhZGQxbXVsMyg0LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzIDE1CiAqIH0pOwogKi8KdmFyIGNvbXBvc2UgPSBmdW5jdGlvbigvKi4uLmFyZ3MqLykgewogICAgcmV0dXJuIHNlcS5hcHBseShudWxsLCBzbGljZShhcmd1bWVudHMpLnJldmVyc2UoKSk7Cn07Cgp2YXIgX2NvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7CgovKioKICogVGhlIHNhbWUgYXMgW2Bjb25jYXRgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICoKICogQG5hbWUgY29uY2F0TGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuY29uY2F0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYCwKICogd2hpY2ggc2hvdWxkIHVzZSBhbiBhcnJheSBhcyBpdHMgcmVzdWx0LiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIGFycmF5CiAqIGNvbnRhaW5pbmcgdGhlIGNvbmNhdGVuYXRlZCByZXN1bHRzIG9mIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBJbnZva2VkIHdpdGgKICogKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgY29uY2F0TGltaXQgPSBmdW5jdGlvbihjb2xsLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7CiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTsKICAgIG1hcExpbWl0KGNvbGwsIGxpbWl0LCBmdW5jdGlvbih2YWwsIGNhbGxiYWNrKSB7CiAgICAgICAgX2l0ZXJhdGVlKHZhbCwgZnVuY3Rpb24oZXJyIC8qLCAuLi5hcmdzKi8pIHsKICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBzbGljZShhcmd1bWVudHMsIDEpKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uKGVyciwgbWFwUmVzdWx0cykgewogICAgICAgIHZhciByZXN1bHQgPSBbXTsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcFJlc3VsdHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgaWYgKG1hcFJlc3VsdHNbaV0pIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb25jYXQuYXBwbHkocmVzdWx0LCBtYXBSZXN1bHRzW2ldKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzdWx0KTsKICAgIH0pOwp9OwoKLyoqCiAqIEFwcGxpZXMgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLCBjb25jYXRlbmF0aW5nIHRoZSByZXN1bHRzLiBSZXR1cm5zCiAqIHRoZSBjb25jYXRlbmF0ZWQgbGlzdC4gVGhlIGBpdGVyYXRlZWBzIGFyZSBjYWxsZWQgaW4gcGFyYWxsZWwsIGFuZCB0aGUKICogcmVzdWx0cyBhcmUgY29uY2F0ZW5hdGVkIGFzIHRoZXkgcmV0dXJuLiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUKICogcmVzdWx0cyBhcnJheSB3aWxsIGJlIHJldHVybmVkIGluIHRoZSBvcmlnaW5hbCBvcmRlciBvZiBgY29sbGAgcGFzc2VkIHRvIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9uLgogKgogKiBAbmFtZSBjb25jYXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLAogKiB3aGljaCBzaG91bGQgdXNlIGFuIGFycmF5IGFzIGl0cyByZXN1bHQuIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2soZXJyKV0gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheQogKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdHMpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5jb25jYXQoWydkaXIxJywnZGlyMicsJ2RpcjMnXSwgZnMucmVhZGRpciwgZnVuY3Rpb24oZXJyLCBmaWxlcykgewogKiAgICAgLy8gZmlsZXMgaXMgbm93IGEgbGlzdCBvZiBmaWxlbmFtZXMgdGhhdCBleGlzdCBpbiB0aGUgMyBkaXJlY3RvcmllcwogKiB9KTsKICovCnZhciBjb25jYXQgPSBkb0xpbWl0KGNvbmNhdExpbWl0LCBJbmZpbml0eSk7CgovKioKICogVGhlIHNhbWUgYXMgW2Bjb25jYXRgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuY29uY2F0fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGNvbmNhdFNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5jb25jYXRde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5jb25jYXR9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGFuIGFycmF5IGFuIGFycmF5IG9mIHJlc3VsdHMuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2soZXJyKV0gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyBhbiBhcnJheQogKiBjb250YWluaW5nIHRoZSBjb25jYXRlbmF0ZWQgcmVzdWx0cyBvZiB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbi4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdHMpLgogKi8KdmFyIGNvbmNhdFNlcmllcyA9IGRvTGltaXQoY29uY2F0TGltaXQsIDEpOwoKLyoqCiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdoZW4gY2FsbGVkLCBjYWxscy1iYWNrIHdpdGggdGhlIHZhbHVlcyBwcm92aWRlZC4KICogVXNlZnVsIGFzIHRoZSBmaXJzdCBmdW5jdGlvbiBpbiBhIFtgd2F0ZXJmYWxsYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndhdGVyZmFsbH0sIG9yIGZvciBwbHVnZ2luZyB2YWx1ZXMgaW4gdG8KICogW2BhdXRvYF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmF1dG99LgogKgogKiBAbmFtZSBjb25zdGFudAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGF1dG9tYXRpY2FsbHkgaW52b2tlCiAqIGNhbGxiYWNrIHdpdGguCiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aGVuIGludm9rZWQsIGF1dG9tYXRpY2FsbHkKICogaW52b2tlcyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcHJldmlvdXMgZ2l2ZW4gYXJndW1lbnRzLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy53YXRlcmZhbGwoWwogKiAgICAgYXN5bmMuY29uc3RhbnQoNDIpLAogKiAgICAgZnVuY3Rpb24gKHZhbHVlLCBuZXh0KSB7CiAqICAgICAgICAgLy8gdmFsdWUgPT09IDQyCiAqICAgICB9LAogKiAgICAgLy8uLi4KICogXSwgY2FsbGJhY2spOwogKgogKiBhc3luYy53YXRlcmZhbGwoWwogKiAgICAgYXN5bmMuY29uc3RhbnQoZmlsZW5hbWUsICJ1dGY4IiksCiAqICAgICBmcy5yZWFkRmlsZSwKICogICAgIGZ1bmN0aW9uIChmaWxlRGF0YSwgbmV4dCkgewogKiAgICAgICAgIC8vLi4uCiAqICAgICB9CiAqICAgICAvLy4uLgogKiBdLCBjYWxsYmFjayk7CiAqCiAqIGFzeW5jLmF1dG8oewogKiAgICAgaG9zdG5hbWU6IGFzeW5jLmNvbnN0YW50KCJodHRwczovL3NlcnZlci5uZXQvIiksCiAqICAgICBwb3J0OiBmaW5kRnJlZVBvcnQsCiAqICAgICBsYXVuY2hTZXJ2ZXI6IFsiaG9zdG5hbWUiLCAicG9ydCIsIGZ1bmN0aW9uIChvcHRpb25zLCBjYikgewogKiAgICAgICAgIHN0YXJ0U2VydmVyKG9wdGlvbnMsIGNiKTsKICogICAgIH1dLAogKiAgICAgLy8uLi4KICogfSwgY2FsbGJhY2spOwogKi8KdmFyIGNvbnN0YW50ID0gZnVuY3Rpb24oLyouLi52YWx1ZXMqLykgewogICAgdmFyIHZhbHVlcyA9IHNsaWNlKGFyZ3VtZW50cyk7CiAgICB2YXIgYXJncyA9IFtudWxsXS5jb25jYXQodmFsdWVzKTsKICAgIHJldHVybiBmdW5jdGlvbiAoLyouLi5pZ25vcmVkQXJncywgY2FsbGJhY2sqLykgewogICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV07CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgfTsKfTsKCi8qKgogKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy4KICoKICogQHN0YXRpYwogKiBAc2luY2UgMC4xLjAKICogQG1lbWJlck9mIF8KICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuCiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuCiAqIEBleGFtcGxlCiAqCiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9OwogKgogKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7CiAqIC8vID0+IHRydWUKICovCmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7CiAgcmV0dXJuIHZhbHVlOwp9CgpmdW5jdGlvbiBfY3JlYXRlVGVzdGVyKGNoZWNrLCBnZXRSZXN1bHQpIHsKICAgIHJldHVybiBmdW5jdGlvbihlYWNoZm4sIGFyciwgaXRlcmF0ZWUsIGNiKSB7CiAgICAgICAgY2IgPSBjYiB8fCBub29wOwogICAgICAgIHZhciB0ZXN0UGFzc2VkID0gZmFsc2U7CiAgICAgICAgdmFyIHRlc3RSZXN1bHQ7CiAgICAgICAgZWFjaGZuKGFyciwgZnVuY3Rpb24odmFsdWUsIF8sIGNhbGxiYWNrKSB7CiAgICAgICAgICAgIGl0ZXJhdGVlKHZhbHVlLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogICAgICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoZWNrKHJlc3VsdCkgJiYgIXRlc3RSZXN1bHQpIHsKICAgICAgICAgICAgICAgICAgICB0ZXN0UGFzc2VkID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICB0ZXN0UmVzdWx0ID0gZ2V0UmVzdWx0KHRydWUsIHZhbHVlKTsKICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBicmVha0xvb3ApOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHsKICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgY2IoZXJyKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNiKG51bGwsIHRlc3RQYXNzZWQgPyB0ZXN0UmVzdWx0IDogZ2V0UmVzdWx0KGZhbHNlKSk7CiAgICAgICAgICAgIH0KICAgICAgICB9KTsKICAgIH07Cn0KCmZ1bmN0aW9uIF9maW5kR2V0UmVzdWx0KHYsIHgpIHsKICAgIHJldHVybiB4Owp9CgovKioKICogUmV0dXJucyB0aGUgZmlyc3QgdmFsdWUgaW4gYGNvbGxgIHRoYXQgcGFzc2VzIGFuIGFzeW5jIHRydXRoIHRlc3QuIFRoZQogKiBgaXRlcmF0ZWVgIGlzIGFwcGxpZWQgaW4gcGFyYWxsZWwsIG1lYW5pbmcgdGhlIGZpcnN0IGl0ZXJhdGVlIHRvIHJldHVybgogKiBgdHJ1ZWAgd2lsbCBmaXJlIHRoZSBkZXRlY3QgYGNhbGxiYWNrYCB3aXRoIHRoYXQgcmVzdWx0LiBUaGF0IG1lYW5zIHRoZQogKiByZXN1bHQgbWlnaHQgbm90IGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBvcmlnaW5hbCBgY29sbGAgKGluIHRlcm1zIG9mIG9yZGVyKQogKiB0aGF0IHBhc3NlcyB0aGUgdGVzdC4KCiAqIElmIG9yZGVyIHdpdGhpbiB0aGUgb3JpZ2luYWwgYGNvbGxgIGlzIGltcG9ydGFudCwgdGhlbiBsb29rIGF0CiAqIFtgZGV0ZWN0U2VyaWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdFNlcmllc30uCiAqCiAqIEBuYW1lIGRldGVjdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAYWxpYXMgZmluZAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnMKICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyByZXN1bHQuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnkKICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4KICogUmVzdWx0IHdpbGwgYmUgdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGFycmF5IHRoYXQgcGFzc2VzIHRoZSB0cnV0aCB0ZXN0CiAqIChpdGVyYXRlZSkgb3IgdGhlIHZhbHVlIGB1bmRlZmluZWRgIGlmIG5vbmUgcGFzc2VkLiBJbnZva2VkIHdpdGgKICogKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICoKICogYXN5bmMuZGV0ZWN0KFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGVQYXRoLCBjYWxsYmFjaykgewogKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyB0aGUgZmlyc3QgZmlsZSBpbiB0aGUgbGlzdCB0aGF0IGV4aXN0cwogKiB9KTsKICovCnZhciBkZXRlY3QgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIoaWRlbnRpdHksIF9maW5kR2V0UmVzdWx0KSk7CgovKioKICogVGhlIHNhbWUgYXMgW2BkZXRlY3RgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEKICogdGltZS4KICoKICogQG5hbWUgZGV0ZWN0TGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZGV0ZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZGV0ZWN0fQogKiBAYWxpYXMgZmluZExpbWl0CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9ucwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgcmVzdWx0LgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55CiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuCiAqIFJlc3VsdCB3aWxsIGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyB0aGUgdHJ1dGggdGVzdAogKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdCkuCiAqLwp2YXIgZGV0ZWN0TGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3RlcihpZGVudGl0eSwgX2ZpbmRHZXRSZXN1bHQpKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGRldGVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5kZXRlY3R9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgZGV0ZWN0U2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmRldGVjdF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmRldGVjdH0KICogQGFsaWFzIGZpbmRTZXJpZXMKICogQGNhdGVnb3J5IENvbGxlY3Rpb25zCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgcmVzdWx0LgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55CiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuCiAqIFJlc3VsdCB3aWxsIGJlIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSB0aGF0IHBhc3NlcyB0aGUgdHJ1dGggdGVzdAogKiAoaXRlcmF0ZWUpIG9yIHRoZSB2YWx1ZSBgdW5kZWZpbmVkYCBpZiBub25lIHBhc3NlZC4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdCkuCiAqLwp2YXIgZGV0ZWN0U2VyaWVzID0gZG9MaW1pdChkZXRlY3RMaW1pdCwgMSk7CgpmdW5jdGlvbiBjb25zb2xlRnVuYyhuYW1lKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKGZuLyosIC4uLmFyZ3MqLykgewogICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyci8qLCAuLi5hcmdzKi8pIHsKICAgICAgICAgICAgdmFyIGFyZ3MgPSBzbGljZShhcmd1bWVudHMsIDEpOwogICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnNvbGUuZXJyb3IpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVtuYW1lXSkgewogICAgICAgICAgICAgICAgICAgIGFycmF5RWFjaChhcmdzLCBmdW5jdGlvbiAoeCkgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlW25hbWVdKHgpOwogICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgd3JhcEFzeW5jKGZuKS5hcHBseShudWxsLCBhcmdzKTsKICAgIH07Cn0KCi8qKgogKiBMb2dzIHRoZSByZXN1bHQgb2YgYW4gW2Bhc3luY2AgZnVuY3Rpb25de0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHRoZQogKiBgY29uc29sZWAgdXNpbmcgYGNvbnNvbGUuZGlyYCB0byBkaXNwbGF5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSByZXN1bHRpbmcgb2JqZWN0LgogKiBPbmx5IHdvcmtzIGluIE5vZGUuanMgb3IgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGBjb25zb2xlLmRpcmAgYW5kCiAqIGBjb25zb2xlLmVycm9yYCAoc3VjaCBhcyBGRiBhbmQgQ2hyb21lKS4KICogSWYgbXVsdGlwbGUgYXJndW1lbnRzIGFyZSByZXR1cm5lZCBmcm9tIHRoZSBhc3luYyBmdW5jdGlvbiwKICogYGNvbnNvbGUuZGlyYCBpcyBjYWxsZWQgb24gZWFjaCBhcmd1bWVudCBpbiBvcmRlci4KICoKICogQG5hbWUgZGlyCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZnVuY3Rpb24gLSBUaGUgZnVuY3Rpb24geW91IHdhbnQgdG8gZXZlbnR1YWxseSBhcHBseQogKiBhbGwgYXJndW1lbnRzIHRvLgogKiBAcGFyYW0gey4uLip9IGFyZ3VtZW50cy4uLiAtIEFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIGFwcGx5IHRvIHRoZSBmdW5jdGlvbi4KICogQGV4YW1wbGUKICoKICogLy8gaW4gYSBtb2R1bGUKICogdmFyIGhlbGxvID0gZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHsKICogICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwge2hlbGxvOiBuYW1lfSk7CiAqICAgICB9LCAxMDAwKTsKICogfTsKICoKICogLy8gaW4gdGhlIG5vZGUgcmVwbAogKiBub2RlPiBhc3luYy5kaXIoaGVsbG8sICd3b3JsZCcpOwogKiB7aGVsbG86ICd3b3JsZCd9CiAqLwp2YXIgZGlyID0gY29uc29sZUZ1bmMoJ2RpcicpOwoKLyoqCiAqIFRoZSBwb3N0LWNoZWNrIHZlcnNpb24gb2YgW2BkdXJpbmdgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuZHVyaW5nfS4gVG8gcmVmbGVjdCB0aGUgZGlmZmVyZW5jZSBpbgogKiB0aGUgb3JkZXIgb2Ygb3BlcmF0aW9ucywgdGhlIGFyZ3VtZW50cyBgdGVzdGAgYW5kIGBmbmAgYXJlIHN3aXRjaGVkLgogKgogKiBBbHNvIGEgdmVyc2lvbiBvZiBbYGRvV2hpbHN0YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fSB3aXRoIGFzeW5jaHJvbm91cyBgdGVzdGAgZnVuY3Rpb24uCiAqIEBuYW1lIGRvRHVyaW5nCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmR1cmluZ117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmR1cmluZ30KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZQogKiBgdGVzdGAgcGFzc2VzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0ZXN0IC0gYXN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBiZWZvcmUgZWFjaAogKiBleGVjdXRpb24gb2YgYGZuYC4gSW52b2tlZCB3aXRoICguLi5hcmdzLCBjYWxsYmFjayksIHdoZXJlIGAuLi5hcmdzYCBhcmUgdGhlCiAqIG5vbi1lcnJvciBhcmdzIGZyb20gdGhlIHByZXZpb3VzIGNhbGxiYWNrIG9mIGBmbmAuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdAogKiBmdW5jdGlvbiBoYXMgZmFpbGVkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGZuYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYAogKiB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBpZiBvbmUgb2NjdXJyZWQsIG90aGVyd2lzZSBgbnVsbGAuCiAqLwpmdW5jdGlvbiBkb0R1cmluZyhmbiwgdGVzdCwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25seU9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICB2YXIgX2ZuID0gd3JhcEFzeW5jKGZuKTsKICAgIHZhciBfdGVzdCA9IHdyYXBBc3luYyh0ZXN0KTsKCiAgICBmdW5jdGlvbiBuZXh0KGVyci8qLCAuLi5hcmdzKi8pIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgYXJncy5wdXNoKGNoZWNrKTsKICAgICAgICBfdGVzdC5hcHBseSh0aGlzLCBhcmdzKTsKICAgIH0KCiAgICBmdW5jdGlvbiBjaGVjayhlcnIsIHRydXRoKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgaWYgKCF0cnV0aCkgcmV0dXJuIGNhbGxiYWNrKG51bGwpOwogICAgICAgIF9mbihuZXh0KTsKICAgIH0KCiAgICBjaGVjayhudWxsLCB0cnVlKTsKCn0KCi8qKgogKiBUaGUgcG9zdC1jaGVjayB2ZXJzaW9uIG9mIFtgd2hpbHN0YF17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LndoaWxzdH0uIFRvIHJlZmxlY3QgdGhlIGRpZmZlcmVuY2UgaW4KICogdGhlIG9yZGVyIG9mIG9wZXJhdGlvbnMsIHRoZSBhcmd1bWVudHMgYHRlc3RgIGFuZCBgaXRlcmF0ZWVgIGFyZSBzd2l0Y2hlZC4KICoKICogYGRvV2hpbHN0YCBpcyB0byBgd2hpbHN0YCBhcyBgZG8gd2hpbGVgIGlzIHRvIGB3aGlsZWAgaW4gcGxhaW4gSmF2YVNjcmlwdC4KICoKICogQG5hbWUgZG9XaGlsc3QKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMud2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWUgYHRlc3RgCiAqIHBhc3Nlcy4gSW52b2tlZCB3aXRoIChjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYWZ0ZXIgZWFjaAogKiBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYC4gSW52b2tlZCB3aXRoIGFueSBub24tZXJyb3IgY2FsbGJhY2sgcmVzdWx0cyBvZgogKiBgaXRlcmF0ZWVgLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3QKICogZnVuY3Rpb24gaGFzIGZhaWxlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuCiAqIGBjYWxsYmFja2Agd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbAogKiBgaXRlcmF0ZWVgJ3MgY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pOwogKi8KZnVuY3Rpb24gZG9XaGlsc3QoaXRlcmF0ZWUsIHRlc3QsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uKGVyci8qLCAuLi5hcmdzKi8pIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgaWYgKHRlc3QuYXBwbHkodGhpcywgYXJncykpIHJldHVybiBfaXRlcmF0ZWUobmV4dCk7CiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7CiAgICB9OwogICAgX2l0ZXJhdGVlKG5leHQpOwp9CgovKioKICogTGlrZSBbJ2RvV2hpbHN0J117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LmRvV2hpbHN0fSwgZXhjZXB0IHRoZSBgdGVzdGAgaXMgaW52ZXJ0ZWQuIE5vdGUgdGhlCiAqIGFyZ3VtZW50IG9yZGVyaW5nIGRpZmZlcnMgZnJvbSBgdW50aWxgLgogKgogKiBAbmFtZSBkb1VudGlsCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmRvV2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cuZG9XaGlsc3R9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWUKICogYHRlc3RgIGZhaWxzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gdGVzdCAtIHN5bmNocm9ub3VzIHRydXRoIHRlc3QgdG8gcGVyZm9ybSBhZnRlciBlYWNoCiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggYW55IG5vbi1lcnJvciBjYWxsYmFjayByZXN1bHRzIG9mCiAqIGBpdGVyYXRlZWAuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciB0aGUgdGVzdAogKiBmdW5jdGlvbiBoYXMgcGFzc2VkIGFuZCByZXBlYXRlZCBleGVjdXRpb24gb2YgYGl0ZXJhdGVlYCBoYXMgc3RvcHBlZC4gYGNhbGxiYWNrYAogKiB3aWxsIGJlIHBhc3NlZCBhbiBlcnJvciBhbmQgYW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGZpbmFsIGBpdGVyYXRlZWAncwogKiBjYWxsYmFjay4gSW52b2tlZCB3aXRoIChlcnIsIFtyZXN1bHRzXSk7CiAqLwpmdW5jdGlvbiBkb1VudGlsKGl0ZXJhdGVlLCB0ZXN0LCBjYWxsYmFjaykgewogICAgZG9XaGlsc3QoaXRlcmF0ZWUsIGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiAhdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfSwgY2FsbGJhY2spOwp9CgovKioKICogTGlrZSBbYHdoaWxzdGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy53aGlsc3R9LCBleGNlcHQgdGhlIGB0ZXN0YCBpcyBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdAogKiBpcyBwYXNzZWQgYSBjYWxsYmFjayBpbiB0aGUgZm9ybSBvZiBgZnVuY3Rpb24gKGVyciwgdHJ1dGgpYC4gSWYgZXJyb3IgaXMKICogcGFzc2VkIHRvIGB0ZXN0YCBvciBgZm5gLCB0aGUgbWFpbiBjYWxsYmFjayBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUKICogdmFsdWUgb2YgdGhlIGVycm9yLgogKgogKiBAbmFtZSBkdXJpbmcKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMud2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGVzdCAtIGFzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2gKICogZXhlY3V0aW9uIG9mIGBmbmAuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZuIC0gQW4gYXN5bmMgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGVhY2ggdGltZQogKiBgdGVzdGAgcGFzc2VzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0CiAqIGZ1bmN0aW9uIGhhcyBmYWlsZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgZm5gIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgCiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yLCBpZiBvbmUgb2NjdXJyZWQsIG90aGVyd2lzZSBgbnVsbGAuCiAqIEBleGFtcGxlCiAqCiAqIHZhciBjb3VudCA9IDA7CiAqCiAqIGFzeW5jLmR1cmluZygKICogICAgIGZ1bmN0aW9uIChjYWxsYmFjaykgewogKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBjb3VudCA8IDUpOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uIChjYWxsYmFjaykgewogKiAgICAgICAgIGNvdW50Kys7CiAqICAgICAgICAgc2V0VGltZW91dChjYWxsYmFjaywgMTAwMCk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24gKGVycikgewogKiAgICAgICAgIC8vIDUgc2Vjb25kcyBoYXZlIHBhc3NlZAogKiAgICAgfQogKiApOwogKi8KZnVuY3Rpb24gZHVyaW5nKHRlc3QsIGZuLCBjYWxsYmFjaykgewogICAgY2FsbGJhY2sgPSBvbmx5T25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIHZhciBfZm4gPSB3cmFwQXN5bmMoZm4pOwogICAgdmFyIF90ZXN0ID0gd3JhcEFzeW5jKHRlc3QpOwoKICAgIGZ1bmN0aW9uIG5leHQoZXJyKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgX3Rlc3QoY2hlY2spOwogICAgfQoKICAgIGZ1bmN0aW9uIGNoZWNrKGVyciwgdHJ1dGgpIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICBpZiAoIXRydXRoKSByZXR1cm4gY2FsbGJhY2sobnVsbCk7CiAgICAgICAgX2ZuKG5leHQpOwogICAgfQoKICAgIF90ZXN0KGNoZWNrKTsKfQoKZnVuY3Rpb24gX3dpdGhvdXRJbmRleChpdGVyYXRlZSkgewogICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgsIGNhbGxiYWNrKSB7CiAgICAgICAgcmV0dXJuIGl0ZXJhdGVlKHZhbHVlLCBjYWxsYmFjayk7CiAgICB9Owp9CgovKioKICogQXBwbGllcyB0aGUgZnVuY3Rpb24gYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLCBpbiBwYXJhbGxlbC4KICogVGhlIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggYW4gaXRlbSBmcm9tIHRoZSBsaXN0LCBhbmQgYSBjYWxsYmFjayBmb3Igd2hlbgogKiBpdCBoYXMgZmluaXNoZWQuIElmIHRoZSBgaXRlcmF0ZWVgIHBhc3NlcyBhbiBlcnJvciB0byBpdHMgYGNhbGxiYWNrYCwgdGhlCiAqIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZSBgZWFjaGAgZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZQogKiBlcnJvci4KICoKICogTm90ZSwgdGhhdCBzaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW4gcGFyYWxsZWwsCiAqIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci4KICoKICogQG5hbWUgZWFjaAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAYWxpYXMgZm9yRWFjaAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0bwogKiBlYWNoIGl0ZW0gaW4gYGNvbGxgLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLgogKiBJZiB5b3UgbmVlZCB0aGUgaW5kZXgsIHVzZSBgZWFjaE9mYC4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLgogKiBAZXhhbXBsZQogKgogKiAvLyBhc3N1bWluZyBvcGVuRmlsZXMgaXMgYW4gYXJyYXkgb2YgZmlsZSBuYW1lcyBhbmQgc2F2ZUZpbGUgaXMgYSBmdW5jdGlvbgogKiAvLyB0byBzYXZlIHRoZSBtb2RpZmllZCBjb250ZW50cyBvZiB0aGF0IGZpbGU6CiAqCiAqIGFzeW5jLmVhY2gob3BlbkZpbGVzLCBzYXZlRmlsZSwgZnVuY3Rpb24oZXJyKXsKICogICAvLyBpZiBhbnkgb2YgdGhlIHNhdmVzIHByb2R1Y2VkIGFuIGVycm9yLCBlcnIgd291bGQgZXF1YWwgdGhhdCBlcnJvcgogKiB9KTsKICoKICogLy8gYXNzdW1pbmcgb3BlbkZpbGVzIGlzIGFuIGFycmF5IG9mIGZpbGUgbmFtZXMKICogYXN5bmMuZWFjaChvcGVuRmlsZXMsIGZ1bmN0aW9uKGZpbGUsIGNhbGxiYWNrKSB7CiAqCiAqICAgICAvLyBQZXJmb3JtIG9wZXJhdGlvbiBvbiBmaWxlIGhlcmUuCiAqICAgICBjb25zb2xlLmxvZygnUHJvY2Vzc2luZyBmaWxlICcgKyBmaWxlKTsKICoKICogICAgIGlmKCBmaWxlLmxlbmd0aCA+IDMyICkgewogKiAgICAgICBjb25zb2xlLmxvZygnVGhpcyBmaWxlIG5hbWUgaXMgdG9vIGxvbmcnKTsKICogICAgICAgY2FsbGJhY2soJ0ZpbGUgbmFtZSB0b28gbG9uZycpOwogKiAgICAgfSBlbHNlIHsKICogICAgICAgLy8gRG8gd29yayB0byBwcm9jZXNzIGZpbGUgaGVyZQogKiAgICAgICBjb25zb2xlLmxvZygnRmlsZSBwcm9jZXNzZWQnKTsKICogICAgICAgY2FsbGJhY2soKTsKICogICAgIH0KICogfSwgZnVuY3Rpb24oZXJyKSB7CiAqICAgICAvLyBpZiBhbnkgb2YgdGhlIGZpbGUgcHJvY2Vzc2luZyBwcm9kdWNlZCBhbiBlcnJvciwgZXJyIHdvdWxkIGVxdWFsIHRoYXQgZXJyb3IKICogICAgIGlmKCBlcnIgKSB7CiAqICAgICAgIC8vIE9uZSBvZiB0aGUgaXRlcmF0aW9ucyBwcm9kdWNlZCBhbiBlcnJvci4KICogICAgICAgLy8gQWxsIHByb2Nlc3Npbmcgd2lsbCBub3cgc3RvcC4KICogICAgICAgY29uc29sZS5sb2coJ0EgZmlsZSBmYWlsZWQgdG8gcHJvY2VzcycpOwogKiAgICAgfSBlbHNlIHsKICogICAgICAgY29uc29sZS5sb2coJ0FsbCBmaWxlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseScpOwogKiAgICAgfQogKiB9KTsKICovCmZ1bmN0aW9uIGVhY2hMaW1pdChjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGVhY2hPZihjb2xsLCBfd2l0aG91dEluZGV4KHdyYXBBc3luYyhpdGVyYXRlZSkpLCBjYWxsYmFjayk7Cn0KCi8qKgogKiBUaGUgc2FtZSBhcyBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGVhY2hMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0KICogQGFsaWFzIGZvckVhY2hMaW1pdAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS4KICogSWYgeW91IG5lZWQgdGhlIGluZGV4LCB1c2UgYGVhY2hPZkxpbWl0YC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS4KICovCmZ1bmN0aW9uIGVhY2hMaW1pdCQxKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIF9lYWNoT2ZMaW1pdChsaW1pdCkoY29sbCwgX3dpdGhvdXRJbmRleCh3cmFwQXN5bmMoaXRlcmF0ZWUpKSwgY2FsbGJhY2spOwp9CgovKioKICogVGhlIHNhbWUgYXMgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgZWFjaFNlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0KICogQGFsaWFzIGZvckVhY2hTZXJpZXMKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaAogKiBpdGVtIGluIGBjb2xsYC4KICogVGhlIGFycmF5IGluZGV4IGlzIG5vdCBwYXNzZWQgdG8gdGhlIGl0ZXJhdGVlLgogKiBJZiB5b3UgbmVlZCB0aGUgaW5kZXgsIHVzZSBgZWFjaE9mU2VyaWVzYC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbAogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS4KICovCnZhciBlYWNoU2VyaWVzID0gZG9MaW1pdChlYWNoTGltaXQkMSwgMSk7CgovKioKICogV3JhcCBhbiBhc3luYyBmdW5jdGlvbiBhbmQgZW5zdXJlIGl0IGNhbGxzIGl0cyBjYWxsYmFjayBvbiBhIGxhdGVyIHRpY2sgb2YKICogdGhlIGV2ZW50IGxvb3AuICBJZiB0aGUgZnVuY3Rpb24gYWxyZWFkeSBjYWxscyBpdHMgY2FsbGJhY2sgb24gYSBuZXh0IHRpY2ssCiAqIG5vIGV4dHJhIGRlZmVycmFsIGlzIGFkZGVkLiBUaGlzIGlzIHVzZWZ1bCBmb3IgcHJldmVudGluZyBzdGFjayBvdmVyZmxvd3MKICogKGBSYW5nZUVycm9yOiBNYXhpbXVtIGNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZGApIGFuZCBnZW5lcmFsbHkga2VlcGluZwogKiBbWmFsZ29dKGh0dHA6Ly9ibG9nLml6cy5tZS9wb3N0LzU5MTQyNzQyMTQzL2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KQogKiBjb250YWluZWQuIEVTMjAxNyBgYXN5bmNgIGZ1bmN0aW9ucyBhcmUgcmV0dXJuZWQgYXMtaXMgLS0gdGhleSBhcmUgaW1tdW5lCiAqIHRvIFphbGdvJ3MgY29ycnVwdGluZyBpbmZsdWVuY2VzLCBhcyB0aGV5IGFsd2F5cyByZXNvbHZlIG9uIGEgbGF0ZXIgdGljay4KICoKICogQG5hbWUgZW5zdXJlQXN5bmMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IFV0aWwKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBmbiAtIGFuIGFzeW5jIGZ1bmN0aW9uLCBvbmUgdGhhdCBleHBlY3RzIGEgbm9kZS1zdHlsZQogKiBjYWxsYmFjayBhcyBpdHMgbGFzdCBhcmd1bWVudC4KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFJldHVybnMgYSB3cmFwcGVkIGZ1bmN0aW9uIHdpdGggdGhlIGV4YWN0IHNhbWUgY2FsbAogKiBzaWduYXR1cmUgYXMgdGhlIGZ1bmN0aW9uIHBhc3NlZCBpbi4KICogQGV4YW1wbGUKICoKICogZnVuY3Rpb24gc29tZXRpbWVzQXN5bmMoYXJnLCBjYWxsYmFjaykgewogKiAgICAgaWYgKGNhY2hlW2FyZ10pIHsKICogICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgY2FjaGVbYXJnXSk7IC8vIHRoaXMgd291bGQgYmUgc3luY2hyb25vdXMhIQogKiAgICAgfSBlbHNlIHsKICogICAgICAgICBkb1NvbWVJTyhhcmcsIGNhbGxiYWNrKTsgLy8gdGhpcyBJTyB3b3VsZCBiZSBhc3luY2hyb25vdXMKICogICAgIH0KICogfQogKgogKiAvLyB0aGlzIGhhcyBhIHJpc2sgb2Ygc3RhY2sgb3ZlcmZsb3dzIGlmIG1hbnkgcmVzdWx0cyBhcmUgY2FjaGVkIGluIGEgcm93CiAqIGFzeW5jLm1hcFNlcmllcyhhcmdzLCBzb21ldGltZXNBc3luYywgZG9uZSk7CiAqCiAqIC8vIHRoaXMgd2lsbCBkZWZlciBzb21ldGltZXNBc3luYydzIGNhbGxiYWNrIGlmIG5lY2Vzc2FyeSwKICogLy8gcHJldmVudGluZyBzdGFjayBvdmVyZmxvd3MKICogYXN5bmMubWFwU2VyaWVzKGFyZ3MsIGFzeW5jLmVuc3VyZUFzeW5jKHNvbWV0aW1lc0FzeW5jKSwgZG9uZSk7CiAqLwpmdW5jdGlvbiBlbnN1cmVBc3luYyhmbikgewogICAgaWYgKGlzQXN5bmMoZm4pKSByZXR1cm4gZm47CiAgICByZXR1cm4gaW5pdGlhbFBhcmFtcyhmdW5jdGlvbiAoYXJncywgY2FsbGJhY2spIHsKICAgICAgICB2YXIgc3luYyA9IHRydWU7CiAgICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgdmFyIGlubmVyQXJncyA9IGFyZ3VtZW50czsKICAgICAgICAgICAgaWYgKHN5bmMpIHsKICAgICAgICAgICAgICAgIHNldEltbWVkaWF0ZSQxKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBpbm5lckFyZ3MpOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBpbm5lckFyZ3MpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7CiAgICAgICAgc3luYyA9IGZhbHNlOwogICAgfSk7Cn0KCmZ1bmN0aW9uIG5vdElkKHYpIHsKICAgIHJldHVybiAhdjsKfQoKLyoqCiAqIFJldHVybnMgYHRydWVgIGlmIGV2ZXJ5IGVsZW1lbnQgaW4gYGNvbGxgIHNhdGlzZmllcyBhbiBhc3luYyB0ZXN0LiBJZiBhbnkKICogaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGBmYWxzZWAsIHRoZSBtYWluIGBjYWxsYmFja2AgaXMgaW1tZWRpYXRlbHkgY2FsbGVkLgogKgogKiBAbmFtZSBldmVyeQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAYWxpYXMgYWxsCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtCiAqIGluIHRoZSBjb2xsZWN0aW9uIGluIHBhcmFsbGVsLgogKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiByZXN1bHQgdmFsdWUuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAKICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICoKICogYXN5bmMuZXZlcnkoWydmaWxlMScsJ2ZpbGUyJywnZmlsZTMnXSwgZnVuY3Rpb24oZmlsZVBhdGgsIGNhbGxiYWNrKSB7CiAqICAgICBmcy5hY2Nlc3MoZmlsZVBhdGgsIGZ1bmN0aW9uKGVycikgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICFlcnIpCiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIGlmIHJlc3VsdCBpcyB0cnVlIHRoZW4gZXZlcnkgZmlsZSBleGlzdHMKICogfSk7CiAqLwp2YXIgZXZlcnkgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIobm90SWQsIG5vdElkKSk7CgovKioKICogVGhlIHNhbWUgYXMgW2BldmVyeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGV2ZXJ5TGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZXZlcnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ldmVyeX0KICogQGFsaWFzIGFsbExpbWl0CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0KICogaW4gdGhlIGNvbGxlY3Rpb24gaW4gcGFyYWxsZWwuCiAqIFRoZSBpdGVyYXRlZSBtdXN0IGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHJlc3VsdCB2YWx1ZS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYAogKiBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMgdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKi8KdmFyIGV2ZXJ5TGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3Rlcihub3RJZCwgbm90SWQpKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGV2ZXJ5YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmV2ZXJ5fSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIGV2ZXJ5U2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmV2ZXJ5XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZXZlcnl9CiAqIEBhbGlhcyBhbGxTZXJpZXMKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0KICogaW4gdGhlIGNvbGxlY3Rpb24gaW4gc2VyaWVzLgogKiBUaGUgaXRlcmF0ZWUgbXVzdCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiByZXN1bHQgdmFsdWUuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAKICogZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICovCnZhciBldmVyeVNlcmllcyA9IGRvTGltaXQoZXZlcnlMaW1pdCwgMSk7CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy4KICoKICogQHByaXZhdGUKICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLgogKi8KZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkgewogIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHsKICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldOwogIH07Cn0KCmZ1bmN0aW9uIGZpbHRlckFycmF5KGVhY2hmbiwgYXJyLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHZhciB0cnV0aFZhbHVlcyA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsKICAgIGVhY2hmbihhcnIsIGZ1bmN0aW9uICh4LCBpbmRleCwgY2FsbGJhY2spIHsKICAgICAgICBpdGVyYXRlZSh4LCBmdW5jdGlvbiAoZXJyLCB2KSB7CiAgICAgICAgICAgIHRydXRoVmFsdWVzW2luZGV4XSA9ICEhdjsKICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICB2YXIgcmVzdWx0cyA9IFtdOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmICh0cnV0aFZhbHVlc1tpXSkgcmVzdWx0cy5wdXNoKGFycltpXSk7CiAgICAgICAgfQogICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpOwogICAgfSk7Cn0KCmZ1bmN0aW9uIGZpbHRlckdlbmVyaWMoZWFjaGZuLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHZhciByZXN1bHRzID0gW107CiAgICBlYWNoZm4oY29sbCwgZnVuY3Rpb24gKHgsIGluZGV4LCBjYWxsYmFjaykgewogICAgICAgIGl0ZXJhdGVlKHgsIGZ1bmN0aW9uIChlcnIsIHYpIHsKICAgICAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGlmICh2KSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtpbmRleDogaW5kZXgsIHZhbHVlOiB4fSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjYWxsYmFjaygpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICB9LCBmdW5jdGlvbiAoZXJyKSB7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgICBjYWxsYmFjayhlcnIpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGFycmF5TWFwKHJlc3VsdHMuc29ydChmdW5jdGlvbiAoYSwgYikgewogICAgICAgICAgICAgICAgcmV0dXJuIGEuaW5kZXggLSBiLmluZGV4OwogICAgICAgICAgICB9KSwgYmFzZVByb3BlcnR5KCd2YWx1ZScpKSk7CiAgICAgICAgfQogICAgfSk7Cn0KCmZ1bmN0aW9uIF9maWx0ZXIoZWFjaGZuLCBjb2xsLCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIHZhciBmaWx0ZXIgPSBpc0FycmF5TGlrZShjb2xsKSA/IGZpbHRlckFycmF5IDogZmlsdGVyR2VuZXJpYzsKICAgIGZpbHRlcihlYWNoZm4sIGNvbGwsIHdyYXBBc3luYyhpdGVyYXRlZSksIGNhbGxiYWNrIHx8IG5vb3ApOwp9CgovKioKICogUmV0dXJucyBhIG5ldyBhcnJheSBvZiBhbGwgdGhlIHZhbHVlcyBpbiBgY29sbGAgd2hpY2ggcGFzcyBhbiBhc3luYyB0cnV0aAogKiB0ZXN0LiBUaGlzIG9wZXJhdGlvbiBpcyBwZXJmb3JtZWQgaW4gcGFyYWxsZWwsIGJ1dCB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGJlCiAqIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSBvcmlnaW5hbC4KICoKICogQG5hbWUgZmlsdGVyCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBhbGlhcyBzZWxlY3QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgYGl0ZXJhdGVlYCBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAsIHdoaWNoIG11c3QgYmUgY2FsbGVkCiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICogQGV4YW1wbGUKICoKICogYXN5bmMuZmlsdGVyKFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGVQYXRoLCBjYWxsYmFjaykgewogKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIHRoZSBleGlzdGluZyBmaWxlcwogKiB9KTsKICovCnZhciBmaWx0ZXIgPSBkb1BhcmFsbGVsKF9maWx0ZXIpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZmlsdGVyYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhCiAqIHRpbWUuCiAqCiAqIEBuYW1lIGZpbHRlckxpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmZpbHRlcl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0KICogQGFsaWFzIHNlbGVjdExpbWl0CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4gYGNvbGxgLgogKiBUaGUgYGl0ZXJhdGVlYCBpcyBwYXNzZWQgYSBgY2FsbGJhY2soZXJyLCB0cnV0aFZhbHVlKWAsIHdoaWNoIG11c3QgYmUgY2FsbGVkCiAqIHdpdGggYSBib29sZWFuIGFyZ3VtZW50IG9uY2UgaXQgaGFzIGNvbXBsZXRlZC4gSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICovCnZhciBmaWx0ZXJMaW1pdCA9IGRvUGFyYWxsZWxMaW1pdChfZmlsdGVyKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgZmlsdGVyU2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmZpbHRlcl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmZpbHRlcn0KICogQGFsaWFzIHNlbGVjdFNlcmllcwogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQSB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbiBgY29sbGAuCiAqIFRoZSBgaXRlcmF0ZWVgIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHRydXRoVmFsdWUpYCwgd2hpY2ggbXVzdCBiZSBjYWxsZWQKICogd2l0aCBhIGJvb2xlYW4gYXJndW1lbnQgb25jZSBpdCBoYXMgY29tcGxldGVkLiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIGFsbCB0aGUKICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpCiAqLwp2YXIgZmlsdGVyU2VyaWVzID0gZG9MaW1pdChmaWx0ZXJMaW1pdCwgMSk7CgovKioKICogQ2FsbHMgdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiBgZm5gIHdpdGggYSBjYWxsYmFjayBwYXJhbWV0ZXIgdGhhdCBhbGxvd3MgaXQKICogdG8gY2FsbCBpdHNlbGYgYWdhaW4sIGluIHNlcmllcywgaW5kZWZpbml0ZWx5LgoKICogSWYgYW4gZXJyb3IgaXMgcGFzc2VkIHRvIHRoZSBjYWxsYmFjayB0aGVuIGBlcnJiYWNrYCBpcyBjYWxsZWQgd2l0aCB0aGUKICogZXJyb3IsIGFuZCBleGVjdXRpb24gc3RvcHMsIG90aGVyd2lzZSBpdCB3aWxsIG5ldmVyIGJlIGNhbGxlZC4KICoKICogQG5hbWUgZm9yZXZlcgogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBhbiBhc3luYyBmdW5jdGlvbiB0byBjYWxsIHJlcGVhdGVkbHkuCiAqIEludm9rZWQgd2l0aCAobmV4dCkuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtlcnJiYWNrXSAtIHdoZW4gYGZuYCBwYXNzZXMgYW4gZXJyb3IgdG8gaXQncyBjYWxsYmFjaywKICogdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCwgYW5kIGV4ZWN1dGlvbiBzdG9wcy4gSW52b2tlZCB3aXRoIChlcnIpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5mb3JldmVyKAogKiAgICAgZnVuY3Rpb24obmV4dCkgewogKiAgICAgICAgIC8vIG5leHQgaXMgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gdGhpbmdzIHRoYXQgbmVlZCBhIGNhbGxiYWNrKGVyciBbLCB3aGF0ZXZlcl0pOwogKiAgICAgICAgIC8vIGl0IHdpbGwgcmVzdWx0IGluIHRoaXMgZnVuY3Rpb24gYmVpbmcgY2FsbGVkIGFnYWluLgogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGVycikgewogKiAgICAgICAgIC8vIGlmIG5leHQgaXMgY2FsbGVkIHdpdGggYSB2YWx1ZSBpbiBpdHMgZmlyc3QgcGFyYW1ldGVyLCBpdCB3aWxsIGFwcGVhcgogKiAgICAgICAgIC8vIGluIGhlcmUgYXMgJ2VycicsIGFuZCBleGVjdXRpb24gd2lsbCBzdG9wLgogKiAgICAgfQogKiApOwogKi8KZnVuY3Rpb24gZm9yZXZlcihmbiwgZXJyYmFjaykgewogICAgdmFyIGRvbmUgPSBvbmx5T25jZShlcnJiYWNrIHx8IG5vb3ApOwogICAgdmFyIHRhc2sgPSB3cmFwQXN5bmMoZW5zdXJlQXN5bmMoZm4pKTsKCiAgICBmdW5jdGlvbiBuZXh0KGVycikgewogICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7CiAgICAgICAgdGFzayhuZXh0KTsKICAgIH0KICAgIG5leHQoKTsKfQoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgZ3JvdXBCeWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICoKICogQG5hbWUgZ3JvdXBCeUxpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci4KICogSW52b2tlZCB3aXRoICh2YWx1ZSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzCiAqIHByb3BlcnRpZXMgYXJlIGFycmF5cyBvZiB2YWx1ZXMgd2hpY2ggcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LgogKi8KdmFyIGdyb3VwQnlMaW1pdCA9IGZ1bmN0aW9uKGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDsKICAgIHZhciBfaXRlcmF0ZWUgPSB3cmFwQXN5bmMoaXRlcmF0ZWUpOwogICAgbWFwTGltaXQoY29sbCwgbGltaXQsIGZ1bmN0aW9uKHZhbCwgY2FsbGJhY2spIHsKICAgICAgICBfaXRlcmF0ZWUodmFsLCBmdW5jdGlvbihlcnIsIGtleSkgewogICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHtrZXk6IGtleSwgdmFsOiB2YWx9KTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uKGVyciwgbWFwUmVzdWx0cykgewogICAgICAgIHZhciByZXN1bHQgPSB7fTsKICAgICAgICAvLyBmcm9tIE1ETiwgaGFuZGxlIG9iamVjdCBoYXZpbmcgYW4gYGhhc093blByb3BlcnR5YCBwcm9wCiAgICAgICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTsKCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBSZXN1bHRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGlmIChtYXBSZXN1bHRzW2ldKSB7CiAgICAgICAgICAgICAgICB2YXIga2V5ID0gbWFwUmVzdWx0c1tpXS5rZXk7CiAgICAgICAgICAgICAgICB2YXIgdmFsID0gbWFwUmVzdWx0c1tpXS52YWw7CgogICAgICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0ucHVzaCh2YWwpOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IFt2YWxdOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCByZXN1bHQpOwogICAgfSk7Cn07CgovKioKICogUmV0dXJucyBhIG5ldyBvYmplY3QsIHdoZXJlIGVhY2ggdmFsdWUgY29ycmVzcG9uZHMgdG8gYW4gYXJyYXkgb2YgaXRlbXMsIGZyb20KICogYGNvbGxgLCB0aGF0IHJldHVybmVkIHRoZSBjb3JyZXNwb25kaW5nIGtleS4gVGhhdCBpcywgdGhlIGtleXMgb2YgdGhlIG9iamVjdAogKiBjb3JyZXNwb25kIHRvIHRoZSB2YWx1ZXMgcGFzc2VkIHRvIHRoZSBgaXRlcmF0ZWVgIGNhbGxiYWNrLgogKgogKiBOb3RlOiBTaW5jZSB0aGlzIGZ1bmN0aW9uIGFwcGxpZXMgdGhlIGBpdGVyYXRlZWAgdG8gZWFjaCBpdGVtIGluIHBhcmFsbGVsLAogKiB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZSBpbiBvcmRlci4KICogSG93ZXZlciwgdGhlIHZhbHVlcyBmb3IgZWFjaCBrZXkgaW4gdGhlIGByZXN1bHRgIHdpbGwgYmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMKICogdGhlIG9yaWdpbmFsIGBjb2xsYC4gRm9yIE9iamVjdHMsIHRoZSB2YWx1ZXMgd2lsbCByb3VnaGx5IGJlIGluIHRoZSBvcmRlciBvZgogKiB0aGUgb3JpZ2luYWwgT2JqZWN0cycga2V5cyAoYnV0IHRoaXMgY2FuIHZhcnkgYWNyb3NzIEphdmFTY3JpcHQgZW5naW5lcykuCiAqCiAqIEBuYW1lIGdyb3VwQnkKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYGtleWAgdG8gZ3JvdXAgdGhlIHZhbHVlIHVuZGVyLgogKiBJbnZva2VkIHdpdGggKHZhbHVlLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIFJlc3VsdCBpcyBhbiBgT2JqZWN0YCB3aG9zZXMKICogcHJvcGVydGllcyBhcmUgYXJyYXlzIG9mIHZhbHVlcyB3aGljaCByZXR1cm5lZCB0aGUgY29ycmVzcG9uZGluZyBrZXkuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmdyb3VwQnkoWyd1c2VySWQxJywgJ3VzZXJJZDInLCAndXNlcklkMyddLCBmdW5jdGlvbih1c2VySWQsIGNhbGxiYWNrKSB7CiAqICAgICBkYi5maW5kQnlJZCh1c2VySWQsIGZ1bmN0aW9uKGVyciwgdXNlcikgewogKiAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB1c2VyLmFnZSk7CiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBpcyBvYmplY3QgY29udGFpbmluZyB0aGUgdXNlcklkcyBncm91cGVkIGJ5IGFnZQogKiAgICAgLy8gZS5nLiB7IDMwOiBbJ3VzZXJJZDEnLCAndXNlcklkMyddLCA0MjogWyd1c2VySWQyJ119OwogKiB9KTsKICovCnZhciBncm91cEJ5ID0gZG9MaW1pdChncm91cEJ5TGltaXQsIEluZmluaXR5KTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYGdyb3VwQnlgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZ3JvdXBCeX0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSBncm91cEJ5U2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLmdyb3VwQnlde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5ncm91cEJ5fQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggaXRlbSBpbgogKiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGBrZXlgIHRvIGdyb3VwIHRoZSB2YWx1ZSB1bmRlci4KICogSW52b2tlZCB3aXRoICh2YWx1ZSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGwgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHQgaXMgYW4gYE9iamVjdGAgd2hvc2VzCiAqIHByb3BlcnRpZXMgYXJlIGFycmF5cyBvZiB2YWx1ZXMgd2hpY2ggcmV0dXJuZWQgdGhlIGNvcnJlc3BvbmRpbmcga2V5LgogKi8KdmFyIGdyb3VwQnlTZXJpZXMgPSBkb0xpbWl0KGdyb3VwQnlMaW1pdCwgMSk7CgovKioKICogTG9ncyB0aGUgcmVzdWx0IG9mIGFuIGBhc3luY2AgZnVuY3Rpb24gdG8gdGhlIGBjb25zb2xlYC4gT25seSB3b3JrcyBpbgogKiBOb2RlLmpzIG9yIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBgY29uc29sZS5sb2dgIGFuZCBgY29uc29sZS5lcnJvcmAgKHN1Y2gKICogYXMgRkYgYW5kIENocm9tZSkuIElmIG11bHRpcGxlIGFyZ3VtZW50cyBhcmUgcmV0dXJuZWQgZnJvbSB0aGUgYXN5bmMKICogZnVuY3Rpb24sIGBjb25zb2xlLmxvZ2AgaXMgY2FsbGVkIG9uIGVhY2ggYXJndW1lbnQgaW4gb3JkZXIuCiAqCiAqIEBuYW1lIGxvZwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGZ1bmN0aW9uIC0gVGhlIGZ1bmN0aW9uIHlvdSB3YW50IHRvIGV2ZW50dWFsbHkgYXBwbHkKICogYWxsIGFyZ3VtZW50cyB0by4KICogQHBhcmFtIHsuLi4qfSBhcmd1bWVudHMuLi4gLSBBbnkgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBhcHBseSB0byB0aGUgZnVuY3Rpb24uCiAqIEBleGFtcGxlCiAqCiAqIC8vIGluIGEgbW9kdWxlCiAqIHZhciBoZWxsbyA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7CiAqICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdoZWxsbyAnICsgbmFtZSk7CiAqICAgICB9LCAxMDAwKTsKICogfTsKICoKICogLy8gaW4gdGhlIG5vZGUgcmVwbAogKiBub2RlPiBhc3luYy5sb2coaGVsbG8sICd3b3JsZCcpOwogKiAnaGVsbG8gd29ybGQnCiAqLwp2YXIgbG9nID0gY29uc29sZUZ1bmMoJ2xvZycpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgbWFwVmFsdWVzYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhCiAqIHRpbWUuCiAqCiAqIEBuYW1lIG1hcFZhbHVlc0xpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLm1hcFZhbHVlc117QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCB2YWx1ZSBhbmQga2V5CiAqIGluIGBjb2xsYC4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIHRoZSB0cmFuc2Zvcm1lZCB2YWx1ZSBhcyBpdHMgcmVzdWx0LgogKiBJbnZva2VkIHdpdGggKHZhbHVlLCBrZXksIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsIGBpdGVyYXRlZWAKICogZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gYHJlc3VsdGAgaXMgYSBuZXcgb2JqZWN0IGNvbnNpc3RpbmcKICogb2YgZWFjaCBrZXkgZnJvbSBgb2JqYCwgd2l0aCBlYWNoIHRyYW5zZm9ybWVkIHZhbHVlIG9uIHRoZSByaWdodC1oYW5kIHNpZGUuCiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKi8KZnVuY3Rpb24gbWFwVmFsdWVzTGltaXQob2JqLCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7CiAgICB2YXIgbmV3T2JqID0ge307CiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTsKICAgIGVhY2hPZkxpbWl0KG9iaiwgbGltaXQsIGZ1bmN0aW9uKHZhbCwga2V5LCBuZXh0KSB7CiAgICAgICAgX2l0ZXJhdGVlKHZhbCwga2V5LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIG5leHQoZXJyKTsKICAgICAgICAgICAgbmV3T2JqW2tleV0gPSByZXN1bHQ7CiAgICAgICAgICAgIG5leHQoKTsKICAgICAgICB9KTsKICAgIH0sIGZ1bmN0aW9uIChlcnIpIHsKICAgICAgICBjYWxsYmFjayhlcnIsIG5ld09iaik7CiAgICB9KTsKfQoKLyoqCiAqIEEgcmVsYXRpdmUgb2YgW2BtYXBgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfSwgZGVzaWduZWQgZm9yIHVzZSB3aXRoIG9iamVjdHMuCiAqCiAqIFByb2R1Y2VzIGEgbmV3IE9iamVjdCBieSBtYXBwaW5nIGVhY2ggdmFsdWUgb2YgYG9iamAgdGhyb3VnaCB0aGUgYGl0ZXJhdGVlYAogKiBmdW5jdGlvbi4gVGhlIGBpdGVyYXRlZWAgaXMgY2FsbGVkIGVhY2ggYHZhbHVlYCBhbmQgYGtleWAgZnJvbSBgb2JqYCBhbmQgYQogKiBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFja3MgdGFrZXMKICogdHdvIGFyZ3VtZW50czogYW4gYGVycm9yYCwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBpdGVtIGZyb20gYG9iamAuIElmIGBpdGVyYXRlZWAKICogcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZSBgbWFwVmFsdWVzYAogKiBmdW5jdGlvbikgaXMgaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLgogKgogKiBOb3RlLCB0aGUgb3JkZXIgb2YgdGhlIGtleXMgaW4gdGhlIHJlc3VsdCBpcyBub3QgZ3VhcmFudGVlZC4gIFRoZSBrZXlzIHdpbGwKICogYmUgcm91Z2hseSBpbiB0aGUgb3JkZXIgdGhleSBjb21wbGV0ZSwgKGJ1dCB0aGlzIGlzIHZlcnkgZW5naW5lLXNwZWNpZmljKQogKgogKiBAbmFtZSBtYXBWYWx1ZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWUgYW5kIGtleQogKiBpbiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC4KICogSW52b2tlZCB3aXRoICh2YWx1ZSwga2V5LCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nCiAqIG9mIGVhY2gga2V5IGZyb20gYG9iamAsIHdpdGggZWFjaCB0cmFuc2Zvcm1lZCB2YWx1ZSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlLgogKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICoKICogYXN5bmMubWFwVmFsdWVzKHsKICogICAgIGYxOiAnZmlsZTEnLAogKiAgICAgZjI6ICdmaWxlMicsCiAqICAgICBmMzogJ2ZpbGUzJwogKiB9LCBmdW5jdGlvbiAoZmlsZSwga2V5LCBjYWxsYmFjaykgewogKiAgIGZzLnN0YXQoZmlsZSwgY2FsbGJhY2spOwogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gcmVzdWx0IGlzIG5vdyBhIG1hcCBvZiBzdGF0cyBmb3IgZWFjaCBmaWxlLCBlLmcuCiAqICAgICAvLyB7CiAqICAgICAvLyAgICAgZjE6IFtzdGF0cyBmb3IgZmlsZTFdLAogKiAgICAgLy8gICAgIGYyOiBbc3RhdHMgZm9yIGZpbGUyXSwKICogICAgIC8vICAgICBmMzogW3N0YXRzIGZvciBmaWxlM10KICogICAgIC8vIH0KICogfSk7CiAqLwoKdmFyIG1hcFZhbHVlcyA9IGRvTGltaXQobWFwVmFsdWVzTGltaXQsIEluZmluaXR5KTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYG1hcFZhbHVlc2Bde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXBWYWx1ZXN9IGJ1dCBydW5zIG9ubHkgYSBzaW5nbGUgYXN5bmMgb3BlcmF0aW9uIGF0IGEgdGltZS4KICoKICogQG5hbWUgbWFwVmFsdWVzU2VyaWVzCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLm1hcFZhbHVlc117QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcFZhbHVlc30KICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2ggdmFsdWUgYW5kIGtleQogKiBpbiBgY29sbGAuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgdHJhbnNmb3JtZWQgdmFsdWUgYXMgaXRzIHJlc3VsdC4KICogSW52b2tlZCB3aXRoICh2YWx1ZSwga2V5LCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgCiAqIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIGByZXN1bHRgIGlzIGEgbmV3IG9iamVjdCBjb25zaXN0aW5nCiAqIG9mIGVhY2gga2V5IGZyb20gYG9iamAsIHdpdGggZWFjaCB0cmFuc2Zvcm1lZCB2YWx1ZSBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlLgogKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICovCnZhciBtYXBWYWx1ZXNTZXJpZXMgPSBkb0xpbWl0KG1hcFZhbHVlc0xpbWl0LCAxKTsKCmZ1bmN0aW9uIGhhcyhvYmosIGtleSkgewogICAgcmV0dXJuIGtleSBpbiBvYmo7Cn0KCi8qKgogKiBDYWNoZXMgdGhlIHJlc3VsdHMgb2YgYW4gYXN5bmMgZnVuY3Rpb24uIFdoZW4gY3JlYXRpbmcgYSBoYXNoIHRvIHN0b3JlCiAqIGZ1bmN0aW9uIHJlc3VsdHMgYWdhaW5zdCwgdGhlIGNhbGxiYWNrIGlzIG9taXR0ZWQgZnJvbSB0aGUgaGFzaCBhbmQgYW4KICogb3B0aW9uYWwgaGFzaCBmdW5jdGlvbiBjYW4gYmUgdXNlZC4KICoKICogSWYgbm8gaGFzaCBmdW5jdGlvbiBpcyBzcGVjaWZpZWQsIHRoZSBmaXJzdCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGFzaCBrZXksCiAqIHdoaWNoIG1heSB3b3JrIHJlYXNvbmFibHkgaWYgaXQgaXMgYSBzdHJpbmcgb3IgYSBkYXRhIHR5cGUgdGhhdCBjb252ZXJ0cyB0byBhCiAqIGRpc3RpbmN0IHN0cmluZy4gTm90ZSB0aGF0IG9iamVjdHMgYW5kIGFycmF5cyB3aWxsIG5vdCBiZWhhdmUgcmVhc29uYWJseS4KICogTmVpdGhlciB3aWxsIGNhc2VzIHdoZXJlIHRoZSBvdGhlciBhcmd1bWVudHMgYXJlIHNpZ25pZmljYW50LiBJbiBzdWNoIGNhc2VzLAogKiBzcGVjaWZ5IHlvdXIgb3duIGhhc2ggZnVuY3Rpb24uCiAqCiAqIFRoZSBjYWNoZSBvZiByZXN1bHRzIGlzIGV4cG9zZWQgYXMgdGhlIGBtZW1vYCBwcm9wZXJ0eSBvZiB0aGUgZnVuY3Rpb24KICogcmV0dXJuZWQgYnkgYG1lbW9pemVgLgogKgogKiBAbmFtZSBtZW1vaXplCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gcHJveHkgYW5kIGNhY2hlIHJlc3VsdHMgZnJvbS4KICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzaGVyIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gZm9yIGdlbmVyYXRpbmcgYSBjdXN0b20gaGFzaAogKiBmb3Igc3RvcmluZyByZXN1bHRzLiBJdCBoYXMgYWxsIHRoZSBhcmd1bWVudHMgYXBwbGllZCB0byBpdCBhcGFydCBmcm9tIHRoZQogKiBjYWxsYmFjaywgYW5kIG11c3QgYmUgc3luY2hyb25vdXMuCiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBhIG1lbW9pemVkIHZlcnNpb24gb2YgYGZuYAogKiBAZXhhbXBsZQogKgogKiB2YXIgc2xvd19mbiA9IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrKSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcKICogICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7CiAqIH07CiAqIHZhciBmbiA9IGFzeW5jLm1lbW9pemUoc2xvd19mbik7CiAqCiAqIC8vIGZuIGNhbiBub3cgYmUgdXNlZCBhcyBpZiBpdCB3ZXJlIHNsb3dfZm4KICogZm4oJ3NvbWUgbmFtZScsIGZ1bmN0aW9uKCkgewogKiAgICAgLy8gY2FsbGJhY2sKICogfSk7CiAqLwpmdW5jdGlvbiBtZW1vaXplKGZuLCBoYXNoZXIpIHsKICAgIHZhciBtZW1vID0gT2JqZWN0LmNyZWF0ZShudWxsKTsKICAgIHZhciBxdWV1ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgaGFzaGVyID0gaGFzaGVyIHx8IGlkZW50aXR5OwogICAgdmFyIF9mbiA9IHdyYXBBc3luYyhmbik7CiAgICB2YXIgbWVtb2l6ZWQgPSBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIG1lbW9pemVkKGFyZ3MsIGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIGtleSA9IGhhc2hlci5hcHBseShudWxsLCBhcmdzKTsKICAgICAgICBpZiAoaGFzKG1lbW8sIGtleSkpIHsKICAgICAgICAgICAgc2V0SW1tZWRpYXRlJDEoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBtZW1vW2tleV0pOwogICAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgaWYgKGhhcyhxdWV1ZXMsIGtleSkpIHsKICAgICAgICAgICAgcXVldWVzW2tleV0ucHVzaChjYWxsYmFjayk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcXVldWVzW2tleV0gPSBbY2FsbGJhY2tdOwogICAgICAgICAgICBfZm4uYXBwbHkobnVsbCwgYXJncy5jb25jYXQoZnVuY3Rpb24oLyphcmdzKi8pIHsKICAgICAgICAgICAgICAgIHZhciBhcmdzID0gc2xpY2UoYXJndW1lbnRzKTsKICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IGFyZ3M7CiAgICAgICAgICAgICAgICB2YXIgcSA9IHF1ZXVlc1trZXldOwogICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXVlc1trZXldOwogICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBxLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgICAgICAgICAgICAgICAgIHFbaV0uYXBwbHkobnVsbCwgYXJncyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pKTsKICAgICAgICB9CiAgICB9KTsKICAgIG1lbW9pemVkLm1lbW8gPSBtZW1vOwogICAgbWVtb2l6ZWQudW5tZW1vaXplZCA9IGZuOwogICAgcmV0dXJuIG1lbW9pemVkOwp9CgovKioKICogQ2FsbHMgYGNhbGxiYWNrYCBvbiBhIGxhdGVyIGxvb3AgYXJvdW5kIHRoZSBldmVudCBsb29wLiBJbiBOb2RlLmpzIHRoaXMganVzdAogKiBjYWxscyBgcHJvY2Vzcy5uZXh0VGljbGAuICBJbiB0aGUgYnJvd3NlciBpdCB3aWxsIHVzZSBgc2V0SW1tZWRpYXRlYCBpZgogKiBhdmFpbGFibGUsIG90aGVyd2lzZSBgc2V0VGltZW91dChjYWxsYmFjaywgMClgLCB3aGljaCBtZWFucyBvdGhlciBoaWdoZXIKICogcHJpb3JpdHkgZXZlbnRzIG1heSBwcmVjZWRlIHRoZSBleGVjdXRpb24gb2YgYGNhbGxiYWNrYC4KICoKICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgZm9yIGJyb3dzZXItY29tcGF0aWJpbGl0eSBwdXJwb3Nlcy4KICoKICogQG5hbWUgbmV4dFRpY2sKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuc2V0SW1tZWRpYXRlXXtAbGluayBtb2R1bGU6VXRpbHMuc2V0SW1tZWRpYXRlfQogKiBAY2F0ZWdvcnkgVXRpbAogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBjYWxsIG9uIGEgbGF0ZXIgbG9vcCBhcm91bmQKICogdGhlIGV2ZW50IGxvb3AuIEludm9rZWQgd2l0aCAoYXJncy4uLikuCiAqIEBwYXJhbSB7Li4uKn0gYXJncy4uLiAtIGFueSBudW1iZXIgb2YgYWRkaXRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUKICogY2FsbGJhY2sgb24gdGhlIG5leHQgdGljay4KICogQGV4YW1wbGUKICoKICogdmFyIGNhbGxfb3JkZXIgPSBbXTsKICogYXN5bmMubmV4dFRpY2soZnVuY3Rpb24oKSB7CiAqICAgICBjYWxsX29yZGVyLnB1c2goJ3R3bycpOwogKiAgICAgLy8gY2FsbF9vcmRlciBub3cgZXF1YWxzIFsnb25lJywndHdvJ10KICogfSk7CiAqIGNhbGxfb3JkZXIucHVzaCgnb25lJyk7CiAqCiAqIGFzeW5jLnNldEltbWVkaWF0ZShmdW5jdGlvbiAoYSwgYiwgYykgewogKiAgICAgLy8gYSwgYiwgYW5kIGMgZXF1YWwgMSwgMiwgYW5kIDMKICogfSwgMSwgMiwgMyk7CiAqLwp2YXIgX2RlZmVyJDE7CgppZiAoaGFzTmV4dFRpY2spIHsKICAgIF9kZWZlciQxID0gcHJvY2Vzcy5uZXh0VGljazsKfSBlbHNlIGlmIChoYXNTZXRJbW1lZGlhdGUpIHsKICAgIF9kZWZlciQxID0gc2V0SW1tZWRpYXRlOwp9IGVsc2UgewogICAgX2RlZmVyJDEgPSBmYWxsYmFjazsKfQoKdmFyIG5leHRUaWNrID0gd3JhcChfZGVmZXIkMSk7CgpmdW5jdGlvbiBfcGFyYWxsZWwoZWFjaGZuLCB0YXNrcywgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDsKICAgIHZhciByZXN1bHRzID0gaXNBcnJheUxpa2UodGFza3MpID8gW10gOiB7fTsKCiAgICBlYWNoZm4odGFza3MsIGZ1bmN0aW9uICh0YXNrLCBrZXksIGNhbGxiYWNrKSB7CiAgICAgICAgd3JhcEFzeW5jKHRhc2spKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkgewogICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmVzdWx0c1trZXldID0gcmVzdWx0OwogICAgICAgICAgICBjYWxsYmFjayhlcnIpOwogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24gKGVycikgewogICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7CiAgICB9KTsKfQoKLyoqCiAqIFJ1biB0aGUgYHRhc2tzYCBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyBpbiBwYXJhbGxlbCwgd2l0aG91dCB3YWl0aW5nIHVudGlsCiAqIHRoZSBwcmV2aW91cyBmdW5jdGlvbiBoYXMgY29tcGxldGVkLiBJZiBhbnkgb2YgdGhlIGZ1bmN0aW9ucyBwYXNzIGFuIGVycm9yIHRvCiAqIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlCiAqIGVycm9yLiBPbmNlIHRoZSBgdGFza3NgIGhhdmUgY29tcGxldGVkLCB0aGUgcmVzdWx0cyBhcmUgcGFzc2VkIHRvIHRoZSBmaW5hbAogKiBgY2FsbGJhY2tgIGFzIGFuIGFycmF5LgogKgogKiAqKk5vdGU6KiogYHBhcmFsbGVsYCBpcyBhYm91dCBraWNraW5nLW9mZiBJL08gdGFza3MgaW4gcGFyYWxsZWwsIG5vdCBhYm91dAogKiBwYXJhbGxlbCBleGVjdXRpb24gb2YgY29kZS4gIElmIHlvdXIgdGFza3MgZG8gbm90IHVzZSBhbnkgdGltZXJzIG9yIHBlcmZvcm0KICogYW55IEkvTywgdGhleSB3aWxsIGFjdHVhbGx5IGJlIGV4ZWN1dGVkIGluIHNlcmllcy4gIEFueSBzeW5jaHJvbm91cyBzZXR1cAogKiBzZWN0aW9ucyBmb3IgZWFjaCB0YXNrIHdpbGwgaGFwcGVuIG9uZSBhZnRlciB0aGUgb3RoZXIuICBKYXZhU2NyaXB0IHJlbWFpbnMKICogc2luZ2xlLXRocmVhZGVkLgogKgogKiAqKkhpbnQ6KiogVXNlIFtgcmVmbGVjdGBde0BsaW5rIG1vZHVsZTpVdGlscy5yZWZsZWN0fSB0byBjb250aW51ZSB0aGUKICogZXhlY3V0aW9uIG9mIG90aGVyIHRhc2tzIHdoZW4gYSB0YXNrIGZhaWxzLgogKgogKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gRWFjaCBwcm9wZXJ0eSB3aWxsCiAqIGJlIHJ1biBhcyBhIGZ1bmN0aW9uIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYAogKiBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gVGhpcyBjYW4gYmUgYSBtb3JlIHJlYWRhYmxlIHdheSBvZiBoYW5kbGluZwogKiByZXN1bHRzIGZyb20ge0BsaW5rIGFzeW5jLnBhcmFsbGVsfS4KICoKICogQG5hbWUgcGFyYWxsZWwKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gb2YKICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLgogKiBFYWNoIGFzeW5jIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZQogKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGZ1bmN0aW9uIGdldHMgYSByZXN1bHRzIGFycmF5CiAqIChvciBvYmplY3QpIGNvbnRhaW5pbmcgYWxsIHRoZSByZXN1bHQgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgdGFzayBjYWxsYmFja3MuCiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICoKICogQGV4YW1wbGUKICogYXN5bmMucGFyYWxsZWwoWwogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7CiAqICAgICAgICAgfSwgMjAwKTsKICogICAgIH0sCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0d28nKTsKICogICAgICAgICB9LCAxMDApOwogKiAgICAgfQogKiBdLAogKiAvLyBvcHRpb25hbCBjYWxsYmFjawogKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHRoZSByZXN1bHRzIGFycmF5IHdpbGwgZXF1YWwgWydvbmUnLCd0d28nXSBldmVuIHRob3VnaAogKiAgICAgLy8gdGhlIHNlY29uZCBmdW5jdGlvbiBoYWQgYSBzaG9ydGVyIHRpbWVvdXQuCiAqIH0pOwogKgogKiAvLyBhbiBleGFtcGxlIHVzaW5nIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5CiAqIGFzeW5jLnBhcmFsbGVsKHsKICogICAgIG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTsKICogICAgICAgICB9LCAyMDApOwogKiAgICAgfSwKICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgewogKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAyKTsKICogICAgICAgICB9LCAxMDApOwogKiAgICAgfQogKiB9LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFscyB0bzoge29uZTogMSwgdHdvOiAyfQogKiB9KTsKICovCmZ1bmN0aW9uIHBhcmFsbGVsTGltaXQodGFza3MsIGNhbGxiYWNrKSB7CiAgICBfcGFyYWxsZWwoZWFjaE9mLCB0YXNrcywgY2FsbGJhY2spOwp9CgovKioKICogVGhlIHNhbWUgYXMgW2BwYXJhbGxlbGBde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wYXJhbGxlbH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhCiAqIHRpbWUuCiAqCiAqIEBuYW1lIHBhcmFsbGVsTGltaXQKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucGFyYWxsZWxde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5wYXJhbGxlbH0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gb2YKICogW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0gdG8gcnVuLgogKiBFYWNoIGFzeW5jIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBbiBvcHRpb25hbCBjYWxsYmFjayB0byBydW4gb25jZSBhbGwgdGhlCiAqIGZ1bmN0aW9ucyBoYXZlIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhIHJlc3VsdHMgYXJyYXkKICogKG9yIG9iamVjdCkgY29udGFpbmluZyBhbGwgdGhlIHJlc3VsdCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSB0YXNrIGNhbGxiYWNrcy4KICogSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdHMpLgogKi8KZnVuY3Rpb24gcGFyYWxsZWxMaW1pdCQxKHRhc2tzLCBsaW1pdCwgY2FsbGJhY2spIHsKICAgIF9wYXJhbGxlbChfZWFjaE9mTGltaXQobGltaXQpLCB0YXNrcywgY2FsbGJhY2spOwp9CgovKioKICogQSBxdWV1ZSBvZiB0YXNrcyBmb3IgdGhlIHdvcmtlciBmdW5jdGlvbiB0byBjb21wbGV0ZS4KICogQHR5cGVkZWYge09iamVjdH0gUXVldWVPYmplY3QKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBsZW5ndGggLSBhIGZ1bmN0aW9uIHJldHVybmluZyB0aGUgbnVtYmVyIG9mIGl0ZW1zCiAqIHdhaXRpbmcgdG8gYmUgcHJvY2Vzc2VkLiBJbnZva2Ugd2l0aCBgcXVldWUubGVuZ3RoKClgLgogKiBAcHJvcGVydHkge2Jvb2xlYW59IHN0YXJ0ZWQgLSBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIG9yIG5vdCBhbnkKICogaXRlbXMgaGF2ZSBiZWVuIHB1c2hlZCBhbmQgcHJvY2Vzc2VkIGJ5IHRoZSBxdWV1ZS4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcnVubmluZyAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBudW1iZXIgb2YgaXRlbXMKICogY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJ1bm5pbmcoKWAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHdvcmtlcnNMaXN0IC0gYSBmdW5jdGlvbiByZXR1cm5pbmcgdGhlIGFycmF5IG9mIGl0ZW1zCiAqIGN1cnJlbnRseSBiZWluZyBwcm9jZXNzZWQuIEludm9rZSB3aXRoIGBxdWV1ZS53b3JrZXJzTGlzdCgpYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaWRsZSAtIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGZhbHNlIGlmIHRoZXJlIGFyZSBpdGVtcwogKiB3YWl0aW5nIG9yIGJlaW5nIHByb2Nlc3NlZCwgb3IgdHJ1ZSBpZiBub3QuIEludm9rZSB3aXRoIGBxdWV1ZS5pZGxlKClgLgogKiBAcHJvcGVydHkge251bWJlcn0gY29uY3VycmVuY3kgLSBhbiBpbnRlZ2VyIGZvciBkZXRlcm1pbmluZyBob3cgbWFueSBgd29ya2VyYAogKiBmdW5jdGlvbnMgc2hvdWxkIGJlIHJ1biBpbiBwYXJhbGxlbC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgY2hhbmdlZCBhZnRlciBhCiAqIGBxdWV1ZWAgaXMgY3JlYXRlZCB0byBhbHRlciB0aGUgY29uY3VycmVuY3kgb24tdGhlLWZseS4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcHVzaCAtIGFkZCBhIG5ldyB0YXNrIHRvIHRoZSBgcXVldWVgLiBDYWxscyBgY2FsbGJhY2tgCiAqIG9uY2UgdGhlIGB3b3JrZXJgIGhhcyBmaW5pc2hlZCBwcm9jZXNzaW5nIHRoZSB0YXNrLiBJbnN0ZWFkIG9mIGEgc2luZ2xlIHRhc2ssCiAqIGEgYHRhc2tzYCBhcnJheSBjYW4gYmUgc3VibWl0dGVkLiBUaGUgcmVzcGVjdGl2ZSBjYWxsYmFjayBpcyB1c2VkIGZvciBldmVyeQogKiB0YXNrIGluIHRoZSBsaXN0LiBJbnZva2Ugd2l0aCBgcXVldWUucHVzaCh0YXNrLCBbY2FsbGJhY2tdKWAsCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVuc2hpZnQgLSBhZGQgYSBuZXcgdGFzayB0byB0aGUgZnJvbnQgb2YgdGhlIGBxdWV1ZWAuCiAqIEludm9rZSB3aXRoIGBxdWV1ZS51bnNoaWZ0KHRhc2ssIFtjYWxsYmFja10pYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVtb3ZlIC0gcmVtb3ZlIGl0ZW1zIGZyb20gdGhlIHF1ZXVlIHRoYXQgbWF0Y2ggYSB0ZXN0CiAqIGZ1bmN0aW9uLiAgVGhlIHRlc3QgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgYW4gb2JqZWN0IHdpdGggYSBgZGF0YWAgcHJvcGVydHksCiAqIGFuZCBhIGBwcmlvcml0eWAgcHJvcGVydHksIGlmIHRoaXMgaXMgYQogKiBbcHJpb3JpdHlRdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnByaW9yaXR5UXVldWV9IG9iamVjdC4KICogSW52b2tlZCB3aXRoIGBxdWV1ZS5yZW1vdmUodGVzdEZuKWAsIHdoZXJlIGB0ZXN0Rm5gIGlzIG9mIHRoZSBmb3JtCiAqIGBmdW5jdGlvbiAoe2RhdGEsIHByaW9yaXR5fSkge31gIGFuZCByZXR1cm5zIGEgQm9vbGVhbi4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc2F0dXJhdGVkIC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBudW1iZXIgb2YKICogcnVubmluZyB3b3JrZXJzIGhpdHMgdGhlIGBjb25jdXJyZW5jeWAgbGltaXQsIGFuZCBmdXJ0aGVyIHRhc2tzIHdpbGwgYmUKICogcXVldWVkLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSB1bnNhdHVyYXRlZCAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbnVtYmVyCiAqIG9mIHJ1bm5pbmcgd29ya2VycyBpcyBsZXNzIHRoYW4gdGhlIGBjb25jdXJyZW5jeWAgJiBgYnVmZmVyYCBsaW1pdHMsIGFuZAogKiBmdXJ0aGVyIHRhc2tzIHdpbGwgbm90IGJlIHF1ZXVlZC4KICogQHByb3BlcnR5IHtudW1iZXJ9IGJ1ZmZlciAtIEEgbWluaW11bSB0aHJlc2hvbGQgYnVmZmVyIGluIG9yZGVyIHRvIHNheSB0aGF0CiAqIHRoZSBgcXVldWVgIGlzIGB1bnNhdHVyYXRlZGAuCiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVtcHR5IC0gYSBjYWxsYmFjayB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBsYXN0IGl0ZW0KICogZnJvbSB0aGUgYHF1ZXVlYCBpcyBnaXZlbiB0byBhIGB3b3JrZXJgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkcmFpbiAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgbGFzdCBpdGVtCiAqIGZyb20gdGhlIGBxdWV1ZWAgaGFzIHJldHVybmVkIGZyb20gdGhlIGB3b3JrZXJgLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlcnJvciAtIGEgY2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiBhIHRhc2sgZXJyb3JzLgogKiBIYXMgdGhlIHNpZ25hdHVyZSBgZnVuY3Rpb24oZXJyb3IsIHRhc2spYC4KICogQHByb3BlcnR5IHtib29sZWFufSBwYXVzZWQgLSBhIGJvb2xlYW4gZm9yIGRldGVybWluaW5nIHdoZXRoZXIgdGhlIHF1ZXVlIGlzCiAqIGluIGEgcGF1c2VkIHN0YXRlLgogKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBwYXVzZSAtIGEgZnVuY3Rpb24gdGhhdCBwYXVzZXMgdGhlIHByb2Nlc3Npbmcgb2YgdGFza3MKICogdW50aWwgYHJlc3VtZSgpYCBpcyBjYWxsZWQuIEludm9rZSB3aXRoIGBxdWV1ZS5wYXVzZSgpYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0gcmVzdW1lIC0gYSBmdW5jdGlvbiB0aGF0IHJlc3VtZXMgdGhlIHByb2Nlc3Npbmcgb2YKICogcXVldWVkIHRhc2tzIHdoZW4gdGhlIHF1ZXVlIGlzIHBhdXNlZC4gSW52b2tlIHdpdGggYHF1ZXVlLnJlc3VtZSgpYC4KICogQHByb3BlcnR5IHtGdW5jdGlvbn0ga2lsbCAtIGEgZnVuY3Rpb24gdGhhdCByZW1vdmVzIHRoZSBgZHJhaW5gIGNhbGxiYWNrIGFuZAogKiBlbXB0aWVzIHJlbWFpbmluZyB0YXNrcyBmcm9tIHRoZSBxdWV1ZSBmb3JjaW5nIGl0IHRvIGdvIGlkbGUuIE5vIG1vcmUgdGFza3MKICogc2hvdWxkIGJlIHB1c2hlZCB0byB0aGUgcXVldWUgYWZ0ZXIgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLiBJbnZva2Ugd2l0aCBgcXVldWUua2lsbCgpYC4KICovCgovKioKICogQ3JlYXRlcyBhIGBxdWV1ZWAgb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBgY29uY3VycmVuY3lgLiBUYXNrcyBhZGRlZCB0byB0aGUKICogYHF1ZXVlYCBhcmUgcHJvY2Vzc2VkIGluIHBhcmFsbGVsICh1cCB0byB0aGUgYGNvbmN1cnJlbmN5YCBsaW1pdCkuIElmIGFsbAogKiBgd29ya2VyYHMgYXJlIGluIHByb2dyZXNzLCB0aGUgdGFzayBpcyBxdWV1ZWQgdW50aWwgb25lIGJlY29tZXMgYXZhaWxhYmxlLgogKiBPbmNlIGEgYHdvcmtlcmAgY29tcGxldGVzIGEgYHRhc2tgLCB0aGF0IGB0YXNrYCdzIGNhbGxiYWNrIGlzIGNhbGxlZC4KICoKICogQG5hbWUgcXVldWUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IHdvcmtlciAtIEFuIGFzeW5jIGZ1bmN0aW9uIGZvciBwcm9jZXNzaW5nIGEgcXVldWVkIHRhc2suCiAqIElmIHlvdSB3YW50IHRvIGhhbmRsZSBlcnJvcnMgZnJvbSBhbiBpbmRpdmlkdWFsIHRhc2ssIHBhc3MgYSBjYWxsYmFjayB0bwogKiBgcS5wdXNoKClgLiBJbnZva2VkIHdpdGggKHRhc2ssIGNhbGxiYWNrKS4KICogQHBhcmFtIHtudW1iZXJ9IFtjb25jdXJyZW5jeT0xXSAtIEFuIGBpbnRlZ2VyYCBmb3IgZGV0ZXJtaW5pbmcgaG93IG1hbnkKICogYHdvcmtlcmAgZnVuY3Rpb25zIHNob3VsZCBiZSBydW4gaW4gcGFyYWxsZWwuICBJZiBvbWl0dGVkLCB0aGUgY29uY3VycmVuY3kKICogZGVmYXVsdHMgdG8gYDFgLiAgSWYgdGhlIGNvbmN1cnJlbmN5IGlzIGAwYCwgYW4gZXJyb3IgaXMgdGhyb3duLgogKiBAcmV0dXJucyB7bW9kdWxlOkNvbnRyb2xGbG93LlF1ZXVlT2JqZWN0fSBBIHF1ZXVlIG9iamVjdCB0byBtYW5hZ2UgdGhlIHRhc2tzLiBDYWxsYmFja3MgY2FuCiAqIGF0dGFjaGVkIGFzIGNlcnRhaW4gcHJvcGVydGllcyB0byBsaXN0ZW4gZm9yIHNwZWNpZmljIGV2ZW50cyBkdXJpbmcgdGhlCiAqIGxpZmVjeWNsZSBvZiB0aGUgcXVldWUuCiAqIEBleGFtcGxlCiAqCiAqIC8vIGNyZWF0ZSBhIHF1ZXVlIG9iamVjdCB3aXRoIGNvbmN1cnJlbmN5IDIKICogdmFyIHEgPSBhc3luYy5xdWV1ZShmdW5jdGlvbih0YXNrLCBjYWxsYmFjaykgewogKiAgICAgY29uc29sZS5sb2coJ2hlbGxvICcgKyB0YXNrLm5hbWUpOwogKiAgICAgY2FsbGJhY2soKTsKICogfSwgMik7CiAqCiAqIC8vIGFzc2lnbiBhIGNhbGxiYWNrCiAqIHEuZHJhaW4gPSBmdW5jdGlvbigpIHsKICogICAgIGNvbnNvbGUubG9nKCdhbGwgaXRlbXMgaGF2ZSBiZWVuIHByb2Nlc3NlZCcpOwogKiB9OwogKgogKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgcXVldWUKICogcS5wdXNoKHtuYW1lOiAnZm9vJ30sIGZ1bmN0aW9uKGVycikgewogKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgZm9vJyk7CiAqIH0pOwogKiBxLnB1c2goe25hbWU6ICdiYXInfSwgZnVuY3Rpb24gKGVycikgewogKiAgICAgY29uc29sZS5sb2coJ2ZpbmlzaGVkIHByb2Nlc3NpbmcgYmFyJyk7CiAqIH0pOwogKgogKiAvLyBhZGQgc29tZSBpdGVtcyB0byB0aGUgcXVldWUgKGJhdGNoLXdpc2UpCiAqIHEucHVzaChbe25hbWU6ICdiYXonfSx7bmFtZTogJ2JheSd9LHtuYW1lOiAnYmF4J31dLCBmdW5jdGlvbihlcnIpIHsKICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGl0ZW0nKTsKICogfSk7CiAqCiAqIC8vIGFkZCBzb21lIGl0ZW1zIHRvIHRoZSBmcm9udCBvZiB0aGUgcXVldWUKICogcS51bnNoaWZ0KHtuYW1lOiAnYmFyJ30sIGZ1bmN0aW9uIChlcnIpIHsKICogICAgIGNvbnNvbGUubG9nKCdmaW5pc2hlZCBwcm9jZXNzaW5nIGJhcicpOwogKiB9KTsKICovCnZhciBxdWV1ZSQxID0gZnVuY3Rpb24gKHdvcmtlciwgY29uY3VycmVuY3kpIHsKICAgIHZhciBfd29ya2VyID0gd3JhcEFzeW5jKHdvcmtlcik7CiAgICByZXR1cm4gcXVldWUoZnVuY3Rpb24gKGl0ZW1zLCBjYikgewogICAgICAgIF93b3JrZXIoaXRlbXNbMF0sIGNiKTsKICAgIH0sIGNvbmN1cnJlbmN5LCAxKTsKfTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYXN5bmMucXVldWVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5xdWV1ZX0gb25seSB0YXNrcyBhcmUgYXNzaWduZWQgYSBwcmlvcml0eSBhbmQKICogY29tcGxldGVkIGluIGFzY2VuZGluZyBwcmlvcml0eSBvcmRlci4KICoKICogQG5hbWUgcHJpb3JpdHlRdWV1ZQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5xdWV1ZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnF1ZXVlfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gd29ya2VyIC0gQW4gYXN5bmMgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgYSBxdWV1ZWQgdGFzay4KICogSWYgeW91IHdhbnQgdG8gaGFuZGxlIGVycm9ycyBmcm9tIGFuIGluZGl2aWR1YWwgdGFzaywgcGFzcyBhIGNhbGxiYWNrIHRvCiAqIGBxLnB1c2goKWAuCiAqIEludm9rZWQgd2l0aCAodGFzaywgY2FsbGJhY2spLgogKiBAcGFyYW0ge251bWJlcn0gY29uY3VycmVuY3kgLSBBbiBgaW50ZWdlcmAgZm9yIGRldGVybWluaW5nIGhvdyBtYW55IGB3b3JrZXJgCiAqIGZ1bmN0aW9ucyBzaG91bGQgYmUgcnVuIGluIHBhcmFsbGVsLiAgSWYgb21pdHRlZCwgdGhlIGNvbmN1cnJlbmN5IGRlZmF1bHRzIHRvCiAqIGAxYC4gIElmIHRoZSBjb25jdXJyZW5jeSBpcyBgMGAsIGFuIGVycm9yIGlzIHRocm93bi4KICogQHJldHVybnMge21vZHVsZTpDb250cm9sRmxvdy5RdWV1ZU9iamVjdH0gQSBwcmlvcml0eVF1ZXVlIG9iamVjdCB0byBtYW5hZ2UgdGhlIHRhc2tzLiBUaGVyZSBhcmUgdHdvCiAqIGRpZmZlcmVuY2VzIGJldHdlZW4gYHF1ZXVlYCBhbmQgYHByaW9yaXR5UXVldWVgIG9iamVjdHM6CiAqICogYHB1c2godGFzaywgcHJpb3JpdHksIFtjYWxsYmFja10pYCAtIGBwcmlvcml0eWAgc2hvdWxkIGJlIGEgbnVtYmVyLiBJZiBhbgogKiAgIGFycmF5IG9mIGB0YXNrc2AgaXMgZ2l2ZW4sIGFsbCB0YXNrcyB3aWxsIGJlIGFzc2lnbmVkIHRoZSBzYW1lIHByaW9yaXR5LgogKiAqIFRoZSBgdW5zaGlmdGAgbWV0aG9kIHdhcyByZW1vdmVkLgogKi8KdmFyIHByaW9yaXR5UXVldWUgPSBmdW5jdGlvbih3b3JrZXIsIGNvbmN1cnJlbmN5KSB7CiAgICAvLyBTdGFydCB3aXRoIGEgbm9ybWFsIHF1ZXVlCiAgICB2YXIgcSA9IHF1ZXVlJDEod29ya2VyLCBjb25jdXJyZW5jeSk7CgogICAgLy8gT3ZlcnJpZGUgcHVzaCB0byBhY2NlcHQgc2Vjb25kIHBhcmFtZXRlciByZXByZXNlbnRpbmcgcHJpb3JpdHkKICAgIHEucHVzaCA9IGZ1bmN0aW9uKGRhdGEsIHByaW9yaXR5LCBjYWxsYmFjaykgewogICAgICAgIGlmIChjYWxsYmFjayA9PSBudWxsKSBjYWxsYmFjayA9IG5vb3A7CiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rhc2sgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CiAgICAgICAgfQogICAgICAgIHEuc3RhcnRlZCA9IHRydWU7CiAgICAgICAgaWYgKCFpc0FycmF5KGRhdGEpKSB7CiAgICAgICAgICAgIGRhdGEgPSBbZGF0YV07CiAgICAgICAgfQogICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAvLyBjYWxsIGRyYWluIGltbWVkaWF0ZWx5IGlmIHRoZXJlIGFyZSBubyB0YXNrcwogICAgICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlJDEoZnVuY3Rpb24oKSB7CiAgICAgICAgICAgICAgICBxLmRyYWluKCk7CiAgICAgICAgICAgIH0pOwogICAgICAgIH0KCiAgICAgICAgcHJpb3JpdHkgPSBwcmlvcml0eSB8fCAwOwogICAgICAgIHZhciBuZXh0Tm9kZSA9IHEuX3Rhc2tzLmhlYWQ7CiAgICAgICAgd2hpbGUgKG5leHROb2RlICYmIHByaW9yaXR5ID49IG5leHROb2RlLnByaW9yaXR5KSB7CiAgICAgICAgICAgIG5leHROb2RlID0gbmV4dE5vZGUubmV4dDsKICAgICAgICB9CgogICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICAgICAgdmFyIGl0ZW0gPSB7CiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhW2ldLAogICAgICAgICAgICAgICAgcHJpb3JpdHk6IHByaW9yaXR5LAogICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrCiAgICAgICAgICAgIH07CgogICAgICAgICAgICBpZiAobmV4dE5vZGUpIHsKICAgICAgICAgICAgICAgIHEuX3Rhc2tzLmluc2VydEJlZm9yZShuZXh0Tm9kZSwgaXRlbSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBxLl90YXNrcy5wdXNoKGl0ZW0pOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHNldEltbWVkaWF0ZSQxKHEucHJvY2Vzcyk7CiAgICB9OwoKICAgIC8vIFJlbW92ZSB1bnNoaWZ0IGZ1bmN0aW9uCiAgICBkZWxldGUgcS51bnNoaWZ0OwoKICAgIHJldHVybiBxOwp9OwoKLyoqCiAqIFJ1bnMgdGhlIGB0YXNrc2AgYXJyYXkgb2YgZnVuY3Rpb25zIGluIHBhcmFsbGVsLCB3aXRob3V0IHdhaXRpbmcgdW50aWwgdGhlCiAqIHByZXZpb3VzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQuIE9uY2UgYW55IG9mIHRoZSBgdGFza3NgIGNvbXBsZXRlIG9yIHBhc3MgYW4KICogZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZC4gSXQncwogKiBlcXVpdmFsZW50IHRvIGBQcm9taXNlLnJhY2UoKWAuCiAqCiAqIEBuYW1lIHJhY2UKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn0KICogdG8gcnVuLiBFYWNoIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFuIG9wdGlvbmFsIGByZXN1bHRgIHZhbHVlLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYW55IG9mIHRoZSBmdW5jdGlvbnMgaGF2ZQogKiBjb21wbGV0ZWQuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhbiBlcnJvciBvciByZXN1bHQgZnJvbSB0aGUgZmlyc3QgZnVuY3Rpb24gdGhhdAogKiBjb21wbGV0ZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKiBAcmV0dXJucyB1bmRlZmluZWQKICogQGV4YW1wbGUKICoKICogYXN5bmMucmFjZShbCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTsKICogICAgICAgICB9LCAyMDApOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpOwogKiAgICAgICAgIH0sIDEwMCk7CiAqICAgICB9CiAqIF0sCiAqIC8vIG1haW4gY2FsbGJhY2sKICogZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHRoZSByZXN1bHQgd2lsbCBiZSBlcXVhbCB0byAndHdvJyBhcyBpdCBmaW5pc2hlcyBlYXJsaWVyCiAqIH0pOwogKi8KZnVuY3Rpb24gcmFjZSh0YXNrcywgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIGlmICghaXNBcnJheSh0YXNrcykpIHJldHVybiBjYWxsYmFjayhuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCB0byByYWNlIG11c3QgYmUgYW4gYXJyYXkgb2YgZnVuY3Rpb25zJykpOwogICAgaWYgKCF0YXNrcy5sZW5ndGgpIHJldHVybiBjYWxsYmFjaygpOwogICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0YXNrcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgICAgICB3cmFwQXN5bmModGFza3NbaV0pKGNhbGxiYWNrKTsKICAgIH0KfQoKLyoqCiAqIFNhbWUgYXMgW2ByZWR1Y2VgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVkdWNlfSwgb25seSBvcGVyYXRlcyBvbiBgYXJyYXlgIGluIHJldmVyc2Ugb3JkZXIuCiAqCiAqIEBuYW1lIHJlZHVjZVJpZ2h0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnJlZHVjZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlZHVjZX0KICogQGFsaWFzIGZvbGRyCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHsqfSBtZW1vIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHJlZHVjdGlvbi4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlCiAqIGFycmF5IHRvIHByb2R1Y2UgdGhlIG5leHQgc3RlcCBpbiB0aGUgcmVkdWN0aW9uLgogKiBUaGUgYGl0ZXJhdGVlYCBzaG91bGQgY29tcGxldGUgd2l0aCB0aGUgbmV4dCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLgogKiBJZiB0aGUgaXRlcmF0ZWUgY29tcGxldGUgd2l0aCBhbiBlcnJvciwgdGhlIHJlZHVjdGlvbiBpcyBzdG9wcGVkIGFuZCB0aGUKICogbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci4KICogSW52b2tlZCB3aXRoIChtZW1vLCBpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIFJlc3VsdCBpcyB0aGUgcmVkdWNlZCB2YWx1ZS4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdCkuCiAqLwpmdW5jdGlvbiByZWR1Y2VSaWdodCAoYXJyYXksIG1lbW8sIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgdmFyIHJldmVyc2VkID0gc2xpY2UoYXJyYXkpLnJldmVyc2UoKTsKICAgIHJlZHVjZShyZXZlcnNlZCwgbWVtbywgaXRlcmF0ZWUsIGNhbGxiYWNrKTsKfQoKLyoqCiAqIFdyYXBzIHRoZSBhc3luYyBmdW5jdGlvbiBpbiBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgYWx3YXlzIGNvbXBsZXRlcyB3aXRoIGEKICogcmVzdWx0IG9iamVjdCwgZXZlbiB3aGVuIGl0IGVycm9ycy4KICoKICogVGhlIHJlc3VsdCBvYmplY3QgaGFzIGVpdGhlciB0aGUgcHJvcGVydHkgYGVycm9yYCBvciBgdmFsdWVgLgogKgogKiBAbmFtZSByZWZsZWN0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSBUaGUgYXN5bmMgZnVuY3Rpb24geW91IHdhbnQgdG8gd3JhcAogKiBAcmV0dXJucyB7RnVuY3Rpb259IC0gQSBmdW5jdGlvbiB0aGF0IGFsd2F5cyBwYXNzZXMgbnVsbCB0byBpdCdzIGNhbGxiYWNrIGFzCiAqIHRoZSBlcnJvci4gVGhlIHNlY29uZCBhcmd1bWVudCB0byB0aGUgY2FsbGJhY2sgd2lsbCBiZSBhbiBgb2JqZWN0YCB3aXRoCiAqIGVpdGhlciBhbiBgZXJyb3JgIG9yIGEgYHZhbHVlYCBwcm9wZXJ0eS4KICogQGV4YW1wbGUKICoKICogYXN5bmMucGFyYWxsZWwoWwogKiAgICAgYXN5bmMucmVmbGVjdChmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIC8vIGRvIHNvbWUgc3R1ZmYgLi4uCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpOwogKiAgICAgfSksCiAqICAgICBhc3luYy5yZWZsZWN0KGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gZG8gc29tZSBtb3JlIHN0dWZmIGJ1dCBlcnJvciAuLi4KICogICAgICAgICBjYWxsYmFjaygnYmFkIHN0dWZmIGhhcHBlbmVkJyk7CiAqICAgICB9KSwKICogICAgIGFzeW5jLnJlZmxlY3QoZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgLi4uCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpOwogKiAgICAgfSkKICogXSwKICogLy8gb3B0aW9uYWwgY2FsbGJhY2sKICogZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyB2YWx1ZXMKICogICAgIC8vIHJlc3VsdHNbMF0udmFsdWUgPSAnb25lJwogKiAgICAgLy8gcmVzdWx0c1sxXS5lcnJvciA9ICdiYWQgc3R1ZmYgaGFwcGVuZWQnCiAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bycKICogfSk7CiAqLwpmdW5jdGlvbiByZWZsZWN0KGZuKSB7CiAgICB2YXIgX2ZuID0gd3JhcEFzeW5jKGZuKTsKICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIHJlZmxlY3RPbihhcmdzLCByZWZsZWN0Q2FsbGJhY2spIHsKICAgICAgICBhcmdzLnB1c2goZnVuY3Rpb24gY2FsbGJhY2soZXJyb3IsIGNiQXJnKSB7CiAgICAgICAgICAgIGlmIChlcnJvcikgewogICAgICAgICAgICAgICAgcmVmbGVjdENhbGxiYWNrKG51bGwsIHsgZXJyb3I6IGVycm9yIH0pOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdmFyIHZhbHVlOwogICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMikgewogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY2JBcmc7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHZhbHVlID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHJlZmxlY3RDYWxsYmFjayhudWxsLCB7IHZhbHVlOiB2YWx1ZSB9KTsKICAgICAgICAgICAgfQogICAgICAgIH0pOwoKICAgICAgICByZXR1cm4gX2ZuLmFwcGx5KHRoaXMsIGFyZ3MpOwogICAgfSk7Cn0KCi8qKgogKiBBIGhlbHBlciBmdW5jdGlvbiB0aGF0IHdyYXBzIGFuIGFycmF5IG9yIGFuIG9iamVjdCBvZiBmdW5jdGlvbnMgd2l0aCBgcmVmbGVjdGAuCiAqCiAqIEBuYW1lIHJlZmxlY3RBbGwKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucmVmbGVjdF17QGxpbmsgbW9kdWxlOlV0aWxzLnJlZmxlY3R9CiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fEl0ZXJhYmxlfSB0YXNrcyAtIFRoZSBjb2xsZWN0aW9uIG9mCiAqIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHdyYXAgaW4gYGFzeW5jLnJlZmxlY3RgLgogKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2YgYXN5bmMgZnVuY3Rpb25zLCBlYWNoIHdyYXBwZWQgaW4KICogYGFzeW5jLnJlZmxlY3RgCiAqIEBleGFtcGxlCiAqCiAqIGxldCB0YXNrcyA9IFsKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScpOwogKiAgICAgICAgIH0sIDIwMCk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgYnV0IGVycm9yIC4uLgogKiAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignYmFkIHN0dWZmIGhhcHBlbmVkJykpOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpOwogKiAgICAgICAgIH0sIDEwMCk7CiAqICAgICB9CiAqIF07CiAqCiAqIGFzeW5jLnBhcmFsbGVsKGFzeW5jLnJlZmxlY3RBbGwodGFza3MpLAogKiAvLyBvcHRpb25hbCBjYWxsYmFjawogKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHZhbHVlcwogKiAgICAgLy8gcmVzdWx0c1swXS52YWx1ZSA9ICdvbmUnCiAqICAgICAvLyByZXN1bHRzWzFdLmVycm9yID0gRXJyb3IoJ2JhZCBzdHVmZiBoYXBwZW5lZCcpCiAqICAgICAvLyByZXN1bHRzWzJdLnZhbHVlID0gJ3R3bycKICogfSk7CiAqCiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXkKICogbGV0IHRhc2tzID0gewogKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTsKICogICAgICAgICB9LCAyMDApOwogKiAgICAgfSwKICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICBjYWxsYmFjaygndHdvJyk7CiAqICAgICB9LAogKiAgICAgdGhyZWU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3RocmVlJyk7CiAqICAgICAgICAgfSwgMTAwKTsKICogICAgIH0KICogfTsKICoKICogYXN5bmMucGFyYWxsZWwoYXN5bmMucmVmbGVjdEFsbCh0YXNrcyksCiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrCiAqIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gdmFsdWVzCiAqICAgICAvLyByZXN1bHRzLm9uZS52YWx1ZSA9ICdvbmUnCiAqICAgICAvLyByZXN1bHRzLnR3by5lcnJvciA9ICd0d28nCiAqICAgICAvLyByZXN1bHRzLnRocmVlLnZhbHVlID0gJ3RocmVlJwogKiB9KTsKICovCmZ1bmN0aW9uIHJlZmxlY3RBbGwodGFza3MpIHsKICAgIHZhciByZXN1bHRzOwogICAgaWYgKGlzQXJyYXkodGFza3MpKSB7CiAgICAgICAgcmVzdWx0cyA9IGFycmF5TWFwKHRhc2tzLCByZWZsZWN0KTsKICAgIH0gZWxzZSB7CiAgICAgICAgcmVzdWx0cyA9IHt9OwogICAgICAgIGJhc2VGb3JPd24odGFza3MsIGZ1bmN0aW9uKHRhc2ssIGtleSkgewogICAgICAgICAgICByZXN1bHRzW2tleV0gPSByZWZsZWN0LmNhbGwodGhpcywgdGFzayk7CiAgICAgICAgfSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0czsKfQoKZnVuY3Rpb24gcmVqZWN0JDEoZWFjaGZuLCBhcnIsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgX2ZpbHRlcihlYWNoZm4sIGFyciwgZnVuY3Rpb24odmFsdWUsIGNiKSB7CiAgICAgICAgaXRlcmF0ZWUodmFsdWUsIGZ1bmN0aW9uKGVyciwgdikgewogICAgICAgICAgICBjYihlcnIsICF2KTsKICAgICAgICB9KTsKICAgIH0sIGNhbGxiYWNrKTsKfQoKLyoqCiAqIFRoZSBvcHBvc2l0ZSBvZiBbYGZpbHRlcmBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5maWx0ZXJ9LiBSZW1vdmVzIHZhbHVlcyB0aGF0IHBhc3MgYW4gYGFzeW5jYCB0cnV0aCB0ZXN0LgogKgogKiBAbmFtZSByZWplY3QKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuZmlsdGVyXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZmlsdGVyfQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyBgcmVzdWx0YC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICogQGV4YW1wbGUKICoKICogYXN5bmMucmVqZWN0KFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGVQYXRoLCBjYWxsYmFjaykgewogKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykgewogKiAgICAgLy8gcmVzdWx0cyBub3cgZXF1YWxzIGFuIGFycmF5IG9mIG1pc3NpbmcgZmlsZXMKICogICAgIGNyZWF0ZUZpbGVzKHJlc3VsdHMpOwogKiB9KTsKICovCnZhciByZWplY3QgPSBkb1BhcmFsbGVsKHJlamVjdCQxKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYHJlamVjdGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYQogKiB0aW1lLgogKgogKiBAbmFtZSByZWplY3RMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5yZWplY3Rde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5yZWplY3R9CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIHRydXRoIHRlc3QgdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluCiAqIGBjb2xsYC4KICogVGhlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiB2YWx1ZSBhcyBpdHMgYHJlc3VsdGAuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqLwp2YXIgcmVqZWN0TGltaXQgPSBkb1BhcmFsbGVsTGltaXQocmVqZWN0JDEpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgcmVqZWN0YF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnJlamVjdH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSByZWplY3RTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucmVqZWN0XXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMucmVqZWN0fQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIHZhbHVlIGFzIGl0cyBgcmVzdWx0YC4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS4KICovCnZhciByZWplY3RTZXJpZXMgPSBkb0xpbWl0KHJlamVjdExpbWl0LCAxKTsKCi8qKgogKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuCiAqCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIF8KICogQHNpbmNlIDIuNC4wCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLgogKiBAZXhhbXBsZQogKgogKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7CiAqCiAqIGNvbnNvbGUubG9nKG9iamVjdHMpOwogKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV0KICoKICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7CiAqIC8vID0+IHRydWUKICovCmZ1bmN0aW9uIGNvbnN0YW50JDEodmFsdWUpIHsKICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICByZXR1cm4gdmFsdWU7CiAgfTsKfQoKLyoqCiAqIEF0dGVtcHRzIHRvIGdldCBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZnJvbSBgdGFza2Agbm8gbW9yZSB0aGFuIGB0aW1lc2AgdGltZXMKICogYmVmb3JlIHJldHVybmluZyBhbiBlcnJvci4gSWYgdGhlIHRhc2sgaXMgc3VjY2Vzc2Z1bCwgdGhlIGBjYWxsYmFja2Agd2lsbCBiZQogKiBwYXNzZWQgdGhlIHJlc3VsdCBvZiB0aGUgc3VjY2Vzc2Z1bCB0YXNrLiBJZiBhbGwgYXR0ZW1wdHMgZmFpbCwgdGhlIGNhbGxiYWNrCiAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LgogKgogKiBAbmFtZSByZXRyeQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBzZWUgW2FzeW5jLnJldHJ5YWJsZV17QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnJldHJ5YWJsZX0KICogQHBhcmFtIHtPYmplY3R8bnVtYmVyfSBbb3B0cyA9IHt0aW1lczogNSwgaW50ZXJ2YWw6IDB9fCA1XSAtIENhbiBiZSBlaXRoZXIgYW4KICogb2JqZWN0IHdpdGggYHRpbWVzYCBhbmQgYGludGVydmFsYCBvciBhIG51bWJlci4KICogKiBgdGltZXNgIC0gVGhlIG51bWJlciBvZiBhdHRlbXB0cyB0byBtYWtlIGJlZm9yZSBnaXZpbmcgdXAuICBUaGUgZGVmYXVsdAogKiAgIGlzIGA1YC4KICogKiBgaW50ZXJ2YWxgIC0gVGhlIHRpbWUgdG8gd2FpdCBiZXR3ZWVuIHJldHJpZXMsIGluIG1pbGxpc2Vjb25kcy4gIFRoZQogKiAgIGRlZmF1bHQgaXMgYDBgLiBUaGUgaW50ZXJ2YWwgbWF5IGFsc28gYmUgc3BlY2lmaWVkIGFzIGEgZnVuY3Rpb24gb2YgdGhlCiAqICAgcmV0cnkgY291bnQgKHNlZSBleGFtcGxlKS4KICogKiBgZXJyb3JGaWx0ZXJgIC0gQW4gb3B0aW9uYWwgc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIG9uCiAqICAgZXJyb25lb3VzIHJlc3VsdC4gSWYgaXQgcmV0dXJucyBgdHJ1ZWAgdGhlIHJldHJ5IGF0dGVtcHRzIHdpbGwgY29udGludWU7CiAqICAgaWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYGZhbHNlYCB0aGUgcmV0cnkgZmxvdyBpcyBhYm9ydGVkIHdpdGggdGhlIGN1cnJlbnQKICogICBhdHRlbXB0J3MgZXJyb3IgYW5kIHJlc3VsdCBiZWluZyByZXR1cm5lZCB0byB0aGUgZmluYWwgY2FsbGJhY2suCiAqICAgSW52b2tlZCB3aXRoIChlcnIpLgogKiAqIElmIGBvcHRzYCBpcyBhIG51bWJlciwgdGhlIG51bWJlciBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0aW1lcyB0byByZXRyeSwKICogICB3aXRoIHRoZSBkZWZhdWx0IGludGVydmFsIG9mIGAwYC4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0YXNrIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gcmV0cnkuCiAqIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlCiAqIHRhc2sgaGFzIHN1Y2NlZWRlZCwgb3IgYWZ0ZXIgdGhlIGZpbmFsIGZhaWxlZCBhdHRlbXB0LiBJdCByZWNlaXZlcyB0aGUgYGVycmAKICogYW5kIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZAogKiB3aXRoIChlcnIsIHJlc3VsdHMpLgogKgogKiBAZXhhbXBsZQogKgogKiAvLyBUaGUgYHJldHJ5YCBmdW5jdGlvbiBjYW4gYmUgdXNlZCBhcyBhIHN0YW5kLWFsb25lIGNvbnRyb2wgZmxvdyBieSBwYXNzaW5nCiAqIC8vIGEgY2FsbGJhY2ssIGFzIHNob3duIGJlbG93OgogKgogKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMyB0aW1lcwogKiBhc3luYy5yZXRyeSgzLCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0CiAqIH0pOwogKgogKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMyB0aW1lcywgd2FpdGluZyAyMDAgbXMgYmV0d2VlbiBlYWNoIHJldHJ5CiAqIGFzeW5jLnJldHJ5KHt0aW1lczogMywgaW50ZXJ2YWw6IDIwMH0sIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHQKICogfSk7CiAqCiAqIC8vIHRyeSBjYWxsaW5nIGFwaU1ldGhvZCAxMCB0aW1lcyB3aXRoIGV4cG9uZW50aWFsIGJhY2tvZmYKICogLy8gKGkuZS4gaW50ZXJ2YWxzIG9mIDEwMCwgMjAwLCA0MDAsIDgwMCwgMTYwMCwgLi4uIG1pbGxpc2Vjb25kcykKICogYXN5bmMucmV0cnkoewogKiAgIHRpbWVzOiAxMCwKICogICBpbnRlcnZhbDogZnVuY3Rpb24ocmV0cnlDb3VudCkgewogKiAgICAgcmV0dXJuIDUwICogTWF0aC5wb3coMiwgcmV0cnlDb3VudCk7CiAqICAgfQogKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0CiAqIH0pOwogKgogKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgdGhlIGRlZmF1bHQgNSB0aW1lcyBubyBkZWxheSBiZXR3ZWVuIGVhY2ggcmV0cnkKICogYXN5bmMucmV0cnkoYXBpTWV0aG9kLCBmdW5jdGlvbihlcnIsIHJlc3VsdCkgewogKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdAogKiB9KTsKICoKICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIG9ubHkgd2hlbiBlcnJvciBjb25kaXRpb24gc2F0aXNmaWVzLCBhbGwgb3RoZXIKICogLy8gZXJyb3JzIHdpbGwgYWJvcnQgdGhlIHJldHJ5IGNvbnRyb2wgZmxvdyBhbmQgcmV0dXJuIHRvIGZpbmFsIGNhbGxiYWNrCiAqIGFzeW5jLnJldHJ5KHsKICogICBlcnJvckZpbHRlcjogZnVuY3Rpb24oZXJyKSB7CiAqICAgICByZXR1cm4gZXJyLm1lc3NhZ2UgPT09ICdUZW1wb3JhcnkgZXJyb3InOyAvLyBvbmx5IHJldHJ5IG9uIGEgc3BlY2lmaWMgZXJyb3IKICogICB9CiAqIH0sIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIGRvIHNvbWV0aGluZyB3aXRoIHRoZSByZXN1bHQKICogfSk7CiAqCiAqIC8vIHRvIHJldHJ5IGluZGl2aWR1YWwgbWV0aG9kcyB0aGF0IGFyZSBub3QgYXMgcmVsaWFibGUgd2l0aGluIG90aGVyCiAqIC8vIGNvbnRyb2wgZmxvdyBmdW5jdGlvbnMsIHVzZSB0aGUgYHJldHJ5YWJsZWAgd3JhcHBlcjoKICogYXN5bmMuYXV0byh7CiAqICAgICB1c2VyczogYXBpLmdldFVzZXJzLmJpbmQoYXBpKSwKICogICAgIHBheW1lbnRzOiBhc3luYy5yZXRyeWFibGUoMywgYXBpLmdldFBheW1lbnRzLmJpbmQoYXBpKSkKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0cwogKiB9KTsKICoKICovCmZ1bmN0aW9uIHJldHJ5KG9wdHMsIHRhc2ssIGNhbGxiYWNrKSB7CiAgICB2YXIgREVGQVVMVF9USU1FUyA9IDU7CiAgICB2YXIgREVGQVVMVF9JTlRFUlZBTCA9IDA7CgogICAgdmFyIG9wdGlvbnMgPSB7CiAgICAgICAgdGltZXM6IERFRkFVTFRfVElNRVMsCiAgICAgICAgaW50ZXJ2YWxGdW5jOiBjb25zdGFudCQxKERFRkFVTFRfSU5URVJWQUwpCiAgICB9OwoKICAgIGZ1bmN0aW9uIHBhcnNlVGltZXMoYWNjLCB0KSB7CiAgICAgICAgaWYgKHR5cGVvZiB0ID09PSAnb2JqZWN0JykgewogICAgICAgICAgICBhY2MudGltZXMgPSArdC50aW1lcyB8fCBERUZBVUxUX1RJTUVTOwoKICAgICAgICAgICAgYWNjLmludGVydmFsRnVuYyA9IHR5cGVvZiB0LmludGVydmFsID09PSAnZnVuY3Rpb24nID8KICAgICAgICAgICAgICAgIHQuaW50ZXJ2YWwgOgogICAgICAgICAgICAgICAgY29uc3RhbnQkMSgrdC5pbnRlcnZhbCB8fCBERUZBVUxUX0lOVEVSVkFMKTsKCiAgICAgICAgICAgIGFjYy5lcnJvckZpbHRlciA9IHQuZXJyb3JGaWx0ZXI7CiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHQgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgIGFjYy50aW1lcyA9ICt0IHx8IERFRkFVTFRfVElNRVM7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFyZ3VtZW50cyBmb3IgYXN5bmMucmV0cnkiKTsKICAgICAgICB9CiAgICB9CgogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgY2FsbGJhY2sgPSB0YXNrIHx8IG5vb3A7CiAgICAgICAgdGFzayA9IG9wdHM7CiAgICB9IGVsc2UgewogICAgICAgIHBhcnNlVGltZXMob3B0aW9ucywgb3B0cyk7CiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wOwogICAgfQoKICAgIGlmICh0eXBlb2YgdGFzayAhPT0gJ2Z1bmN0aW9uJykgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5Iik7CiAgICB9CgogICAgdmFyIF90YXNrID0gd3JhcEFzeW5jKHRhc2spOwoKICAgIHZhciBhdHRlbXB0ID0gMTsKICAgIGZ1bmN0aW9uIHJldHJ5QXR0ZW1wdCgpIHsKICAgICAgICBfdGFzayhmdW5jdGlvbihlcnIpIHsKICAgICAgICAgICAgaWYgKGVyciAmJiBhdHRlbXB0KysgPCBvcHRpb25zLnRpbWVzICYmCiAgICAgICAgICAgICAgICAodHlwZW9mIG9wdGlvbnMuZXJyb3JGaWx0ZXIgIT0gJ2Z1bmN0aW9uJyB8fAogICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JGaWx0ZXIoZXJyKSkpIHsKICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmV0cnlBdHRlbXB0LCBvcHRpb25zLmludGVydmFsRnVuYyhhdHRlbXB0KSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICB9CgogICAgcmV0cnlBdHRlbXB0KCk7Cn0KCi8qKgogKiBBIGNsb3NlIHJlbGF0aXZlIG9mIFtgcmV0cnlgXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cucmV0cnl9LiAgVGhpcyBtZXRob2QKICogd3JhcHMgYSB0YXNrIGFuZCBtYWtlcyBpdCByZXRyeWFibGUsIHJhdGhlciB0aGFuIGltbWVkaWF0ZWx5IGNhbGxpbmcgaXQKICogd2l0aCByZXRyaWVzLgogKgogKiBAbmFtZSByZXRyeWFibGUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMucmV0cnlde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeX0KICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRzID0ge3RpbWVzOiA1LCBpbnRlcnZhbDogMH18IDVdIC0gb3B0aW9uYWwKICogb3B0aW9ucywgZXhhY3RseSB0aGUgc2FtZSBhcyBmcm9tIGByZXRyeWAKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSB0YXNrIC0gdGhlIGFzeW5jaHJvbm91cyBmdW5jdGlvbiB0byB3cmFwLgogKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSByZXR1cm5lZCB3cmFwcGVyLgogKiBJbnZva2VkIHdpdGggKC4uLmFyZ3MsIGNhbGxiYWNrKS4KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IFRoZSB3cmFwcGVkIGZ1bmN0aW9uLCB3aGljaCB3aGVuIGludm9rZWQsIHdpbGwKICogcmV0cnkgb24gYW4gZXJyb3IsIGJhc2VkIG9uIHRoZSBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiBgb3B0c2AuCiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBhY2NlcHQgdGhlIHNhbWUgcGFyYW1ldGVycyBhcyBgdGFza2AuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLmF1dG8oewogKiAgICAgZGVwMTogYXN5bmMucmV0cnlhYmxlKDMsIGdldEZyb21GbGFreVNlcnZpY2UpLAogKiAgICAgcHJvY2VzczogWyJkZXAxIiwgYXN5bmMucmV0cnlhYmxlKDMsIGZ1bmN0aW9uIChyZXN1bHRzLCBjYikgewogKiAgICAgICAgIG1heWJlUHJvY2Vzc0RhdGEocmVzdWx0cy5kZXAxLCBjYik7CiAqICAgICB9KV0KICogfSwgY2FsbGJhY2spOwogKi8KdmFyIHJldHJ5YWJsZSA9IGZ1bmN0aW9uIChvcHRzLCB0YXNrKSB7CiAgICBpZiAoIXRhc2spIHsKICAgICAgICB0YXNrID0gb3B0czsKICAgICAgICBvcHRzID0gbnVsbDsKICAgIH0KICAgIHZhciBfdGFzayA9IHdyYXBBc3luYyh0YXNrKTsKICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykgewogICAgICAgIGZ1bmN0aW9uIHRhc2tGbihjYikgewogICAgICAgICAgICBfdGFzay5hcHBseShudWxsLCBhcmdzLmNvbmNhdChjYikpOwogICAgICAgIH0KCiAgICAgICAgaWYgKG9wdHMpIHJldHJ5KG9wdHMsIHRhc2tGbiwgY2FsbGJhY2spOwogICAgICAgIGVsc2UgcmV0cnkodGFza0ZuLCBjYWxsYmFjayk7CgogICAgfSk7Cn07CgovKioKICogUnVuIHRoZSBmdW5jdGlvbnMgaW4gdGhlIGB0YXNrc2AgY29sbGVjdGlvbiBpbiBzZXJpZXMsIGVhY2ggb25lIHJ1bm5pbmcgb25jZQogKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IGZ1bmN0aW9ucyBpbiB0aGUgc2VyaWVzIHBhc3MgYW4KICogZXJyb3IgdG8gaXRzIGNhbGxiYWNrLCBubyBtb3JlIGZ1bmN0aW9ucyBhcmUgcnVuLCBhbmQgYGNhbGxiYWNrYCBpcwogKiBpbW1lZGlhdGVseSBjYWxsZWQgd2l0aCB0aGUgdmFsdWUgb2YgdGhlIGVycm9yLiBPdGhlcndpc2UsIGBjYWxsYmFja2AKICogcmVjZWl2ZXMgYW4gYXJyYXkgb2YgcmVzdWx0cyB3aGVuIGB0YXNrc2AgaGF2ZSBjb21wbGV0ZWQuCiAqCiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gdXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBFYWNoIHByb3BlcnR5IHdpbGwKICogYmUgcnVuIGFzIGEgZnVuY3Rpb24sIGFuZCB0aGUgcmVzdWx0cyB3aWxsIGJlIHBhc3NlZCB0byB0aGUgZmluYWwgYGNhbGxiYWNrYAogKiBhcyBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gVGhpcyBjYW4gYmUgYSBtb3JlIHJlYWRhYmxlIHdheSBvZiBoYW5kbGluZwogKiAgcmVzdWx0cyBmcm9tIHtAbGluayBhc3luYy5zZXJpZXN9LgogKgogKiAqKk5vdGUqKiB0aGF0IHdoaWxlIG1hbnkgaW1wbGVtZW50YXRpb25zIHByZXNlcnZlIHRoZSBvcmRlciBvZiBvYmplY3QKICogcHJvcGVydGllcywgdGhlIFtFQ01BU2NyaXB0IExhbmd1YWdlIFNwZWNpZmljYXRpb25dKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi81LjEvI3NlYy04LjYpCiAqIGV4cGxpY2l0bHkgc3RhdGVzIHRoYXQKICoKICogPiBUaGUgbWVjaGFuaWNzIGFuZCBvcmRlciBvZiBlbnVtZXJhdGluZyB0aGUgcHJvcGVydGllcyBpcyBub3Qgc3BlY2lmaWVkLgogKgogKiBTbyBpZiB5b3UgcmVseSBvbiB0aGUgb3JkZXIgaW4gd2hpY2ggeW91ciBzZXJpZXMgb2YgZnVuY3Rpb25zIGFyZSBleGVjdXRlZCwKICogYW5kIHdhbnQgdGhpcyB0byB3b3JrIG9uIGFsbCBwbGF0Zm9ybXMsIGNvbnNpZGVyIHVzaW5nIGFuIGFycmF5LgogKgogKiBAbmFtZSBzZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZwogKiBbYXN5bmMgZnVuY3Rpb25zXXtAbGluayBBc3luY0Z1bmN0aW9ufSB0byBydW4gaW4gc2VyaWVzLgogKiBFYWNoIGZ1bmN0aW9uIGNhbiBjb21wbGV0ZSB3aXRoIGFueSBudW1iZXIgb2Ygb3B0aW9uYWwgYHJlc3VsdGAgdmFsdWVzLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZQogKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQuIFRoaXMgZnVuY3Rpb24gZ2V0cyBhIHJlc3VsdHMgYXJyYXkgKG9yIG9iamVjdCkKICogY29udGFpbmluZyBhbGwgdGhlIHJlc3VsdCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBgdGFza2AgY2FsbGJhY2tzLiBJbnZva2VkCiAqIHdpdGggKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICogYXN5bmMuc2VyaWVzKFsKICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gZG8gc29tZSBzdHVmZiAuLi4KICogICAgICAgICBjYWxsYmFjayhudWxsLCAnb25lJyk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHsKICogICAgICAgICAvLyBkbyBzb21lIG1vcmUgc3R1ZmYgLi4uCiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ3R3bycpOwogKiAgICAgfQogKiBdLAogKiAvLyBvcHRpb25hbCBjYWxsYmFjawogKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFsIHRvIFsnb25lJywgJ3R3byddCiAqIH0pOwogKgogKiBhc3luYy5zZXJpZXMoewogKiAgICAgb25lOiBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7CiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDEpOwogKiAgICAgICAgIH0sIDIwMCk7CiAqICAgICB9LAogKiAgICAgdHdvOiBmdW5jdGlvbihjYWxsYmFjayl7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgMik7CiAqICAgICAgICAgfSwgMTAwKTsKICogICAgIH0KICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyBlcXVhbCB0bzoge29uZTogMSwgdHdvOiAyfQogKiB9KTsKICovCmZ1bmN0aW9uIHNlcmllcyh0YXNrcywgY2FsbGJhY2spIHsKICAgIF9wYXJhbGxlbChlYWNoT2ZTZXJpZXMsIHRhc2tzLCBjYWxsYmFjayk7Cn0KCi8qKgogKiBSZXR1cm5zIGB0cnVlYCBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgYGNvbGxgIHNhdGlzZmllcyBhbiBhc3luYyB0ZXN0LgogKiBJZiBhbnkgaXRlcmF0ZWUgY2FsbCByZXR1cm5zIGB0cnVlYCwgdGhlIG1haW4gYGNhbGxiYWNrYCBpcyBpbW1lZGlhdGVseQogKiBjYWxsZWQuCiAqCiAqIEBuYW1lIHNvbWUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQGFsaWFzIGFueQogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyB0cnV0aCB0ZXN0IHRvIGFwcGx5IHRvIGVhY2ggaXRlbQogKiBpbiB0aGUgY29sbGVjdGlvbnMgaW4gcGFyYWxsZWwuCiAqIFRoZSBpdGVyYXRlZSBzaG91bGQgY29tcGxldGUgd2l0aCBhIGJvb2xlYW4gYHJlc3VsdGAgdmFsdWUuCiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYXMgc29vbiBhcyBhbnkKICogaXRlcmF0ZWUgcmV0dXJucyBgdHJ1ZWAsIG9yIGFmdGVyIGFsbCB0aGUgaXRlcmF0ZWUgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQuCiAqIFJlc3VsdCB3aWxsIGJlIGVpdGhlciBgdHJ1ZWAgb3IgYGZhbHNlYCBkZXBlbmRpbmcgb24gdGhlIHZhbHVlcyBvZiB0aGUgYXN5bmMKICogdGVzdHMuIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHQpLgogKiBAZXhhbXBsZQogKgogKiBhc3luYy5zb21lKFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZ1bmN0aW9uKGZpbGVQYXRoLCBjYWxsYmFjaykgewogKiAgICAgZnMuYWNjZXNzKGZpbGVQYXRoLCBmdW5jdGlvbihlcnIpIHsKICogICAgICAgICBjYWxsYmFjayhudWxsLCAhZXJyKQogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7CiAqICAgICAvLyBpZiByZXN1bHQgaXMgdHJ1ZSB0aGVuIGF0IGxlYXN0IG9uZSBvZiB0aGUgZmlsZXMgZXhpc3RzCiAqIH0pOwogKi8KdmFyIHNvbWUgPSBkb1BhcmFsbGVsKF9jcmVhdGVUZXN0ZXIoQm9vbGVhbiwgaWRlbnRpdHkpKTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbYHNvbWVgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIHNvbWVMaW1pdAogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy5zb21lXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuc29tZX0KICogQGFsaWFzIGFueUxpbWl0CiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0KICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHBhcmFsbGVsLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSBib29sZWFuIGByZXN1bHRgIHZhbHVlLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFzIHNvb24gYXMgYW55CiAqIGl0ZXJhdGVlIHJldHVybnMgYHRydWVgLCBvciBhZnRlciBhbGwgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLgogKiBSZXN1bHQgd2lsbCBiZSBlaXRoZXIgYHRydWVgIG9yIGBmYWxzZWAgZGVwZW5kaW5nIG9uIHRoZSB2YWx1ZXMgb2YgdGhlIGFzeW5jCiAqIHRlc3RzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICovCnZhciBzb21lTGltaXQgPSBkb1BhcmFsbGVsTGltaXQoX2NyZWF0ZVRlc3RlcihCb29sZWFuLCBpZGVudGl0eSkpOwoKLyoqCiAqIFRoZSBzYW1lIGFzIFtgc29tZWBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5zb21lfSBidXQgcnVucyBvbmx5IGEgc2luZ2xlIGFzeW5jIG9wZXJhdGlvbiBhdCBhIHRpbWUuCiAqCiAqIEBuYW1lIHNvbWVTZXJpZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMuc29tZV17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLnNvbWV9CiAqIEBhbGlhcyBhbnlTZXJpZXMKICogQGNhdGVnb3J5IENvbGxlY3Rpb24KICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgdHJ1dGggdGVzdCB0byBhcHBseSB0byBlYWNoIGl0ZW0KICogaW4gdGhlIGNvbGxlY3Rpb25zIGluIHNlcmllcy4KICogVGhlIGl0ZXJhdGVlIHNob3VsZCBjb21wbGV0ZSB3aXRoIGEgYm9vbGVhbiBgcmVzdWx0YCB2YWx1ZS4KICogSW52b2tlZCB3aXRoIChpdGVtLCBjYWxsYmFjaykuCiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhcyBzb29uIGFzIGFueQogKiBpdGVyYXRlZSByZXR1cm5zIGB0cnVlYCwgb3IgYWZ0ZXIgYWxsIHRoZSBpdGVyYXRlZSBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZC4KICogUmVzdWx0IHdpbGwgYmUgZWl0aGVyIGB0cnVlYCBvciBgZmFsc2VgIGRlcGVuZGluZyBvbiB0aGUgdmFsdWVzIG9mIHRoZSBhc3luYwogKiB0ZXN0cy4gSW52b2tlZCB3aXRoIChlcnIsIHJlc3VsdCkuCiAqLwp2YXIgc29tZVNlcmllcyA9IGRvTGltaXQoc29tZUxpbWl0LCAxKTsKCi8qKgogKiBTb3J0cyBhIGxpc3QgYnkgdGhlIHJlc3VsdHMgb2YgcnVubmluZyBlYWNoIGBjb2xsYCB2YWx1ZSB0aHJvdWdoIGFuIGFzeW5jCiAqIGBpdGVyYXRlZWAuCiAqCiAqIEBuYW1lIHNvcnRCeQogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnMKICogQG1ldGhvZAogKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbgogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW4KICogYGNvbGxgLgogKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggYSB2YWx1ZSB0byB1c2UgYXMgdGhlIHNvcnQgY3JpdGVyaWEgYXMKICogaXRzIGByZXN1bHRgLgogKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBhZnRlciBhbGwgdGhlCiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gUmVzdWx0cyBpcyB0aGUgaXRlbXMKICogZnJvbSB0aGUgb3JpZ2luYWwgYGNvbGxgIHNvcnRlZCBieSB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBgaXRlcmF0ZWVgCiAqIGNhbGxzLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLnNvcnRCeShbJ2ZpbGUxJywnZmlsZTInLCdmaWxlMyddLCBmdW5jdGlvbihmaWxlLCBjYWxsYmFjaykgewogKiAgICAgZnMuc3RhdChmaWxlLCBmdW5jdGlvbihlcnIsIHN0YXRzKSB7CiAqICAgICAgICAgY2FsbGJhY2soZXJyLCBzdGF0cy5tdGltZSk7CiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7CiAqICAgICAvLyByZXN1bHRzIGlzIG5vdyB0aGUgb3JpZ2luYWwgYXJyYXkgb2YgZmlsZXMgc29ydGVkIGJ5CiAqICAgICAvLyBtb2RpZmllZCBkYXRlCiAqIH0pOwogKgogKiAvLyBCeSBtb2RpZnlpbmcgdGhlIGNhbGxiYWNrIHBhcmFtZXRlciB0aGUKICogLy8gc29ydGluZyBvcmRlciBjYW4gYmUgaW5mbHVlbmNlZDoKICoKICogLy8gYXNjZW5kaW5nIG9yZGVyCiAqIGFzeW5jLnNvcnRCeShbMSw5LDMsNV0sIGZ1bmN0aW9uKHgsIGNhbGxiYWNrKSB7CiAqICAgICBjYWxsYmFjayhudWxsLCB4KTsKICogfSwgZnVuY3Rpb24oZXJyLHJlc3VsdCkgewogKiAgICAgLy8gcmVzdWx0IGNhbGxiYWNrCiAqIH0pOwogKgogKiAvLyBkZXNjZW5kaW5nIG9yZGVyCiAqIGFzeW5jLnNvcnRCeShbMSw5LDMsNV0sIGZ1bmN0aW9uKHgsIGNhbGxiYWNrKSB7CiAqICAgICBjYWxsYmFjayhudWxsLCB4Ki0xKTsgICAgLy88LSB4Ki0xIGluc3RlYWQgb2YgeCwgdHVybnMgdGhlIG9yZGVyIGFyb3VuZAogKiB9LCBmdW5jdGlvbihlcnIscmVzdWx0KSB7CiAqICAgICAvLyByZXN1bHQgY2FsbGJhY2sKICogfSk7CiAqLwpmdW5jdGlvbiBzb3J0QnkgKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICBtYXAoY29sbCwgZnVuY3Rpb24gKHgsIGNhbGxiYWNrKSB7CiAgICAgICAgX2l0ZXJhdGVlKHgsIGZ1bmN0aW9uIChlcnIsIGNyaXRlcmlhKSB7CiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7dmFsdWU6IHgsIGNyaXRlcmlhOiBjcml0ZXJpYX0pOwogICAgICAgIH0pOwogICAgfSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykgewogICAgICAgIGlmIChlcnIpIHJldHVybiBjYWxsYmFjayhlcnIpOwogICAgICAgIGNhbGxiYWNrKG51bGwsIGFycmF5TWFwKHJlc3VsdHMuc29ydChjb21wYXJhdG9yKSwgYmFzZVByb3BlcnR5KCd2YWx1ZScpKSk7CiAgICB9KTsKCiAgICBmdW5jdGlvbiBjb21wYXJhdG9yKGxlZnQsIHJpZ2h0KSB7CiAgICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhLCBiID0gcmlnaHQuY3JpdGVyaWE7CiAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwOwogICAgfQp9CgovKioKICogU2V0cyBhIHRpbWUgbGltaXQgb24gYW4gYXN5bmNocm9ub3VzIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZG9lcyBub3QgY2FsbAogKiBpdHMgY2FsbGJhY2sgd2l0aGluIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEKICogdGltZW91dCBlcnJvci4gVGhlIGNvZGUgcHJvcGVydHkgZm9yIHRoZSBlcnJvciBvYmplY3Qgd2lsbCBiZSBgJ0VUSU1FRE9VVCdgLgogKgogKiBAbmFtZSB0aW1lb3V0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpVdGlscwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gYXN5bmNGbiAtIFRoZSBhc3luYyBmdW5jdGlvbiB0byBsaW1pdCBpbiB0aW1lLgogKiBAcGFyYW0ge251bWJlcn0gbWlsbGlzZWNvbmRzIC0gVGhlIHNwZWNpZmllZCB0aW1lIGxpbWl0LgogKiBAcGFyYW0geyp9IFtpbmZvXSAtIEFueSB2YXJpYWJsZSB5b3Ugd2FudCBhdHRhY2hlZCAoYHN0cmluZ2AsIGBvYmplY3RgLCBldGMpCiAqIHRvIHRpbWVvdXQgRXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uLgogKiBAcmV0dXJucyB7QXN5bmNGdW5jdGlvbn0gUmV0dXJucyBhIHdyYXBwZWQgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB3aXRoIGFueQogKiBvZiB0aGUgY29udHJvbCBmbG93IGZ1bmN0aW9ucy4KICogSW52b2tlIHRoaXMgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIGFzIHlvdSB3b3VsZCBgYXN5bmNGdW5jYC4KICogQGV4YW1wbGUKICoKICogZnVuY3Rpb24gbXlGdW5jdGlvbihmb28sIGNhbGxiYWNrKSB7CiAqICAgICBkb0FzeW5jVGFzayhmb28sIGZ1bmN0aW9uKGVyciwgZGF0YSkgewogKiAgICAgICAgIC8vIGhhbmRsZSBlcnJvcnMKICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTsKICoKICogICAgICAgICAvLyBkbyBzb21lIHN0dWZmIC4uLgogKgogKiAgICAgICAgIC8vIHJldHVybiBwcm9jZXNzZWQgZGF0YQogKiAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCBkYXRhKTsKICogICAgIH0pOwogKiB9CiAqCiAqIHZhciB3cmFwcGVkID0gYXN5bmMudGltZW91dChteUZ1bmN0aW9uLCAxMDAwKTsKICoKICogLy8gY2FsbCBgd3JhcHBlZGAgYXMgeW91IHdvdWxkIGBteUZ1bmN0aW9uYAogKiB3cmFwcGVkKHsgYmFyOiAnYmFyJyB9LCBmdW5jdGlvbihlcnIsIGRhdGEpIHsKICogICAgIC8vIGlmIGBteUZ1bmN0aW9uYCB0YWtlcyA8IDEwMDAgbXMgdG8gZXhlY3V0ZSwgYGVycmAKICogICAgIC8vIGFuZCBgZGF0YWAgd2lsbCBoYXZlIHRoZWlyIGV4cGVjdGVkIHZhbHVlcwogKgogKiAgICAgLy8gZWxzZSBgZXJyYCB3aWxsIGJlIGFuIEVycm9yIHdpdGggdGhlIGNvZGUgJ0VUSU1FRE9VVCcKICogfSk7CiAqLwpmdW5jdGlvbiB0aW1lb3V0KGFzeW5jRm4sIG1pbGxpc2Vjb25kcywgaW5mbykgewogICAgdmFyIGZuID0gd3JhcEFzeW5jKGFzeW5jRm4pOwoKICAgIHJldHVybiBpbml0aWFsUGFyYW1zKGZ1bmN0aW9uIChhcmdzLCBjYWxsYmFjaykgewogICAgICAgIHZhciB0aW1lZE91dCA9IGZhbHNlOwogICAgICAgIHZhciB0aW1lcjsKCiAgICAgICAgZnVuY3Rpb24gdGltZW91dENhbGxiYWNrKCkgewogICAgICAgICAgICB2YXIgbmFtZSA9IGFzeW5jRm4ubmFtZSB8fCAnYW5vbnltb3VzJzsKICAgICAgICAgICAgdmFyIGVycm9yICA9IG5ldyBFcnJvcignQ2FsbGJhY2sgZnVuY3Rpb24gIicgKyBuYW1lICsgJyIgdGltZWQgb3V0LicpOwogICAgICAgICAgICBlcnJvci5jb2RlID0gJ0VUSU1FRE9VVCc7CiAgICAgICAgICAgIGlmIChpbmZvKSB7CiAgICAgICAgICAgICAgICBlcnJvci5pbmZvID0gaW5mbzsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aW1lZE91dCA9IHRydWU7CiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTsKICAgICAgICB9CgogICAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIGlmICghdGltZWRPdXQpIHsKICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7CiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CgogICAgICAgIC8vIHNldHVwIHRpbWVyIGFuZCBjYWxsIG9yaWdpbmFsIGZ1bmN0aW9uCiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgbWlsbGlzZWNvbmRzKTsKICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTsKICAgIH0pOwp9CgovKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovCnZhciBuYXRpdmVDZWlsID0gTWF0aC5jZWlsOwp2YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXg7CgovKioKICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0CiAqIGNvZXJjZSBhcmd1bWVudHMuCiAqCiAqIEBwcml2YXRlCiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLgogKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLgogKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS4KICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuCiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy4KICovCmZ1bmN0aW9uIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpIHsKICB2YXIgaW5kZXggPSAtMSwKICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksCiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7CgogIHdoaWxlIChsZW5ndGgtLSkgewogICAgcmVzdWx0W2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7CiAgICBzdGFydCArPSBzdGVwOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CgovKioKICogVGhlIHNhbWUgYXMgW3RpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9IGJ1dCBydW5zIGEgbWF4aW11bSBvZiBgbGltaXRgIGFzeW5jIG9wZXJhdGlvbnMgYXQgYQogKiB0aW1lLgogKgogKiBAbmFtZSB0aW1lc0xpbWl0CiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvdwogKiBAbWV0aG9kCiAqIEBzZWUgW2FzeW5jLnRpbWVzXXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cudGltZXN9CiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3cKICogQHBhcmFtIHtudW1iZXJ9IGNvdW50IC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gdGhlIGZ1bmN0aW9uLgogKiBAcGFyYW0ge251bWJlcn0gbGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBUaGUgYXN5bmMgZnVuY3Rpb24gdG8gY2FsbCBgbmAgdGltZXMuCiAqIEludm9rZWQgd2l0aCB0aGUgaXRlcmF0aW9uIGluZGV4IGFuZCBhIGNhbGxiYWNrOiAobiwgbmV4dCkuCiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gc2VlIFthc3luYy5tYXBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5tYXB9LgogKi8KZnVuY3Rpb24gdGltZUxpbWl0KGNvdW50LCBsaW1pdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICB2YXIgX2l0ZXJhdGVlID0gd3JhcEFzeW5jKGl0ZXJhdGVlKTsKICAgIG1hcExpbWl0KGJhc2VSYW5nZSgwLCBjb3VudCwgMSksIGxpbWl0LCBfaXRlcmF0ZWUsIGNhbGxiYWNrKTsKfQoKLyoqCiAqIENhbGxzIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uIGBuYCB0aW1lcywgYW5kIGFjY3VtdWxhdGVzIHJlc3VsdHMgaW4gdGhlIHNhbWUKICogbWFubmVyIHlvdSB3b3VsZCB1c2Ugd2l0aCBbbWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfS4KICoKICogQG5hbWUgdGltZXMKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMubWFwXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMubWFwfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gdGhlIGZ1bmN0aW9uLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIGNhbGwgYG5gIHRpbWVzLgogKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHNlZSB7QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uCiAqIEBleGFtcGxlCiAqCiAqIC8vIFByZXRlbmQgdGhpcyBpcyBzb21lIGNvbXBsaWNhdGVkIGFzeW5jIGZhY3RvcnkKICogdmFyIGNyZWF0ZVVzZXIgPSBmdW5jdGlvbihpZCwgY2FsbGJhY2spIHsKICogICAgIGNhbGxiYWNrKG51bGwsIHsKICogICAgICAgICBpZDogJ3VzZXInICsgaWQKICogICAgIH0pOwogKiB9OwogKgogKiAvLyBnZW5lcmF0ZSA1IHVzZXJzCiAqIGFzeW5jLnRpbWVzKDUsIGZ1bmN0aW9uKG4sIG5leHQpIHsKICogICAgIGNyZWF0ZVVzZXIobiwgZnVuY3Rpb24oZXJyLCB1c2VyKSB7CiAqICAgICAgICAgbmV4dChlcnIsIHVzZXIpOwogKiAgICAgfSk7CiAqIH0sIGZ1bmN0aW9uKGVyciwgdXNlcnMpIHsKICogICAgIC8vIHdlIHNob3VsZCBub3cgaGF2ZSA1IHVzZXJzCiAqIH0pOwogKi8KdmFyIHRpbWVzID0gZG9MaW1pdCh0aW1lTGltaXQsIEluZmluaXR5KTsKCi8qKgogKiBUaGUgc2FtZSBhcyBbdGltZXNde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy50aW1lc30gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLgogKgogKiBAbmFtZSB0aW1lc1NlcmllcwogKiBAc3RhdGljCiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3cKICogQG1ldGhvZAogKiBAc2VlIFthc3luYy50aW1lc117QGxpbmsgbW9kdWxlOkNvbnRyb2xGbG93LnRpbWVzfQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gVGhlIG51bWJlciBvZiB0aW1lcyB0byBydW4gdGhlIGZ1bmN0aW9uLgogKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gVGhlIGFzeW5jIGZ1bmN0aW9uIHRvIGNhbGwgYG5gIHRpbWVzLgogKiBJbnZva2VkIHdpdGggdGhlIGl0ZXJhdGlvbiBpbmRleCBhbmQgYSBjYWxsYmFjazogKG4sIG5leHQpLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIHNlZSB7QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLm1hcH0uCiAqLwp2YXIgdGltZXNTZXJpZXMgPSBkb0xpbWl0KHRpbWVMaW1pdCwgMSk7CgovKioKICogQSByZWxhdGl2ZSBvZiBgcmVkdWNlYC4gIFRha2VzIGFuIE9iamVjdCBvciBBcnJheSwgYW5kIGl0ZXJhdGVzIG92ZXIgZWFjaAogKiBlbGVtZW50IGluIHNlcmllcywgZWFjaCBzdGVwIHBvdGVudGlhbGx5IG11dGF0aW5nIGFuIGBhY2N1bXVsYXRvcmAgdmFsdWUuCiAqIFRoZSB0eXBlIG9mIHRoZSBhY2N1bXVsYXRvciBkZWZhdWx0cyB0byB0aGUgdHlwZSBvZiBjb2xsZWN0aW9uIHBhc3NlZCBpbi4KICoKICogQG5hbWUgdHJhbnNmb3JtCiAqIEBzdGF0aWMKICogQG1lbWJlck9mIG1vZHVsZTpDb2xsZWN0aW9ucwogKiBAbWV0aG9kCiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uCiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci4KICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIC0gVGhlIGluaXRpYWwgc3RhdGUgb2YgdGhlIHRyYW5zZm9ybS4gIElmIG9taXR0ZWQsCiAqIGl0IHdpbGwgZGVmYXVsdCB0byBhbiBlbXB0eSBPYmplY3Qgb3IgQXJyYXksIGRlcGVuZGluZyBvbiB0aGUgdHlwZSBvZiBgY29sbGAKICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gYXBwbGllZCB0byBlYWNoIGl0ZW0gaW4gdGhlCiAqIGNvbGxlY3Rpb24gdGhhdCBwb3RlbnRpYWxseSBtb2RpZmllcyB0aGUgYWNjdW11bGF0b3IuCiAqIEludm9rZWQgd2l0aCAoYWNjdW11bGF0b3IsIGl0ZW0sIGtleSwgY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgYWxsIHRoZQogKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLiBSZXN1bHQgaXMgdGhlIHRyYW5zZm9ybWVkIGFjY3VtdWxhdG9yLgogKiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0KS4KICogQGV4YW1wbGUKICoKICogYXN5bmMudHJhbnNmb3JtKFsxLDIsM10sIGZ1bmN0aW9uKGFjYywgaXRlbSwgaW5kZXgsIGNhbGxiYWNrKSB7CiAqICAgICAvLyBwb2ludGxlc3MgYXN5bmM6CiAqICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkgewogKiAgICAgICAgIGFjYy5wdXNoKGl0ZW0gKiAyKQogKiAgICAgICAgIGNhbGxiYWNrKG51bGwpCiAqICAgICB9KTsKICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBpcyBub3cgZXF1YWwgdG8gWzIsIDQsIDZdCiAqIH0pOwogKgogKiBAZXhhbXBsZQogKgogKiBhc3luYy50cmFuc2Zvcm0oe2E6IDEsIGI6IDIsIGM6IDN9LCBmdW5jdGlvbiAob2JqLCB2YWwsIGtleSwgY2FsbGJhY2spIHsKICogICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7CiAqICAgICAgICAgb2JqW2tleV0gPSB2YWwgKiAyOwogKiAgICAgICAgIGNhbGxiYWNrKCk7CiAqICAgICB9KQogKiB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBpcyBlcXVhbCB0byB7YTogMiwgYjogNCwgYzogNn0KICogfSkKICovCmZ1bmN0aW9uIHRyYW5zZm9ybSAoY29sbCwgYWNjdW11bGF0b3IsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMykgewogICAgICAgIGNhbGxiYWNrID0gaXRlcmF0ZWU7CiAgICAgICAgaXRlcmF0ZWUgPSBhY2N1bXVsYXRvcjsKICAgICAgICBhY2N1bXVsYXRvciA9IGlzQXJyYXkoY29sbCkgPyBbXSA6IHt9OwogICAgfQogICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CgogICAgZWFjaE9mKGNvbGwsIGZ1bmN0aW9uKHYsIGssIGNiKSB7CiAgICAgICAgX2l0ZXJhdGVlKGFjY3VtdWxhdG9yLCB2LCBrLCBjYik7CiAgICB9LCBmdW5jdGlvbihlcnIpIHsKICAgICAgICBjYWxsYmFjayhlcnIsIGFjY3VtdWxhdG9yKTsKICAgIH0pOwp9CgovKioKICogSXQgcnVucyBlYWNoIHRhc2sgaW4gc2VyaWVzIGJ1dCBzdG9wcyB3aGVuZXZlciBhbnkgb2YgdGhlIGZ1bmN0aW9ucyB3ZXJlCiAqIHN1Y2Nlc3NmdWwuIElmIG9uZSBvZiB0aGUgdGFza3Mgd2VyZSBzdWNjZXNzZnVsLCB0aGUgYGNhbGxiYWNrYCB3aWxsIGJlCiAqIHBhc3NlZCB0aGUgcmVzdWx0IG9mIHRoZSBzdWNjZXNzZnVsIHRhc2suIElmIGFsbCB0YXNrcyBmYWlsLCB0aGUgY2FsbGJhY2sKICogd2lsbCBiZSBwYXNzZWQgdGhlIGVycm9yIGFuZCByZXN1bHQgKGlmIGFueSkgb2YgdGhlIGZpbmFsIGF0dGVtcHQuCiAqCiAqIEBuYW1lIHRyeUVhY2gKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gY29udGFpbmluZyBmdW5jdGlvbnMgdG8KICogcnVuLCBlYWNoIGZ1bmN0aW9uIGlzIHBhc3NlZCBhIGBjYWxsYmFjayhlcnIsIHJlc3VsdClgIGl0IG11c3QgY2FsbCBvbgogKiBjb21wbGV0aW9uIHdpdGggYW4gZXJyb3IgYGVycmAgKHdoaWNoIGNhbiBiZSBgbnVsbGApIGFuZCBhbiBvcHRpb25hbCBgcmVzdWx0YAogKiB2YWx1ZS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIG9uZQogKiBvZiB0aGUgdGFza3MgaGFzIHN1Y2NlZWRlZCwgb3IgYWxsIGhhdmUgZmFpbGVkLiBJdCByZWNlaXZlcyB0aGUgYGVycmAgYW5kCiAqIGByZXN1bHRgIGFyZ3VtZW50cyBvZiB0aGUgbGFzdCBhdHRlbXB0IGF0IGNvbXBsZXRpbmcgdGhlIGB0YXNrYC4gSW52b2tlZCB3aXRoCiAqIChlcnIsIHJlc3VsdHMpLgogKiBAZXhhbXBsZQogKiBhc3luYy50cnlFYWNoKFsKICogICAgIGZ1bmN0aW9uIGdldERhdGFGcm9tRmlyc3RXZWJzaXRlKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgZmlyc3Qgd2Vic2l0ZQogKiAgICAgICAgIGNhbGxiYWNrKGVyciwgZGF0YSk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24gZ2V0RGF0YUZyb21TZWNvbmRXZWJzaXRlKGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gRmlyc3Qgd2Vic2l0ZSBmYWlsZWQsCiAqICAgICAgICAgLy8gVHJ5IGdldHRpbmcgdGhlIGRhdGEgZnJvbSB0aGUgYmFja3VwIHdlYnNpdGUKICogICAgICAgICBjYWxsYmFjayhlcnIsIGRhdGEpOwogKiAgICAgfQogKiBdLAogKiAvLyBvcHRpb25hbCBjYWxsYmFjawogKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsKICogICAgIE5vdyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4KICogfSk7CiAqCiAqLwpmdW5jdGlvbiB0cnlFYWNoKHRhc2tzLCBjYWxsYmFjaykgewogICAgdmFyIGVycm9yID0gbnVsbDsKICAgIHZhciByZXN1bHQ7CiAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7CiAgICBlYWNoU2VyaWVzKHRhc2tzLCBmdW5jdGlvbih0YXNrLCBjYWxsYmFjaykgewogICAgICAgIHdyYXBBc3luYyh0YXNrKShmdW5jdGlvbiAoZXJyLCByZXMvKiwgLi4uYXJncyovKSB7CiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikgewogICAgICAgICAgICAgICAgcmVzdWx0ID0gc2xpY2UoYXJndW1lbnRzLCAxKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlczsKICAgICAgICAgICAgfQogICAgICAgICAgICBlcnJvciA9IGVycjsKICAgICAgICAgICAgY2FsbGJhY2soIWVycik7CiAgICAgICAgfSk7CiAgICB9LCBmdW5jdGlvbiAoKSB7CiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3VsdCk7CiAgICB9KTsKfQoKLyoqCiAqIFVuZG9lcyBhIFttZW1vaXplXXtAbGluayBtb2R1bGU6VXRpbHMubWVtb2l6ZX1kIGZ1bmN0aW9uLCByZXZlcnRpbmcgaXQgdG8gdGhlIG9yaWdpbmFsLAogKiB1bm1lbW9pemVkIGZvcm0uIEhhbmR5IGZvciB0ZXN0aW5nLgogKgogKiBAbmFtZSB1bm1lbW9pemUKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOlV0aWxzCiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMubWVtb2l6ZV17QGxpbmsgbW9kdWxlOlV0aWxzLm1lbW9pemV9CiAqIEBjYXRlZ29yeSBVdGlsCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gZm4gLSB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24KICogQHJldHVybnMge0FzeW5jRnVuY3Rpb259IGEgZnVuY3Rpb24gdGhhdCBjYWxscyB0aGUgb3JpZ2luYWwgdW5tZW1vaXplZCBmdW5jdGlvbgogKi8KZnVuY3Rpb24gdW5tZW1vaXplKGZuKSB7CiAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiAoZm4udW5tZW1vaXplZCB8fCBmbikuYXBwbHkobnVsbCwgYXJndW1lbnRzKTsKICAgIH07Cn0KCi8qKgogKiBSZXBlYXRlZGx5IGNhbGwgYGl0ZXJhdGVlYCwgd2hpbGUgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW4KICogc3RvcHBlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLgogKgogKiBAbmFtZSB3aGlsc3QKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0Z1bmN0aW9ufSB0ZXN0IC0gc3luY2hyb25vdXMgdHJ1dGggdGVzdCB0byBwZXJmb3JtIGJlZm9yZSBlYWNoCiAqIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgLiBJbnZva2VkIHdpdGggKCkuCiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB3aGljaCBpcyBjYWxsZWQgZWFjaCB0aW1lCiAqIGB0ZXN0YCBwYXNzZXMuIEludm9rZWQgd2l0aCAoY2FsbGJhY2spLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgYWZ0ZXIgdGhlIHRlc3QKICogZnVuY3Rpb24gaGFzIGZhaWxlZCBhbmQgcmVwZWF0ZWQgZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAgaGFzIHN0b3BwZWQuIGBjYWxsYmFja2AKICogd2lsbCBiZSBwYXNzZWQgYW4gZXJyb3IgYW5kIGFueSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmaW5hbCBgaXRlcmF0ZWVgJ3MKICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pOwogKiBAcmV0dXJucyB1bmRlZmluZWQKICogQGV4YW1wbGUKICoKICogdmFyIGNvdW50ID0gMDsKICogYXN5bmMud2hpbHN0KAogKiAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBjb3VudCA8IDU7IH0sCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIGNvdW50Kys7CiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsKICogICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgY291bnQpOwogKiAgICAgICAgIH0sIDEwMDApOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uIChlcnIsIG4pIHsKICogICAgICAgICAvLyA1IHNlY29uZHMgaGF2ZSBwYXNzZWQsIG4gPSA1CiAqICAgICB9CiAqICk7CiAqLwpmdW5jdGlvbiB3aGlsc3QodGVzdCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7CiAgICBjYWxsYmFjayA9IG9ubHlPbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwogICAgdmFyIF9pdGVyYXRlZSA9IHdyYXBBc3luYyhpdGVyYXRlZSk7CiAgICBpZiAoIXRlc3QoKSkgcmV0dXJuIGNhbGxiYWNrKG51bGwpOwogICAgdmFyIG5leHQgPSBmdW5jdGlvbihlcnIvKiwgLi4uYXJncyovKSB7CiAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7CiAgICAgICAgaWYgKHRlc3QoKSkgcmV0dXJuIF9pdGVyYXRlZShuZXh0KTsKICAgICAgICB2YXIgYXJncyA9IHNsaWNlKGFyZ3VtZW50cywgMSk7CiAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgW251bGxdLmNvbmNhdChhcmdzKSk7CiAgICB9OwogICAgX2l0ZXJhdGVlKG5leHQpOwp9CgovKioKICogUmVwZWF0ZWRseSBjYWxsIGBpdGVyYXRlZWAgdW50aWwgYHRlc3RgIHJldHVybnMgYHRydWVgLiBDYWxscyBgY2FsbGJhY2tgIHdoZW4KICogc3RvcHBlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBgY2FsbGJhY2tgIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkKICogYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzIGNhbGxiYWNrLgogKgogKiBUaGUgaW52ZXJzZSBvZiBbd2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fS4KICoKICogQG5hbWUgdW50aWwKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQHNlZSBbYXN5bmMud2hpbHN0XXtAbGluayBtb2R1bGU6Q29udHJvbEZsb3cud2hpbHN0fQogKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93CiAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3QgLSBzeW5jaHJvbm91cyB0cnV0aCB0ZXN0IHRvIHBlcmZvcm0gYmVmb3JlIGVhY2gKICogZXhlY3V0aW9uIG9mIGBpdGVyYXRlZWAuIEludm9rZWQgd2l0aCAoKS4KICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHdoaWNoIGlzIGNhbGxlZCBlYWNoIHRpbWUKICogYHRlc3RgIGZhaWxzLiBJbnZva2VkIHdpdGggKGNhbGxiYWNrKS4KICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGFmdGVyIHRoZSB0ZXN0CiAqIGZ1bmN0aW9uIGhhcyBwYXNzZWQgYW5kIHJlcGVhdGVkIGV4ZWN1dGlvbiBvZiBgaXRlcmF0ZWVgIGhhcyBzdG9wcGVkLiBgY2FsbGJhY2tgCiAqIHdpbGwgYmUgcGFzc2VkIGFuIGVycm9yIGFuZCBhbnkgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgZmluYWwgYGl0ZXJhdGVlYCdzCiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKTsKICovCmZ1bmN0aW9uIHVudGlsKHRlc3QsIGl0ZXJhdGVlLCBjYWxsYmFjaykgewogICAgd2hpbHN0KGZ1bmN0aW9uKCkgewogICAgICAgIHJldHVybiAhdGVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfSwgaXRlcmF0ZWUsIGNhbGxiYWNrKTsKfQoKLyoqCiAqIFJ1bnMgdGhlIGB0YXNrc2AgYXJyYXkgb2YgZnVuY3Rpb25zIGluIHNlcmllcywgZWFjaCBwYXNzaW5nIHRoZWlyIHJlc3VsdHMgdG8KICogdGhlIG5leHQgaW4gdGhlIGFycmF5LiBIb3dldmVyLCBpZiBhbnkgb2YgdGhlIGB0YXNrc2AgcGFzcyBhbiBlcnJvciB0byB0aGVpcgogKiBvd24gY2FsbGJhY2ssIHRoZSBuZXh0IGZ1bmN0aW9uIGlzIG5vdCBleGVjdXRlZCwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXMKICogaW1tZWRpYXRlbHkgY2FsbGVkIHdpdGggdGhlIGVycm9yLgogKgogKiBAbmFtZSB3YXRlcmZhbGwKICogQHN0YXRpYwogKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93CiAqIEBtZXRob2QKICogQGNhdGVnb3J5IENvbnRyb2wgRmxvdwogKiBAcGFyYW0ge0FycmF5fSB0YXNrcyAtIEFuIGFycmF5IG9mIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259CiAqIHRvIHJ1bi4KICogRWFjaCBmdW5jdGlvbiBzaG91bGQgY29tcGxldGUgd2l0aCBhbnkgbnVtYmVyIG9mIGByZXN1bHRgIHZhbHVlcy4KICogVGhlIGByZXN1bHRgIHZhbHVlcyB3aWxsIGJlIHBhc3NlZCBhcyBhcmd1bWVudHMsIGluIG9yZGVyLCB0byB0aGUgbmV4dCB0YXNrLgogKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZQogKiBmdW5jdGlvbnMgaGF2ZSBjb21wbGV0ZWQuIFRoaXMgd2lsbCBiZSBwYXNzZWQgdGhlIHJlc3VsdHMgb2YgdGhlIGxhc3QgdGFzaydzCiAqIGNhbGxiYWNrLiBJbnZva2VkIHdpdGggKGVyciwgW3Jlc3VsdHNdKS4KICogQHJldHVybnMgdW5kZWZpbmVkCiAqIEBleGFtcGxlCiAqCiAqIGFzeW5jLndhdGVyZmFsbChbCiAqICAgICBmdW5jdGlvbihjYWxsYmFjaykgewogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnLCAndHdvJyk7CiAqICAgICB9LAogKiAgICAgZnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHsKICogICAgICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJwogKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpOwogKiAgICAgfSwKICogICAgIGZ1bmN0aW9uKGFyZzEsIGNhbGxiYWNrKSB7CiAqICAgICAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZScKICogICAgICAgICBjYWxsYmFjayhudWxsLCAnZG9uZScpOwogKiAgICAgfQogKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzICdkb25lJwogKiB9KTsKICoKICogLy8gT3IsIHdpdGggbmFtZWQgZnVuY3Rpb25zOgogKiBhc3luYy53YXRlcmZhbGwoWwogKiAgICAgbXlGaXJzdEZ1bmN0aW9uLAogKiAgICAgbXlTZWNvbmRGdW5jdGlvbiwKICogICAgIG15TGFzdEZ1bmN0aW9uLAogKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHsKICogICAgIC8vIHJlc3VsdCBub3cgZXF1YWxzICdkb25lJwogKiB9KTsKICogZnVuY3Rpb24gbXlGaXJzdEZ1bmN0aW9uKGNhbGxiYWNrKSB7CiAqICAgICBjYWxsYmFjayhudWxsLCAnb25lJywgJ3R3bycpOwogKiB9CiAqIGZ1bmN0aW9uIG15U2Vjb25kRnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHsKICogICAgIC8vIGFyZzEgbm93IGVxdWFscyAnb25lJyBhbmQgYXJnMiBub3cgZXF1YWxzICd0d28nCiAqICAgICBjYWxsYmFjayhudWxsLCAndGhyZWUnKTsKICogfQogKiBmdW5jdGlvbiBteUxhc3RGdW5jdGlvbihhcmcxLCBjYWxsYmFjaykgewogKiAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZScKICogICAgIGNhbGxiYWNrKG51bGwsICdkb25lJyk7CiAqIH0KICovCnZhciB3YXRlcmZhbGwgPSBmdW5jdGlvbih0YXNrcywgY2FsbGJhY2spIHsKICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayB8fCBub29wKTsKICAgIGlmICghaXNBcnJheSh0YXNrcykpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpKTsKICAgIGlmICghdGFza3MubGVuZ3RoKSByZXR1cm4gY2FsbGJhY2soKTsKICAgIHZhciB0YXNrSW5kZXggPSAwOwoKICAgIGZ1bmN0aW9uIG5leHRUYXNrKGFyZ3MpIHsKICAgICAgICB2YXIgdGFzayA9IHdyYXBBc3luYyh0YXNrc1t0YXNrSW5kZXgrK10pOwogICAgICAgIGFyZ3MucHVzaChvbmx5T25jZShuZXh0KSk7CiAgICAgICAgdGFzay5hcHBseShudWxsLCBhcmdzKTsKICAgIH0KCiAgICBmdW5jdGlvbiBuZXh0KGVyci8qLCAuLi5hcmdzKi8pIHsKICAgICAgICBpZiAoZXJyIHx8IHRhc2tJbmRleCA9PT0gdGFza3MubGVuZ3RoKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpOwogICAgICAgIH0KICAgICAgICBuZXh0VGFzayhzbGljZShhcmd1bWVudHMsIDEpKTsKICAgIH0KCiAgICBuZXh0VGFzayhbXSk7Cn07CgovKioKICogQW4gImFzeW5jIGZ1bmN0aW9uIiBpbiB0aGUgY29udGV4dCBvZiBBc3luYyBpcyBhbiBhc3luY2hyb25vdXMgZnVuY3Rpb24gd2l0aAogKiBhIHZhcmlhYmxlIG51bWJlciBvZiBwYXJhbWV0ZXJzLCB3aXRoIHRoZSBmaW5hbCBwYXJhbWV0ZXIgYmVpbmcgYSBjYWxsYmFjay4KICogKGBmdW5jdGlvbiAoYXJnMSwgYXJnMiwgLi4uLCBjYWxsYmFjaykge31gKQogKiBUaGUgZmluYWwgY2FsbGJhY2sgaXMgb2YgdGhlIGZvcm0gYGNhbGxiYWNrKGVyciwgcmVzdWx0cy4uLilgLCB3aGljaCBtdXN0IGJlCiAqIGNhbGxlZCBvbmNlIHRoZSBmdW5jdGlvbiBpcyBjb21wbGV0ZWQuICBUaGUgY2FsbGJhY2sgc2hvdWxkIGJlIGNhbGxlZCB3aXRoIGEKICogRXJyb3IgYXMgaXRzIGZpcnN0IGFyZ3VtZW50IHRvIHNpZ25hbCB0aGF0IGFuIGVycm9yIG9jY3VycmVkLgogKiBPdGhlcndpc2UsIGlmIG5vIGVycm9yIG9jY3VycmVkLCBpdCBzaG91bGQgYmUgY2FsbGVkIHdpdGggYG51bGxgIGFzIHRoZSBmaXJzdAogKiBhcmd1bWVudCwgYW5kIGFueSBhZGRpdGlvbmFsIGByZXN1bHRgIGFyZ3VtZW50cyB0aGF0IG1heSBhcHBseSwgdG8gc2lnbmFsCiAqIHN1Y2Nlc3NmdWwgY29tcGxldGlvbi4KICogVGhlIGNhbGxiYWNrIG11c3QgYmUgY2FsbGVkIGV4YWN0bHkgb25jZSwgaWRlYWxseSBvbiBhIGxhdGVyIHRpY2sgb2YgdGhlCiAqIEphdmFTY3JpcHQgZXZlbnQgbG9vcC4KICoKICogVGhpcyB0eXBlIG9mIGZ1bmN0aW9uIGlzIGFsc28gcmVmZXJyZWQgdG8gYXMgYSAiTm9kZS1zdHlsZSBhc3luYyBmdW5jdGlvbiIsCiAqIG9yIGEgImNvbnRpbnVhdGlvbiBwYXNzaW5nLXN0eWxlIGZ1bmN0aW9uIiAoQ1BTKS4gTW9zdCBvZiB0aGUgbWV0aG9kcyBvZiB0aGlzCiAqIGxpYnJhcnkgYXJlIHRoZW1zZWx2ZXMgQ1BTL05vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb25zLCBvciBmdW5jdGlvbnMgdGhhdAogKiByZXR1cm4gQ1BTL05vZGUtc3R5bGUgYXN5bmMgZnVuY3Rpb25zLgogKgogKiBXaGVyZXZlciB3ZSBhY2NlcHQgYSBOb2RlLXN0eWxlIGFzeW5jIGZ1bmN0aW9uLCB3ZSBhbHNvIGRpcmVjdGx5IGFjY2VwdCBhbgogKiBbRVMyMDE3IGBhc3luY2AgZnVuY3Rpb25de0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1N0YXRlbWVudHMvYXN5bmNfZnVuY3Rpb259LgogKiBJbiB0aGlzIGNhc2UsIHRoZSBgYXN5bmNgIGZ1bmN0aW9uIHdpbGwgbm90IGJlIHBhc3NlZCBhIGZpbmFsIGNhbGxiYWNrCiAqIGFyZ3VtZW50LCBhbmQgYW55IHRocm93biBlcnJvciB3aWxsIGJlIHVzZWQgYXMgdGhlIGBlcnJgIGFyZ3VtZW50IG9mIHRoZQogKiBpbXBsaWNpdCBjYWxsYmFjaywgYW5kIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBgcmVzdWx0YCB2YWx1ZS4KICogKGkuZS4gYSBgcmVqZWN0ZWRgIG9mIHRoZSByZXR1cm5lZCBQcm9taXNlIGJlY29tZXMgdGhlIGBlcnJgIGNhbGxiYWNrCiAqIGFyZ3VtZW50LCBhbmQgYSBgcmVzb2x2ZWRgIHZhbHVlIGJlY29tZXMgdGhlIGByZXN1bHRgLikKICoKICogTm90ZSwgZHVlIHRvIEphdmFTY3JpcHQgbGltaXRhdGlvbnMsIHdlIGNhbiBvbmx5IGRldGVjdCBuYXRpdmUgYGFzeW5jYAogKiBmdW5jdGlvbnMgYW5kIG5vdCB0cmFuc3BpbGllZCBpbXBsZW1lbnRhdGlvbnMuCiAqIFlvdXIgZW52aXJvbm1lbnQgbXVzdCBoYXZlIGBhc3luY2AvYGF3YWl0YCBzdXBwb3J0IGZvciB0aGlzIHRvIHdvcmsuCiAqIChlLmcuIE5vZGUgPiB2Ny42LCBvciBhIHJlY2VudCB2ZXJzaW9uIG9mIGEgbW9kZXJuIGJyb3dzZXIpLgogKiBJZiB5b3UgYXJlIHVzaW5nIGBhc3luY2AgZnVuY3Rpb25zIHRocm91Z2ggYSB0cmFuc3BpbGVyIChlLmcuIEJhYmVsKSwgeW91CiAqIG11c3Qgc3RpbGwgd3JhcCB0aGUgZnVuY3Rpb24gd2l0aCBbYXN5bmNpZnlde0BsaW5rIG1vZHVsZTpVdGlscy5hc3luY2lmeX0sCiAqIGJlY2F1c2UgdGhlIGBhc3luYyBmdW5jdGlvbmAgd2lsbCBiZSBjb21waWxlZCB0byBhbiBvcmRpbmFyeSBmdW5jdGlvbiB0aGF0CiAqIHJldHVybnMgYSBwcm9taXNlLgogKgogKiBAdHlwZWRlZiB7RnVuY3Rpb259IEFzeW5jRnVuY3Rpb24KICogQHN0YXRpYwogKi8KCi8qKgogKiBBc3luYyBpcyBhIHV0aWxpdHkgbW9kdWxlIHdoaWNoIHByb3ZpZGVzIHN0cmFpZ2h0LWZvcndhcmQsIHBvd2VyZnVsIGZ1bmN0aW9ucwogKiBmb3Igd29ya2luZyB3aXRoIGFzeW5jaHJvbm91cyBKYXZhU2NyaXB0LiBBbHRob3VnaCBvcmlnaW5hbGx5IGRlc2lnbmVkIGZvcgogKiB1c2Ugd2l0aCBbTm9kZS5qc10oaHR0cDovL25vZGVqcy5vcmcpIGFuZCBpbnN0YWxsYWJsZSB2aWEKICogYG5wbSBpbnN0YWxsIC0tc2F2ZSBhc3luY2AsIGl0IGNhbiBhbHNvIGJlIHVzZWQgZGlyZWN0bHkgaW4gdGhlIGJyb3dzZXIuCiAqIEBtb2R1bGUgYXN5bmMKICogQHNlZSBBc3luY0Z1bmN0aW9uCiAqLwoKCi8qKgogKiBBIGNvbGxlY3Rpb24gb2YgYGFzeW5jYCBmdW5jdGlvbnMgZm9yIG1hbmlwdWxhdGluZyBjb2xsZWN0aW9ucywgc3VjaCBhcwogKiBhcnJheXMgYW5kIG9iamVjdHMuCiAqIEBtb2R1bGUgQ29sbGVjdGlvbnMKICovCgovKioKICogQSBjb2xsZWN0aW9uIG9mIGBhc3luY2AgZnVuY3Rpb25zIGZvciBjb250cm9sbGluZyB0aGUgZmxvdyB0aHJvdWdoIGEgc2NyaXB0LgogKiBAbW9kdWxlIENvbnRyb2xGbG93CiAqLwoKLyoqCiAqIEEgY29sbGVjdGlvbiBvZiBgYXN5bmNgIHV0aWxpdHkgZnVuY3Rpb25zLgogKiBAbW9kdWxlIFV0aWxzCiAqLwoKdmFyIGluZGV4ID0gewogICAgYXBwbHk6IGFwcGx5LAogICAgYXBwbHlFYWNoOiBhcHBseUVhY2gsCiAgICBhcHBseUVhY2hTZXJpZXM6IGFwcGx5RWFjaFNlcmllcywKICAgIGFzeW5jaWZ5OiBhc3luY2lmeSwKICAgIGF1dG86IGF1dG8sCiAgICBhdXRvSW5qZWN0OiBhdXRvSW5qZWN0LAogICAgY2FyZ286IGNhcmdvLAogICAgY29tcG9zZTogY29tcG9zZSwKICAgIGNvbmNhdDogY29uY2F0LAogICAgY29uY2F0TGltaXQ6IGNvbmNhdExpbWl0LAogICAgY29uY2F0U2VyaWVzOiBjb25jYXRTZXJpZXMsCiAgICBjb25zdGFudDogY29uc3RhbnQsCiAgICBkZXRlY3Q6IGRldGVjdCwKICAgIGRldGVjdExpbWl0OiBkZXRlY3RMaW1pdCwKICAgIGRldGVjdFNlcmllczogZGV0ZWN0U2VyaWVzLAogICAgZGlyOiBkaXIsCiAgICBkb0R1cmluZzogZG9EdXJpbmcsCiAgICBkb1VudGlsOiBkb1VudGlsLAogICAgZG9XaGlsc3Q6IGRvV2hpbHN0LAogICAgZHVyaW5nOiBkdXJpbmcsCiAgICBlYWNoOiBlYWNoTGltaXQsCiAgICBlYWNoTGltaXQ6IGVhY2hMaW1pdCQxLAogICAgZWFjaE9mOiBlYWNoT2YsCiAgICBlYWNoT2ZMaW1pdDogZWFjaE9mTGltaXQsCiAgICBlYWNoT2ZTZXJpZXM6IGVhY2hPZlNlcmllcywKICAgIGVhY2hTZXJpZXM6IGVhY2hTZXJpZXMsCiAgICBlbnN1cmVBc3luYzogZW5zdXJlQXN5bmMsCiAgICBldmVyeTogZXZlcnksCiAgICBldmVyeUxpbWl0OiBldmVyeUxpbWl0LAogICAgZXZlcnlTZXJpZXM6IGV2ZXJ5U2VyaWVzLAogICAgZmlsdGVyOiBmaWx0ZXIsCiAgICBmaWx0ZXJMaW1pdDogZmlsdGVyTGltaXQsCiAgICBmaWx0ZXJTZXJpZXM6IGZpbHRlclNlcmllcywKICAgIGZvcmV2ZXI6IGZvcmV2ZXIsCiAgICBncm91cEJ5OiBncm91cEJ5LAogICAgZ3JvdXBCeUxpbWl0OiBncm91cEJ5TGltaXQsCiAgICBncm91cEJ5U2VyaWVzOiBncm91cEJ5U2VyaWVzLAogICAgbG9nOiBsb2csCiAgICBtYXA6IG1hcCwKICAgIG1hcExpbWl0OiBtYXBMaW1pdCwKICAgIG1hcFNlcmllczogbWFwU2VyaWVzLAogICAgbWFwVmFsdWVzOiBtYXBWYWx1ZXMsCiAgICBtYXBWYWx1ZXNMaW1pdDogbWFwVmFsdWVzTGltaXQsCiAgICBtYXBWYWx1ZXNTZXJpZXM6IG1hcFZhbHVlc1NlcmllcywKICAgIG1lbW9pemU6IG1lbW9pemUsCiAgICBuZXh0VGljazogbmV4dFRpY2ssCiAgICBwYXJhbGxlbDogcGFyYWxsZWxMaW1pdCwKICAgIHBhcmFsbGVsTGltaXQ6IHBhcmFsbGVsTGltaXQkMSwKICAgIHByaW9yaXR5UXVldWU6IHByaW9yaXR5UXVldWUsCiAgICBxdWV1ZTogcXVldWUkMSwKICAgIHJhY2U6IHJhY2UsCiAgICByZWR1Y2U6IHJlZHVjZSwKICAgIHJlZHVjZVJpZ2h0OiByZWR1Y2VSaWdodCwKICAgIHJlZmxlY3Q6IHJlZmxlY3QsCiAgICByZWZsZWN0QWxsOiByZWZsZWN0QWxsLAogICAgcmVqZWN0OiByZWplY3QsCiAgICByZWplY3RMaW1pdDogcmVqZWN0TGltaXQsCiAgICByZWplY3RTZXJpZXM6IHJlamVjdFNlcmllcywKICAgIHJldHJ5OiByZXRyeSwKICAgIHJldHJ5YWJsZTogcmV0cnlhYmxlLAogICAgc2VxOiBzZXEsCiAgICBzZXJpZXM6IHNlcmllcywKICAgIHNldEltbWVkaWF0ZTogc2V0SW1tZWRpYXRlJDEsCiAgICBzb21lOiBzb21lLAogICAgc29tZUxpbWl0OiBzb21lTGltaXQsCiAgICBzb21lU2VyaWVzOiBzb21lU2VyaWVzLAogICAgc29ydEJ5OiBzb3J0QnksCiAgICB0aW1lb3V0OiB0aW1lb3V0LAogICAgdGltZXM6IHRpbWVzLAogICAgdGltZXNMaW1pdDogdGltZUxpbWl0LAogICAgdGltZXNTZXJpZXM6IHRpbWVzU2VyaWVzLAogICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sCiAgICB0cnlFYWNoOiB0cnlFYWNoLAogICAgdW5tZW1vaXplOiB1bm1lbW9pemUsCiAgICB1bnRpbDogdW50aWwsCiAgICB3YXRlcmZhbGw6IHdhdGVyZmFsbCwKICAgIHdoaWxzdDogd2hpbHN0LAoKICAgIC8vIGFsaWFzZXMKICAgIGFsbDogZXZlcnksCiAgICBhbGxMaW1pdDogZXZlcnlMaW1pdCwKICAgIGFsbFNlcmllczogZXZlcnlTZXJpZXMsCiAgICBhbnk6IHNvbWUsCiAgICBhbnlMaW1pdDogc29tZUxpbWl0LAogICAgYW55U2VyaWVzOiBzb21lU2VyaWVzLAogICAgZmluZDogZGV0ZWN0LAogICAgZmluZExpbWl0OiBkZXRlY3RMaW1pdCwKICAgIGZpbmRTZXJpZXM6IGRldGVjdFNlcmllcywKICAgIGZvckVhY2g6IGVhY2hMaW1pdCwKICAgIGZvckVhY2hTZXJpZXM6IGVhY2hTZXJpZXMsCiAgICBmb3JFYWNoTGltaXQ6IGVhY2hMaW1pdCQxLAogICAgZm9yRWFjaE9mOiBlYWNoT2YsCiAgICBmb3JFYWNoT2ZTZXJpZXM6IGVhY2hPZlNlcmllcywKICAgIGZvckVhY2hPZkxpbWl0OiBlYWNoT2ZMaW1pdCwKICAgIGluamVjdDogcmVkdWNlLAogICAgZm9sZGw6IHJlZHVjZSwKICAgIGZvbGRyOiByZWR1Y2VSaWdodCwKICAgIHNlbGVjdDogZmlsdGVyLAogICAgc2VsZWN0TGltaXQ6IGZpbHRlckxpbWl0LAogICAgc2VsZWN0U2VyaWVzOiBmaWx0ZXJTZXJpZXMsCiAgICB3cmFwU3luYzogYXN5bmNpZnkKfTsKCmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGluZGV4OwpleHBvcnRzLmFwcGx5ID0gYXBwbHk7CmV4cG9ydHMuYXBwbHlFYWNoID0gYXBwbHlFYWNoOwpleHBvcnRzLmFwcGx5RWFjaFNlcmllcyA9IGFwcGx5RWFjaFNlcmllczsKZXhwb3J0cy5hc3luY2lmeSA9IGFzeW5jaWZ5OwpleHBvcnRzLmF1dG8gPSBhdXRvOwpleHBvcnRzLmF1dG9JbmplY3QgPSBhdXRvSW5qZWN0OwpleHBvcnRzLmNhcmdvID0gY2FyZ287CmV4cG9ydHMuY29tcG9zZSA9IGNvbXBvc2U7CmV4cG9ydHMuY29uY2F0ID0gY29uY2F0OwpleHBvcnRzLmNvbmNhdExpbWl0ID0gY29uY2F0TGltaXQ7CmV4cG9ydHMuY29uY2F0U2VyaWVzID0gY29uY2F0U2VyaWVzOwpleHBvcnRzLmNvbnN0YW50ID0gY29uc3RhbnQ7CmV4cG9ydHMuZGV0ZWN0ID0gZGV0ZWN0OwpleHBvcnRzLmRldGVjdExpbWl0ID0gZGV0ZWN0TGltaXQ7CmV4cG9ydHMuZGV0ZWN0U2VyaWVzID0gZGV0ZWN0U2VyaWVzOwpleHBvcnRzLmRpciA9IGRpcjsKZXhwb3J0cy5kb0R1cmluZyA9IGRvRHVyaW5nOwpleHBvcnRzLmRvVW50aWwgPSBkb1VudGlsOwpleHBvcnRzLmRvV2hpbHN0ID0gZG9XaGlsc3Q7CmV4cG9ydHMuZHVyaW5nID0gZHVyaW5nOwpleHBvcnRzLmVhY2ggPSBlYWNoTGltaXQ7CmV4cG9ydHMuZWFjaExpbWl0ID0gZWFjaExpbWl0JDE7CmV4cG9ydHMuZWFjaE9mID0gZWFjaE9mOwpleHBvcnRzLmVhY2hPZkxpbWl0ID0gZWFjaE9mTGltaXQ7CmV4cG9ydHMuZWFjaE9mU2VyaWVzID0gZWFjaE9mU2VyaWVzOwpleHBvcnRzLmVhY2hTZXJpZXMgPSBlYWNoU2VyaWVzOwpleHBvcnRzLmVuc3VyZUFzeW5jID0gZW5zdXJlQXN5bmM7CmV4cG9ydHMuZXZlcnkgPSBldmVyeTsKZXhwb3J0cy5ldmVyeUxpbWl0ID0gZXZlcnlMaW1pdDsKZXhwb3J0cy5ldmVyeVNlcmllcyA9IGV2ZXJ5U2VyaWVzOwpleHBvcnRzLmZpbHRlciA9IGZpbHRlcjsKZXhwb3J0cy5maWx0ZXJMaW1pdCA9IGZpbHRlckxpbWl0OwpleHBvcnRzLmZpbHRlclNlcmllcyA9IGZpbHRlclNlcmllczsKZXhwb3J0cy5mb3JldmVyID0gZm9yZXZlcjsKZXhwb3J0cy5ncm91cEJ5ID0gZ3JvdXBCeTsKZXhwb3J0cy5ncm91cEJ5TGltaXQgPSBncm91cEJ5TGltaXQ7CmV4cG9ydHMuZ3JvdXBCeVNlcmllcyA9IGdyb3VwQnlTZXJpZXM7CmV4cG9ydHMubG9nID0gbG9nOwpleHBvcnRzLm1hcCA9IG1hcDsKZXhwb3J0cy5tYXBMaW1pdCA9IG1hcExpbWl0OwpleHBvcnRzLm1hcFNlcmllcyA9IG1hcFNlcmllczsKZXhwb3J0cy5tYXBWYWx1ZXMgPSBtYXBWYWx1ZXM7CmV4cG9ydHMubWFwVmFsdWVzTGltaXQgPSBtYXBWYWx1ZXNMaW1pdDsKZXhwb3J0cy5tYXBWYWx1ZXNTZXJpZXMgPSBtYXBWYWx1ZXNTZXJpZXM7CmV4cG9ydHMubWVtb2l6ZSA9IG1lbW9pemU7CmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljazsKZXhwb3J0cy5wYXJhbGxlbCA9IHBhcmFsbGVsTGltaXQ7CmV4cG9ydHMucGFyYWxsZWxMaW1pdCA9IHBhcmFsbGVsTGltaXQkMTsKZXhwb3J0cy5wcmlvcml0eVF1ZXVlID0gcHJpb3JpdHlRdWV1ZTsKZXhwb3J0cy5xdWV1ZSA9IHF1ZXVlJDE7CmV4cG9ydHMucmFjZSA9IHJhY2U7CmV4cG9ydHMucmVkdWNlID0gcmVkdWNlOwpleHBvcnRzLnJlZHVjZVJpZ2h0ID0gcmVkdWNlUmlnaHQ7CmV4cG9ydHMucmVmbGVjdCA9IHJlZmxlY3Q7CmV4cG9ydHMucmVmbGVjdEFsbCA9IHJlZmxlY3RBbGw7CmV4cG9ydHMucmVqZWN0ID0gcmVqZWN0OwpleHBvcnRzLnJlamVjdExpbWl0ID0gcmVqZWN0TGltaXQ7CmV4cG9ydHMucmVqZWN0U2VyaWVzID0gcmVqZWN0U2VyaWVzOwpleHBvcnRzLnJldHJ5ID0gcmV0cnk7CmV4cG9ydHMucmV0cnlhYmxlID0gcmV0cnlhYmxlOwpleHBvcnRzLnNlcSA9IHNlcTsKZXhwb3J0cy5zZXJpZXMgPSBzZXJpZXM7CmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlJDE7CmV4cG9ydHMuc29tZSA9IHNvbWU7CmV4cG9ydHMuc29tZUxpbWl0ID0gc29tZUxpbWl0OwpleHBvcnRzLnNvbWVTZXJpZXMgPSBzb21lU2VyaWVzOwpleHBvcnRzLnNvcnRCeSA9IHNvcnRCeTsKZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dDsKZXhwb3J0cy50aW1lcyA9IHRpbWVzOwpleHBvcnRzLnRpbWVzTGltaXQgPSB0aW1lTGltaXQ7CmV4cG9ydHMudGltZXNTZXJpZXMgPSB0aW1lc1NlcmllczsKZXhwb3J0cy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07CmV4cG9ydHMudHJ5RWFjaCA9IHRyeUVhY2g7CmV4cG9ydHMudW5tZW1vaXplID0gdW5tZW1vaXplOwpleHBvcnRzLnVudGlsID0gdW50aWw7CmV4cG9ydHMud2F0ZXJmYWxsID0gd2F0ZXJmYWxsOwpleHBvcnRzLndoaWxzdCA9IHdoaWxzdDsKZXhwb3J0cy5hbGwgPSBldmVyeTsKZXhwb3J0cy5hbGxMaW1pdCA9IGV2ZXJ5TGltaXQ7CmV4cG9ydHMuYWxsU2VyaWVzID0gZXZlcnlTZXJpZXM7CmV4cG9ydHMuYW55ID0gc29tZTsKZXhwb3J0cy5hbnlMaW1pdCA9IHNvbWVMaW1pdDsKZXhwb3J0cy5hbnlTZXJpZXMgPSBzb21lU2VyaWVzOwpleHBvcnRzLmZpbmQgPSBkZXRlY3Q7CmV4cG9ydHMuZmluZExpbWl0ID0gZGV0ZWN0TGltaXQ7CmV4cG9ydHMuZmluZFNlcmllcyA9IGRldGVjdFNlcmllczsKZXhwb3J0cy5mb3JFYWNoID0gZWFjaExpbWl0OwpleHBvcnRzLmZvckVhY2hTZXJpZXMgPSBlYWNoU2VyaWVzOwpleHBvcnRzLmZvckVhY2hMaW1pdCA9IGVhY2hMaW1pdCQxOwpleHBvcnRzLmZvckVhY2hPZiA9IGVhY2hPZjsKZXhwb3J0cy5mb3JFYWNoT2ZTZXJpZXMgPSBlYWNoT2ZTZXJpZXM7CmV4cG9ydHMuZm9yRWFjaE9mTGltaXQgPSBlYWNoT2ZMaW1pdDsKZXhwb3J0cy5pbmplY3QgPSByZWR1Y2U7CmV4cG9ydHMuZm9sZGwgPSByZWR1Y2U7CmV4cG9ydHMuZm9sZHIgPSByZWR1Y2VSaWdodDsKZXhwb3J0cy5zZWxlY3QgPSBmaWx0ZXI7CmV4cG9ydHMuc2VsZWN0TGltaXQgPSBmaWx0ZXJMaW1pdDsKZXhwb3J0cy5zZWxlY3RTZXJpZXMgPSBmaWx0ZXJTZXJpZXM7CmV4cG9ydHMud3JhcFN5bmMgPSBhc3luY2lmeTsKCk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7Cgp9KSkpOwoKfSkuY2FsbCh0aGlzLF9kZXJlcV8oJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSkKfSx7Il9wcm9jZXNzIjoxOX1dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IHsgImRlZmF1bHQiOiBfZGVyZXFfKCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbiIpLCBfX2VzTW9kdWxlOiB0cnVlIH07Cn0seyJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2Fzc2lnbiI6MjF9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB7ICJkZWZhdWx0IjogX2RlcmVxXygiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUiKSwgX19lc01vZHVsZTogdHJ1ZSB9Owp9LHsiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUiOjIyfV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0geyAiZGVmYXVsdCI6IF9kZXJlcV8oImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5IiksIF9fZXNNb2R1bGU6IHRydWUgfTsKfSx7ImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5IjoyM31dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IHsgImRlZmF1bHQiOiBfZGVyZXFfKCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2YiKSwgX19lc01vZHVsZTogdHJ1ZSB9Owp9LHsiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mIjoyNH1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IHsgImRlZmF1bHQiOiBfZGVyZXFfKCJjb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YiKSwgX19lc01vZHVsZTogdHJ1ZSB9Owp9LHsiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9zZXQtcHJvdG90eXBlLW9mIjoyNX1dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB7ICJkZWZhdWx0IjogX2RlcmVxXygiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07Cn0seyJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sIjoyNn1dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB7ICJkZWZhdWx0IjogX2RlcmVxXygiY29yZS1qcy9saWJyYXJ5L2ZuL3N5bWJvbC9pdGVyYXRvciIpLCBfX2VzTW9kdWxlOiB0cnVlIH07Cn0seyJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yIjoyN31dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKInVzZSBzdHJpY3QiOwoKZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKCmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsKICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uIik7CiAgfQp9Owp9LHt9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CiJ1c2Ugc3RyaWN0IjsKCmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7Cgp2YXIgX2RlZmluZVByb3BlcnR5ID0gX2RlcmVxXygiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5Iik7Cgp2YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTsKCmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9CgpleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7CiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7CiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07CiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsKICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOwogICAgICBpZiAoInZhbHVlIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsKICAgICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTIuZGVmYXVsdCkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7CiAgICB9CiAgfQoKICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgewogICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsKICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOwogICAgcmV0dXJuIENvbnN0cnVjdG9yOwogIH07Cn0oKTsKfSx7Ii4uL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eSI6N31dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKInVzZSBzdHJpY3QiOwoKZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKCnZhciBfc2V0UHJvdG90eXBlT2YgPSBfZGVyZXFfKCIuLi9jb3JlLWpzL29iamVjdC9zZXQtcHJvdG90eXBlLW9mIik7Cgp2YXIgX3NldFByb3RvdHlwZU9mMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NldFByb3RvdHlwZU9mKTsKCnZhciBfY3JlYXRlID0gX2RlcmVxXygiLi4vY29yZS1qcy9vYmplY3QvY3JlYXRlIik7Cgp2YXIgX2NyZWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGUpOwoKdmFyIF90eXBlb2YyID0gX2RlcmVxXygiLi4vaGVscGVycy90eXBlb2YiKTsKCnZhciBfdHlwZW9mMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3R5cGVvZjIpOwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChzdWJDbGFzcywgc3VwZXJDbGFzcykgewogIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gImZ1bmN0aW9uIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICIgKyAodHlwZW9mIHN1cGVyQ2xhc3MgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc3VwZXJDbGFzcykpKTsKICB9CgogIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7CiAgICBjb25zdHJ1Y3RvcjogewogICAgICB2YWx1ZTogc3ViQ2xhc3MsCiAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICB3cml0YWJsZTogdHJ1ZSwKICAgICAgY29uZmlndXJhYmxlOiB0cnVlCiAgICB9CiAgfSk7CiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCA/ICgwLCBfc2V0UHJvdG90eXBlT2YyLmRlZmF1bHQpKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7Cn07Cn0seyIuLi9jb3JlLWpzL29iamVjdC9jcmVhdGUiOjYsIi4uL2NvcmUtanMvb2JqZWN0L3NldC1wcm90b3R5cGUtb2YiOjksIi4uL2hlbHBlcnMvdHlwZW9mIjoxNn1dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKInVzZSBzdHJpY3QiOwoKZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKCnZhciBfdHlwZW9mMiA9IF9kZXJlcV8oIi4uL2hlbHBlcnMvdHlwZW9mIik7Cgp2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTsKCmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9CgpleHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiAoc2VsZiwgY2FsbCkgewogIGlmICghc2VsZikgewogICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWQiKTsKICB9CgogIHJldHVybiBjYWxsICYmICgodHlwZW9mIGNhbGwgPT09ICJ1bmRlZmluZWQiID8gInVuZGVmaW5lZCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSAib2JqZWN0IiB8fCB0eXBlb2YgY2FsbCA9PT0gImZ1bmN0aW9uIikgPyBjYWxsIDogc2VsZjsKfTsKfSx7Ii4uL2hlbHBlcnMvdHlwZW9mIjoxNn1dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKInVzZSBzdHJpY3QiOwoKZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsKCnZhciBfaXRlcmF0b3IgPSBfZGVyZXFfKCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvciIpOwoKdmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7Cgp2YXIgX3N5bWJvbCA9IF9kZXJlcV8oIi4uL2NvcmUtanMvc3ltYm9sIik7Cgp2YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpOwoKdmFyIF90eXBlb2YgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gImZ1bmN0aW9uIiAmJiB0eXBlb2YgX2l0ZXJhdG9yMi5kZWZhdWx0ID09PSAic3ltYm9sIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09ICJmdW5jdGlvbiIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBfc3ltYm9sMi5kZWZhdWx0ICYmIG9iaiAhPT0gX3N5bWJvbDIuZGVmYXVsdC5wcm90b3R5cGUgPyAic3ltYm9sIiA6IHR5cGVvZiBvYmo7IH07CgpmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfQoKZXhwb3J0cy5kZWZhdWx0ID0gdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09ICJmdW5jdGlvbiIgJiYgX3R5cGVvZihfaXRlcmF0b3IyLmRlZmF1bHQpID09PSAic3ltYm9sIiA/IGZ1bmN0aW9uIChvYmopIHsKICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gInVuZGVmaW5lZCIgPyAidW5kZWZpbmVkIiA6IF90eXBlb2Yob2JqKTsKfSA6IGZ1bmN0aW9uIChvYmopIHsKICByZXR1cm4gb2JqICYmIHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSAiZnVuY3Rpb24iICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gInN5bWJvbCIgOiB0eXBlb2Ygb2JqID09PSAidW5kZWZpbmVkIiA/ICJ1bmRlZmluZWQiIDogX3R5cGVvZihvYmopOwp9Owp9LHsiLi4vY29yZS1qcy9zeW1ib2wiOjEwLCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvciI6MTF9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JwoKZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aApleHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXkKZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheQoKdmFyIGxvb2t1cCA9IFtdCnZhciByZXZMb29rdXAgPSBbXQp2YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5Cgp2YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJwpmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkgewogIGxvb2t1cFtpXSA9IGNvZGVbaV0KICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGkKfQoKcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyCnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2MwoKZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkgewogIHZhciBsZW4gPSBiNjQubGVuZ3RoCiAgaWYgKGxlbiAlIDQgPiAwKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKQogIH0KCiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycykKICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0CiAgLy8gcmVwcmVzZW50IG9uZSBieXRlCiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzCiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZQogIHJldHVybiBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwCn0KCmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkgewogIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YQogIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NCkKfQoKZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkgewogIHZhciBpLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyCiAgdmFyIGxlbiA9IGI2NC5sZW5ndGgKICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpCgogIGFyciA9IG5ldyBBcnIoKGxlbiAqIDMgLyA0KSAtIHBsYWNlSG9sZGVycykKCiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFycwogIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlbgoKICB2YXIgTCA9IDAKCiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkgewogICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8IHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldCiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRgogICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRgogICAgYXJyW0wrK10gPSB0bXAgJiAweEZGCiAgfQoKICBpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7CiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KQogICAgYXJyW0wrK10gPSB0bXAgJiAweEZGCiAgfSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHsKICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKQogICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRgogICAgYXJyW0wrK10gPSB0bXAgJiAweEZGCiAgfQoKICByZXR1cm4gYXJyCn0KCmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7CiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdCn0KCmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkgewogIHZhciB0bXAKICB2YXIgb3V0cHV0ID0gW10KICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykgewogICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKQogICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpCiAgfQogIHJldHVybiBvdXRwdXQuam9pbignJykKfQoKZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHsKICB2YXIgdG1wCiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aAogIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlcwogIHZhciBvdXRwdXQgPSAnJwogIHZhciBwYXJ0cyA9IFtdCiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzCgogIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXIKICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7CiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKQogIH0KCiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlcwogIGlmIChleHRyYUJ5dGVzID09PSAxKSB7CiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXQogICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMl0KICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdCiAgICBvdXRwdXQgKz0gJz09JwogIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikgewogICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKQogICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdCiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXQogICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0KICAgIG91dHB1dCArPSAnPScKICB9CgogIHBhcnRzLnB1c2gob3V0cHV0KQoKICByZXR1cm4gcGFydHMuam9pbignJykKfQoKfSx7fV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewoKfSx7fV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXIKdmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9OwoKLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0Ci8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpcwovLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhCi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuCgp2YXIgY2FjaGVkU2V0VGltZW91dDsKdmFyIGNhY2hlZENsZWFyVGltZW91dDsKCmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTsKfQpmdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHsKICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7Cn0KKGZ1bmN0aW9uICgpIHsKICAgIHRyeSB7CiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0OwogICAgICAgIH0KICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDsKICAgIH0KICAgIHRyeSB7CiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7CiAgICAgICAgfQogICAgfSBjYXRjaCAoZSkgewogICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7CiAgICB9Cn0gKCkpCmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7CiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkgewogICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9ucwogICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7CiAgICB9CiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZAogICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7CiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7CiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTsKICAgIH0KICAgIHRyeSB7CiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzcwogICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7CiAgICB9IGNhdGNoKGUpewogICAgICAgIHRyeSB7CiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseQogICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7CiAgICAgICAgfSBjYXRjaChlKXsKICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IKICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApOwogICAgICAgIH0KICAgIH0KCgp9CmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHsKICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkgewogICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9ucwogICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTsKICAgIH0KICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWQKICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkgewogICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDsKICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7CiAgICB9CiAgICB0cnkgewogICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3MKICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7CiAgICB9IGNhdGNoIChlKXsKICAgICAgICB0cnkgewogICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5CiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpOwogICAgICAgIH0gY2F0Y2ggKGUpewogICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci4KICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dAogICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTsKICAgICAgICB9CiAgICB9CgoKCn0KdmFyIHF1ZXVlID0gW107CnZhciBkcmFpbmluZyA9IGZhbHNlOwp2YXIgY3VycmVudFF1ZXVlOwp2YXIgcXVldWVJbmRleCA9IC0xOwoKZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkgewogICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7CiAgICAgICAgcmV0dXJuOwogICAgfQogICAgZHJhaW5pbmcgPSBmYWxzZTsKICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7CiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTsKICAgIH0gZWxzZSB7CiAgICAgICAgcXVldWVJbmRleCA9IC0xOwogICAgfQogICAgaWYgKHF1ZXVlLmxlbmd0aCkgewogICAgICAgIGRyYWluUXVldWUoKTsKICAgIH0KfQoKZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHsKICAgIGlmIChkcmFpbmluZykgewogICAgICAgIHJldHVybjsKICAgIH0KICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spOwogICAgZHJhaW5pbmcgPSB0cnVlOwoKICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7CiAgICB3aGlsZShsZW4pIHsKICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTsKICAgICAgICBxdWV1ZSA9IFtdOwogICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHsKICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkgewogICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHF1ZXVlSW5kZXggPSAtMTsKICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7CiAgICB9CiAgICBjdXJyZW50UXVldWUgPSBudWxsOwogICAgZHJhaW5pbmcgPSBmYWxzZTsKICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTsKfQoKcHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHsKICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTsKICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgewogICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldOwogICAgICAgIH0KICAgIH0KICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7CiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykgewogICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7CiAgICB9Cn07CgovLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzCmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkgewogICAgdGhpcy5mdW4gPSBmdW47CiAgICB0aGlzLmFycmF5ID0gYXJyYXk7Cn0KSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkgewogICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7Cn07CnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7CnByb2Nlc3MuYnJvd3NlciA9IHRydWU7CnByb2Nlc3MuZW52ID0ge307CnByb2Nlc3MuYXJndiA9IFtdOwpwcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXMKcHJvY2Vzcy52ZXJzaW9ucyA9IHt9OwoKZnVuY3Rpb24gbm9vcCgpIHt9Cgpwcm9jZXNzLm9uID0gbm9vcDsKcHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7CnByb2Nlc3Mub25jZSA9IG5vb3A7CnByb2Nlc3Mub2ZmID0gbm9vcDsKcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7CnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDsKcHJvY2Vzcy5lbWl0ID0gbm9vcDsKcHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wOwpwcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wOwoKcHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfQoKcHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHsKICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTsKfTsKCnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07CnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpOwp9Owpwcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9OwoKfSx7fV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovKiEKICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuCiAqCiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+CiAqIEBsaWNlbnNlICBNSVQKICovCi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovCgondXNlIHN0cmljdCcKCnZhciBiYXNlNjQgPSBfZGVyZXFfKCdiYXNlNjQtanMnKQp2YXIgaWVlZTc1NCA9IF9kZXJlcV8oJ2llZWU3NTQnKQoKZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXIKZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlcgpleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTAKCnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmCmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSAoKLyoqCiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6CiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpCiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdAogKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KQogKgogKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssCiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy4KICoKICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlCiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAKICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydAogKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi4KICovCkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKQoKaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYKICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7CiAgY29uc29sZS5lcnJvcigKICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArCiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nCiAgKQp9CgpmdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7CiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkPwogIHRyeSB7CiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSkKICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fQogICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIKICB9IGNhdGNoIChlKSB7CiAgICByZXR1cm4gZmFsc2UKICB9Cn0KCmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7CiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJykKICB9CiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UKICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKQogIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlCiAgcmV0dXJuIGJ1Zgp9CgovKioKICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyCiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2YKICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kcwogKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdAogKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LgogKgogKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuCiAqLwoKZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIC8vIENvbW1vbiBjYXNlLgogIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykgewogICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykgewogICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJwogICAgICApCiAgICB9CiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKQogIH0KICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkKfQoKLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTcKaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmCiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywgewogICAgdmFsdWU6IG51bGwsCiAgICBjb25maWd1cmFibGU6IHRydWUsCiAgICBlbnVtZXJhYmxlOiBmYWxzZSwKICAgIHdyaXRhYmxlOiBmYWxzZQogIH0pCn0KCkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvbgoKZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJykKICB9CgogIGlmIChpc0FycmF5QnVmZmVyKHZhbHVlKSkgewogICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKQogIH0KCiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsKICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KQogIH0KCiAgcmV0dXJuIGZyb21PYmplY3QodmFsdWUpCn0KCi8qKgogKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvcgogKiBpZiB2YWx1ZSBpcyBhIG51bWJlci4KICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKQogKiBCdWZmZXIuZnJvbShhcnJheSkKICogQnVmZmVyLmZyb20oYnVmZmVyKQogKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSkKICoqLwpCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7CiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkKfQoKLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOgovLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OApCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlCkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5CgpmdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7CiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignInNpemUiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKQogIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCcic2l6ZSIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKQogIH0KfQoKZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgYXNzZXJ0U2l6ZShzaXplKQogIGlmIChzaXplIDw9IDApIHsKICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSkKICB9CiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkgewogICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXMKICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGQKICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC4KICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnCiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpCiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCkKICB9CiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKQp9CgovKioKICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLgogKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pCiAqKi8KQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKQp9CgpmdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkgewogIGFzc2VydFNpemUoc2l6ZSkKICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKQp9CgovKioKICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS4KICogKi8KQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHsKICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSkKfQovKioKICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuCiAqLwpCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHsKICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSkKfQoKZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykgewogIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykgewogICAgZW5jb2RpbmcgPSAndXRmOCcKICB9CgogIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCciZW5jb2RpbmciIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKQogIH0KCiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwCiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpCgogIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZykKCiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7CiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGwKICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuCiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJykKICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpCiAgfQoKICByZXR1cm4gYnVmCn0KCmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7CiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMAogIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKQogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHsKICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1CiAgfQogIHJldHVybiBidWYKfQoKZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7CiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCdvZmZzZXRcJyBpcyBvdXQgb2YgYm91bmRzJykKICB9CgogIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcJ2xlbmd0aFwnIGlzIG91dCBvZiBib3VuZHMnKQogIH0KCiAgdmFyIGJ1ZgogIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHsKICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KQogIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsKICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KQogIH0gZWxzZSB7CiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKQogIH0KCiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UKICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZQogIHJldHVybiBidWYKfQoKZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7CiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7CiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDAKICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKQoKICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7CiAgICAgIHJldHVybiBidWYKICAgIH0KCiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbikKICAgIHJldHVybiBidWYKICB9CgogIGlmIChvYmopIHsKICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhvYmopIHx8ICdsZW5ndGgnIGluIG9iaikgewogICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7CiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKQogICAgICB9CiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iaikKICAgIH0KCiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7CiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKQogICAgfQogIH0KCiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpCn0KCmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkgewogIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlbgogIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKQogIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICsKICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpCiAgfQogIHJldHVybiBsZW5ndGggfCAwCn0KCmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkgewogIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcQogICAgbGVuZ3RoID0gMAogIH0KICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpCn0KCkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7CiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZQp9CgpCdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJykKICB9CgogIGlmIChhID09PSBiKSByZXR1cm4gMAoKICB2YXIgeCA9IGEubGVuZ3RoCiAgdmFyIHkgPSBiLmxlbmd0aAoKICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkgewogICAgaWYgKGFbaV0gIT09IGJbaV0pIHsKICAgICAgeCA9IGFbaV0KICAgICAgeSA9IGJbaV0KICAgICAgYnJlYWsKICAgIH0KICB9CgogIGlmICh4IDwgeSkgcmV0dXJuIC0xCiAgaWYgKHkgPCB4KSByZXR1cm4gMQogIHJldHVybiAwCn0KCkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHsKICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkgewogICAgY2FzZSAnaGV4JzoKICAgIGNhc2UgJ3V0ZjgnOgogICAgY2FzZSAndXRmLTgnOgogICAgY2FzZSAnYXNjaWknOgogICAgY2FzZSAnbGF0aW4xJzoKICAgIGNhc2UgJ2JpbmFyeSc6CiAgICBjYXNlICdiYXNlNjQnOgogICAgY2FzZSAndWNzMic6CiAgICBjYXNlICd1Y3MtMic6CiAgICBjYXNlICd1dGYxNmxlJzoKICAgIGNhc2UgJ3V0Zi0xNmxlJzoKICAgICAgcmV0dXJuIHRydWUKICAgIGRlZmF1bHQ6CiAgICAgIHJldHVybiBmYWxzZQogIH0KfQoKQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7CiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJykKICB9CgogIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgewogICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKQogIH0KCiAgdmFyIGkKICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHsKICAgIGxlbmd0aCA9IDAKICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7CiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aAogICAgfQogIH0KCiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpCiAgdmFyIHBvcyA9IDAKICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkgewogICAgdmFyIGJ1ZiA9IGxpc3RbaV0KICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHsKICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignImxpc3QiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpCiAgICB9CiAgICBidWYuY29weShidWZmZXIsIHBvcykKICAgIHBvcyArPSBidWYubGVuZ3RoCiAgfQogIHJldHVybiBidWZmZXIKfQoKZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykgewogIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkgewogICAgcmV0dXJuIHN0cmluZy5sZW5ndGgKICB9CiAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHN0cmluZykgfHwgaXNBcnJheUJ1ZmZlcihzdHJpbmcpKSB7CiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGgKICB9CiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7CiAgICBzdHJpbmcgPSAnJyArIHN0cmluZwogIH0KCiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGgKICBpZiAobGVuID09PSAwKSByZXR1cm4gMAoKICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb24KICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZQogIGZvciAoOzspIHsKICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgY2FzZSAnYXNjaWknOgogICAgICBjYXNlICdsYXRpbjEnOgogICAgICBjYXNlICdiaW5hcnknOgogICAgICAgIHJldHVybiBsZW4KICAgICAgY2FzZSAndXRmOCc6CiAgICAgIGNhc2UgJ3V0Zi04JzoKICAgICAgY2FzZSB1bmRlZmluZWQ6CiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoCiAgICAgIGNhc2UgJ3VjczInOgogICAgICBjYXNlICd1Y3MtMic6CiAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgcmV0dXJuIGxlbiAqIDIKICAgICAgY2FzZSAnaGV4JzoKICAgICAgICByZXR1cm4gbGVuID4+PiAxCiAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGgKICAgICAgZGVmYXVsdDoKICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOAogICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkKICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWUKICAgIH0KICB9Cn0KQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoCgpmdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7CiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2UKCiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCAidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMiIgc2luY2UgaXQncyBhIHJlYWQtb25seQogIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuCgogIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZAogIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS4KICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLAogIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLgogIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkgewogICAgc3RhcnQgPSAwCiAgfQogIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyCiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy4KICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkgewogICAgcmV0dXJuICcnCiAgfQoKICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHsKICAgIGVuZCA9IHRoaXMubGVuZ3RoCiAgfQoKICBpZiAoZW5kIDw9IDApIHsKICAgIHJldHVybiAnJwogIH0KCiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC4KICBlbmQgPj4+PSAwCiAgc3RhcnQgPj4+PSAwCgogIGlmIChlbmQgPD0gc3RhcnQpIHsKICAgIHJldHVybiAnJwogIH0KCiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCcKCiAgd2hpbGUgKHRydWUpIHsKICAgIHN3aXRjaCAoZW5jb2RpbmcpIHsKICAgICAgY2FzZSAnaGV4JzoKICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCiAgICAgIGNhc2UgJ3V0ZjgnOgogICAgICBjYXNlICd1dGYtOCc6CiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKICAgICAgY2FzZSAnYXNjaWknOgogICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpCgogICAgICBjYXNlICdsYXRpbjEnOgogICAgICBjYXNlICdiaW5hcnknOgogICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKICAgICAgY2FzZSAnYmFzZTY0JzoKICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZCkKCiAgICAgIGNhc2UgJ3VjczInOgogICAgICBjYXNlICd1Y3MtMic6CiAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKQoKICAgICAgZGVmYXVsdDoKICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZykKICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpCiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlCiAgICB9CiAgfQp9CgovLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpCi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmAKLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnQKLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyCi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS4KLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0CkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZQoKZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkgewogIHZhciBpID0gYltuXQogIGJbbl0gPSBiW21dCiAgYlttXSA9IGkKfQoKQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkgewogIHZhciBsZW4gPSB0aGlzLmxlbmd0aAogIGlmIChsZW4gJSAyICE9PSAwKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKQogIH0KICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7CiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKQogIH0KICByZXR1cm4gdGhpcwp9CgpCdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7CiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoCiAgaWYgKGxlbiAlIDQgIT09IDApIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpCiAgfQogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHsKICAgIHN3YXAodGhpcywgaSwgaSArIDMpCiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMikKICB9CiAgcmV0dXJuIHRoaXMKfQoKQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkgewogIHZhciBsZW4gPSB0aGlzLmxlbmd0aAogIGlmIChsZW4gJSA4ICE9PSAwKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKQogIH0KICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7CiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KQogICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpCiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSkKICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KQogIH0KICByZXR1cm4gdGhpcwp9CgpCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkgewogIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aAogIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJwogIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aCkKICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykKfQoKQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpCiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlCiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwCn0KCkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkgewogIHZhciBzdHIgPSAnJwogIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTCiAgaWYgKHRoaXMubGVuZ3RoID4gMCkgewogICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJykKICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICcKICB9CiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPicKfQoKQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJykKICB9CgogIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7CiAgICBzdGFydCA9IDAKICB9CiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7CiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMAogIH0KICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHsKICAgIHRoaXNTdGFydCA9IDAKICB9CiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkgewogICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoCiAgfQoKICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHsKICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKQogIH0KCiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkgewogICAgcmV0dXJuIDAKICB9CiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7CiAgICByZXR1cm4gLTEKICB9CiAgaWYgKHN0YXJ0ID49IGVuZCkgewogICAgcmV0dXJuIDEKICB9CgogIHN0YXJ0ID4+Pj0gMAogIGVuZCA+Pj49IDAKICB0aGlzU3RhcnQgPj4+PSAwCiAgdGhpc0VuZCA+Pj49IDAKCiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDAKCiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0CiAgdmFyIHkgPSBlbmQgLSBzdGFydAogIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KQoKICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCkKICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKQoKICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7CiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHsKICAgICAgeCA9IHRoaXNDb3B5W2ldCiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldCiAgICAgIGJyZWFrCiAgICB9CiAgfQoKICBpZiAoeCA8IHkpIHJldHVybiAtMQogIGlmICh5IDwgeCkgcmV0dXJuIDEKICByZXR1cm4gMAp9CgovLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsCi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuCi8vCi8vIEFyZ3VtZW50czoKLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2gKLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXIKLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyCi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nCi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mCmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikgewogIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaAogIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTEKCiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQKICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7CiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQKICAgIGJ5dGVPZmZzZXQgPSAwCiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikgewogICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmYKICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgewogICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwCiAgfQogIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci4KICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHsKICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sICJmb28iLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXIKICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKQogIH0KCiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXIKICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldAogIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHsKICAgIGlmIChkaXIpIHJldHVybiAtMQogICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDEKICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7CiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMAogICAgZWxzZSByZXR1cm4gLTEKICB9CgogIC8vIE5vcm1hbGl6ZSB2YWwKICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHsKICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpCiAgfQoKICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZgogIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkgewogICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlscwogICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHsKICAgICAgcmV0dXJuIC0xCiAgICB9CiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKQogIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHsKICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XQogICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7CiAgICAgIGlmIChkaXIpIHsKICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KQogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KQogICAgICB9CiAgICB9CiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikKICB9CgogIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpCn0KCmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHsKICB2YXIgaW5kZXhTaXplID0gMQogIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoCiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGgKCiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHsKICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpCiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fAogICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHsKICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7CiAgICAgICAgcmV0dXJuIC0xCiAgICAgIH0KICAgICAgaW5kZXhTaXplID0gMgogICAgICBhcnJMZW5ndGggLz0gMgogICAgICB2YWxMZW5ndGggLz0gMgogICAgICBieXRlT2Zmc2V0IC89IDIKICAgIH0KICB9CgogIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkgewogICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkgewogICAgICByZXR1cm4gYnVmW2ldCiAgICB9IGVsc2UgewogICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKQogICAgfQogIH0KCiAgdmFyIGkKICBpZiAoZGlyKSB7CiAgICB2YXIgZm91bmRJbmRleCA9IC0xCiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHsKICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkgewogICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGkKICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplCiAgICAgIH0gZWxzZSB7CiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4CiAgICAgICAgZm91bmRJbmRleCA9IC0xCiAgICAgIH0KICAgIH0KICB9IGVsc2UgewogICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGgKICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7CiAgICAgIHZhciBmb3VuZCA9IHRydWUKICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykgewogICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHsKICAgICAgICAgIGZvdW5kID0gZmFsc2UKICAgICAgICAgIGJyZWFrCiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGkKICAgIH0KICB9CgogIHJldHVybiAtMQp9CgpCdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHsKICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMQp9CgpCdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7CiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpCn0KCkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgewogIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSkKfQoKZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDAKICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldAogIGlmICghbGVuZ3RoKSB7CiAgICBsZW5ndGggPSByZW1haW5pbmcKICB9IGVsc2UgewogICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aCkKICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHsKICAgICAgbGVuZ3RoID0gcmVtYWluaW5nCiAgICB9CiAgfQoKICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0cwogIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoCiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpCgogIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7CiAgICBsZW5ndGggPSBzdHJMZW4gLyAyCiAgfQogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpCiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGkKICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZAogIH0KICByZXR1cm4gaQp9CgpmdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpCn0KCmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQp9CgpmdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQp9CgpmdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7CiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKQp9CgpmdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHsKICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKQogIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkgewogICAgZW5jb2RpbmcgPSAndXRmOCcKICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoCiAgICBvZmZzZXQgPSAwCiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpCiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykgewogICAgZW5jb2RpbmcgPSBvZmZzZXQKICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoCiAgICBvZmZzZXQgPSAwCiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSkKICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHsKICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHsKICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwCiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4JwogICAgfSBlbHNlIHsKICAgICAgZW5jb2RpbmcgPSBsZW5ndGgKICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkCiAgICB9CiAgfSBlbHNlIHsKICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJwogICAgKQogIH0KCiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0CiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nCgogIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7CiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKQogIH0KCiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCcKCiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2UKICBmb3IgKDs7KSB7CiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7CiAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpCgogICAgICBjYXNlICd1dGY4JzoKICAgICAgY2FzZSAndXRmLTgnOgogICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGNhc2UgJ2FzY2lpJzoKICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQoKICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGUKICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkKCiAgICAgIGNhc2UgJ3VjczInOgogICAgICBjYXNlICd1Y3MtMic6CiAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKQoKICAgICAgZGVmYXVsdDoKICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZykKICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpCiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlCiAgICB9CiAgfQp9CgpCdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7CiAgcmV0dXJuIHsKICAgIHR5cGU6ICdCdWZmZXInLAogICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApCiAgfQp9CgpmdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkgewogICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZikKICB9IGVsc2UgewogICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSkKICB9Cn0KCmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKQogIHZhciByZXMgPSBbXQoKICB2YXIgaSA9IHN0YXJ0CiAgd2hpbGUgKGkgPCBlbmQpIHsKICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV0KICAgIHZhciBjb2RlUG9pbnQgPSBudWxsCiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDQKICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzCiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMgogICAgICA6IDEKCiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7CiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnQKCiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkgewogICAgICAgIGNhc2UgMToKICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7CiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZQogICAgICAgICAgfQogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlIDI6CiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXQogICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHsKICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpCiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RikgewogICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlIDM6CiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXQogICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXQogICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7CiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKQogICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7CiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludAogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBicmVhawogICAgICAgIGNhc2UgNDoKICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdCiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdCiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXQogICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHsKICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpCiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkgewogICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICB9CiAgICB9CgogICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkgewogICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhCiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGUKICAgICAgY29kZVBvaW50ID0gMHhGRkZECiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxCiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikgewogICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKQogICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMAogICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApCiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGCiAgICB9CgogICAgcmVzLnB1c2goY29kZVBvaW50KQogICAgaSArPSBieXRlc1BlclNlcXVlbmNlCiAgfQoKICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcykKfQoKLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoCi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy4KLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eQp2YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDAKCmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykgewogIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aAogIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHsKICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKQogIH0KCiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCAiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkIi4KICB2YXIgcmVzID0gJycKICB2YXIgaSA9IDAKICB3aGlsZSAoaSA8IGxlbikgewogICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoCiAgICAgIFN0cmluZywKICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKQogICAgKQogIH0KICByZXR1cm4gcmVzCn0KCmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIHZhciByZXQgPSAnJwogIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCkKCiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpCiAgfQogIHJldHVybiByZXQKfQoKZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkgewogIHZhciByZXQgPSAnJwogIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCkKCiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSkKICB9CiAgcmV0dXJuIHJldAp9CgpmdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7CiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGgKCiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMAogIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW4KCiAgdmFyIG91dCA9ICcnCiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgIG91dCArPSB0b0hleChidWZbaV0pCiAgfQogIHJldHVybiBvdXQKfQoKZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHsKICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCkKICB2YXIgcmVzID0gJycKICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7CiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKQogIH0KICByZXR1cm4gcmVzCn0KCkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkgewogIHZhciBsZW4gPSB0aGlzLmxlbmd0aAogIHN0YXJ0ID0gfn5zdGFydAogIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmQKCiAgaWYgKHN0YXJ0IDwgMCkgewogICAgc3RhcnQgKz0gbGVuCiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDAKICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7CiAgICBzdGFydCA9IGxlbgogIH0KCiAgaWYgKGVuZCA8IDApIHsKICAgIGVuZCArPSBsZW4KICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwCiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHsKICAgIGVuZCA9IGxlbgogIH0KCiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydAoKICB2YXIgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKQogIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlCiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGUKICByZXR1cm4gbmV3QnVmCn0KCi8qCiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLgogKi8KZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHsKICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKQogIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJykKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCkKCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XQogIHZhciBtdWwgPSAxCiAgdmFyIGkgPSAwCiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsCiAgfQoKICByZXR1cm4gdmFsCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIHsKICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpCiAgfQoKICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdCiAgdmFyIG11bCA9IDEKICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWwKICB9CgogIHJldHVybiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKQogIHJldHVybiB0aGlzW29mZnNldF0KfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKQogIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpCiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKCiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8CiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHwKICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArCiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKQp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCgogIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArCiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHwKICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHwKICAgIHRoaXNbb2Zmc2V0ICsgM10pCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKQoKICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdCiAgdmFyIG11bCA9IDEKICB2YXIgaSA9IDAKICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkgewogICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWwKICB9CiAgbXVsICo9IDB4ODAKCiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkKCiAgcmV0dXJuIHZhbAp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCkKCiAgdmFyIGkgPSBieXRlTGVuZ3RoCiAgdmFyIG11bCA9IDEKICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldCiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsCiAgfQogIG11bCAqPSAweDgwCgogIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpCgogIHJldHVybiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCkKICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pCiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpCiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpCiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbAp9CgpCdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKQogIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KQogIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWwKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKCiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHwKICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHwKICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8CiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKCiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHwKICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8CiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8CiAgICAodGhpc1tvZmZzZXQgKyAzXSkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCkKICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpCn0KCkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkgewogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpCiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKQogIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOCkKfQoKQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHsKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKQogIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpCn0KCmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHsKICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCciYnVmZmVyIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJykKICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKQogIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJykKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxCiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCkKICB9CgogIHZhciBtdWwgPSAxCiAgdmFyIGkgPSAwCiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGCiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRgogIH0KCiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxCiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCkKICB9CgogIHZhciBpID0gYnl0ZUxlbmd0aCAtIDEKICB2YXIgbXVsID0gMQogIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkYKICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHsKICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRgogIH0KCiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApCiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgMQp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkKICByZXR1cm4gb2Zmc2V0ICsgMgp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgMgp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMCkKICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCkKICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNikKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDQKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApCiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNCkKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNikKICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KQogIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKQogIHJldHVybiBvZmZzZXQgKyA0Cn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSB7CiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSkKCiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCkKICB9CgogIHZhciBpID0gMAogIHZhciBtdWwgPSAxCiAgdmFyIHN1YiA9IDAKICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkYKICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkgewogICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHsKICAgICAgc3ViID0gMQogICAgfQogICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRgogIH0KCiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGgKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIHsKICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKQoKICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KQogIH0KCiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMQogIHZhciBtdWwgPSAxCiAgdmFyIHN1YiA9IDAKICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGCiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7CiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkgewogICAgICBzdWIgPSAxCiAgICB9CiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGCiAgfQoKICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKQogIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgcmV0dXJuIG9mZnNldCArIDEKfQoKQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgdmFsdWUgPSArdmFsdWUKICBvZmZzZXQgPSBvZmZzZXQgPj4+IDAKICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApCiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZikKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KQogIHJldHVybiBvZmZzZXQgKyAyCn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgMgp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNikKICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNCkKICByZXR1cm4gb2Zmc2V0ICsgNAp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKQogIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMQogIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpCiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpCiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCkKICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZikKICByZXR1cm4gb2Zmc2V0ICsgNAp9CgpmdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikgewogIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJykKICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpCn0KCmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkgewogIHZhbHVlID0gK3ZhbHVlCiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwCiAgaWYgKCFub0Fzc2VydCkgewogICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpCiAgfQogIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KQogIHJldHVybiBvZmZzZXQgKyA0Cn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KQp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHsKICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpCn0KCmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHsKICB2YWx1ZSA9ICt2YWx1ZQogIG9mZnNldCA9IG9mZnNldCA+Pj4gMAogIGlmICghbm9Bc3NlcnQpIHsKICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpCiAgfQogIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KQogIHJldHVybiBvZmZzZXQgKyA4Cn0KCkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7CiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KQp9CgpCdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkgewogIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpCn0KCi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aCkKQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkgewogIGlmICghc3RhcnQpIHN0YXJ0ID0gMAogIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGgKICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoCiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwCiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0CgogIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZQogIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMAogIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMAoKICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zCiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKQogIH0KICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpCiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpCgogIC8vIEFyZSB3ZSBvb2I/CiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aAogIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkgewogICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnQKICB9CgogIHZhciBsZW4gPSBlbmQgLSBzdGFydAogIHZhciBpCgogIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkgewogICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kCiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkgewogICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XQogICAgfQogIH0gZWxzZSBpZiAobGVuIDwgMTAwMCkgewogICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydAogICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7CiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdCiAgICB9CiAgfSBlbHNlIHsKICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKAogICAgICB0YXJnZXQsCiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwKICAgICAgdGFyZ2V0U3RhcnQKICAgICkKICB9CgogIHJldHVybiBsZW4KfQoKLy8gVXNhZ2U6Ci8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKQovLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSkKLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pCkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHsKICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOgogIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykgewogICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHsKICAgICAgZW5jb2RpbmcgPSBzdGFydAogICAgICBzdGFydCA9IDAKICAgICAgZW5kID0gdGhpcy5sZW5ndGgKICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHsKICAgICAgZW5jb2RpbmcgPSBlbmQKICAgICAgZW5kID0gdGhpcy5sZW5ndGgKICAgIH0KICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7CiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMCkKICAgICAgaWYgKGNvZGUgPCAyNTYpIHsKICAgICAgICB2YWwgPSBjb2RlCiAgICAgIH0KICAgIH0KICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHsKICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpCiAgICB9CiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZykKICAgIH0KICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7CiAgICB2YWwgPSB2YWwgJiAyNTUKICB9CgogIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LgogIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkgewogICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpCiAgfQoKICBpZiAoZW5kIDw9IHN0YXJ0KSB7CiAgICByZXR1cm4gdGhpcwogIH0KCiAgc3RhcnQgPSBzdGFydCA+Pj4gMAogIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDAKCiAgaWYgKCF2YWwpIHZhbCA9IDAKCiAgdmFyIGkKICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHsKICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHsKICAgICAgdGhpc1tpXSA9IHZhbAogICAgfQogIH0gZWxzZSB7CiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKQogICAgICA/IHZhbAogICAgICA6IG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykKICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGgKICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7CiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dCiAgICB9CiAgfQoKICByZXR1cm4gdGhpcwp9CgovLyBIRUxQRVIgRlVOQ1RJT05TCi8vID09PT09PT09PT09PT09PT0KCnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2cKCmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHsKICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXG4gYW5kIFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90CiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJykKICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnCiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJycKICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3QKICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHsKICAgIHN0ciA9IHN0ciArICc9JwogIH0KICByZXR1cm4gc3RyCn0KCmZ1bmN0aW9uIHRvSGV4IChuKSB7CiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpCiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpCn0KCmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7CiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eQogIHZhciBjb2RlUG9pbnQKICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aAogIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbAogIHZhciBieXRlcyA9IFtdCgogIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpCgogICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudAogICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHsKICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWQKICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7CiAgICAgICAgLy8gbm8gbGVhZCB5ZXQKICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7CiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsCiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCkKICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7CiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkCiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCkKICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgfQoKICAgICAgICAvLyB2YWxpZCBsZWFkCiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludAoKICAgICAgICBjb250aW51ZQogICAgICB9CgogICAgICAvLyAyIGxlYWRzIGluIGEgcm93CiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHsKICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCkKICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50CiAgICAgICAgY29udGludWUKICAgICAgfQoKICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXIKICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMAogICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7CiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWQKICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpCiAgICB9CgogICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGwKCiAgICAvLyBlbmNvZGUgdXRmOAogICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHsKICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrCiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KQogICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkgewogICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWsKICAgICAgYnl0ZXMucHVzaCgKICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCwKICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MAogICAgICApCiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHsKICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrCiAgICAgIGJ5dGVzLnB1c2goCiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsCiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLAogICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwCiAgICAgICkKICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHsKICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrCiAgICAgIGJ5dGVzLnB1c2goCiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLAogICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCwKICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsCiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODAKICAgICAgKQogICAgfSBlbHNlIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKQogICAgfQogIH0KCiAgcmV0dXJuIGJ5dGVzCn0KCmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7CiAgdmFyIGJ5dGVBcnJheSA9IFtdCiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLgogICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKQogIH0KICByZXR1cm4gYnl0ZUFycmF5Cn0KCmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7CiAgdmFyIGMsIGhpLCBsbwogIHZhciBieXRlQXJyYXkgPSBbXQogIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7CiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWsKCiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSkKICAgIGhpID0gYyA+PiA4CiAgICBsbyA9IGMgJSAyNTYKICAgIGJ5dGVBcnJheS5wdXNoKGxvKQogICAgYnl0ZUFycmF5LnB1c2goaGkpCiAgfQoKICByZXR1cm4gYnl0ZUFycmF5Cn0KCmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikgewogIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSkKfQoKZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVhawogICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldCiAgfQogIHJldHVybiBpCn0KCi8vIEFycmF5QnVmZmVycyBmcm9tIGFub3RoZXIgY29udGV4dCAoaS5lLiBhbiBpZnJhbWUpIGRvIG5vdCBwYXNzIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sKLy8gYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NgpmdW5jdGlvbiBpc0FycmF5QnVmZmVyIChvYmopIHsKICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwKICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJgogICAgICB0eXBlb2Ygb2JqLmJ5dGVMZW5ndGggPT09ICdudW1iZXInKQp9CgovLyBOb2RlIDAuMTAgc3VwcG9ydHMgYEFycmF5QnVmZmVyYCBidXQgbGFja3MgYEFycmF5QnVmZmVyLmlzVmlld2AKZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcgKG9iaikgewogIHJldHVybiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikKfQoKZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikgewogIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZQp9Cgp9LHsiYmFzZTY0LWpzIjoxNywiaWVlZTc1NCI6MTAxfV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduJyk7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5hc3NpZ247Cgp9LHsiLi4vLi4vbW9kdWxlcy9fY29yZSI6MzMsIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5hc3NpZ24iOjg3fV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlJyk7CnZhciAkT2JqZWN0ID0gX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdDsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkgewogIHJldHVybiAkT2JqZWN0LmNyZWF0ZShQLCBEKTsKfTsKCn0seyIuLi8uLi9tb2R1bGVzL19jb3JlIjozMywiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZSI6ODh9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5kZWZpbmUtcHJvcGVydHknKTsKdmFyICRPYmplY3QgPSBfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0Owptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpIHsKICByZXR1cm4gJE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKTsKfTsKCn0seyIuLi8uLi9tb2R1bGVzL19jb3JlIjozMywiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eSI6ODl9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9fY29yZScpLk9iamVjdC5nZXRQcm90b3R5cGVPZjsKCn0seyIuLi8uLi9tb2R1bGVzL19jb3JlIjozMywiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1wcm90b3R5cGUtb2YiOjkwfV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuLi8uLi9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZicpOwptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7Cgp9LHsiLi4vLi4vbW9kdWxlcy9fY29yZSI6MzMsIi4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mIjo5MX1dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYuc3ltYm9sJyk7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLmFzeW5jLWl0ZXJhdG9yJyk7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlJyk7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDsKCn0seyIuLi8uLi9tb2R1bGVzL19jb3JlIjozMywiLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LnRvLXN0cmluZyI6OTIsIi4uLy4uL21vZHVsZXMvZXM2LnN5bWJvbCI6OTQsIi4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvciI6OTUsIi4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlIjo5Nn1dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi4vLi4vbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yJyk7Cl9kZXJlcV8oJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpOwptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4uLy4uL21vZHVsZXMvX3drcy1leHQnKS5mKCdpdGVyYXRvcicpOwoKfSx7Ii4uLy4uL21vZHVsZXMvX3drcy1leHQiOjg0LCIuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IiOjkzLCIuLi8uLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUiOjk3fV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIGlmICh0eXBlb2YgaXQgIT0gJ2Z1bmN0aW9uJykgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYSBmdW5jdGlvbiEnKTsKICByZXR1cm4gaXQ7Cn07Cgp9LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9OwoKfSx7fV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgaXNPYmplY3QgPSBfZGVyZXFfKCcuL19pcy1vYmplY3QnKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpOwogIHJldHVybiBpdDsKfTsKCn0seyIuL19pcy1vYmplY3QiOjQ5fV0sMzE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBmYWxzZSAtPiBBcnJheSNpbmRleE9mCi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzCnZhciB0b0lPYmplY3QgPSBfZGVyZXFfKCcuL190by1pb2JqZWN0Jyk7CnZhciB0b0xlbmd0aCA9IF9kZXJlcV8oJy4vX3RvLWxlbmd0aCcpOwp2YXIgdG9BYnNvbHV0ZUluZGV4ID0gX2RlcmVxXygnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHsKICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBlbCwgZnJvbUluZGV4KSB7CiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7CiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpOwogICAgdmFyIGluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGZyb21JbmRleCwgbGVuZ3RoKTsKICAgIHZhciB2YWx1ZTsKICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG0KICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmUKICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7CiAgICAgIHZhbHVlID0gT1tpbmRleCsrXTsKICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZQogICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlOwogICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdAogICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSBpZiAoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgewogICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDsKICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTsKICB9Owp9OwoKfSx7Ii4vX3RvLWFic29sdXRlLWluZGV4Ijo3NiwiLi9fdG8taW9iamVjdCI6NzgsIi4vX3RvLWxlbmd0aCI6Nzl9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nOwoKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpOwp9OwoKfSx7fV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgY29yZSA9IG1vZHVsZS5leHBvcnRzID0geyB2ZXJzaW9uOiAnMi41LjMnIH07CmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmCgp9LHt9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZwp2YXIgYUZ1bmN0aW9uID0gX2RlcmVxXygnLi9fYS1mdW5jdGlvbicpOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7CiAgYUZ1bmN0aW9uKGZuKTsKICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47CiAgc3dpdGNoIChsZW5ndGgpIHsKICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7CiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpOwogICAgfTsKICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7CiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpOwogICAgfTsKICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7CiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpOwogICAgfTsKICB9CiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7CiAgICByZXR1cm4gZm4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTsKICB9Owp9OwoKfSx7Ii4vX2EtZnVuY3Rpb24iOjI4fV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KQptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcigiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gICIgKyBpdCk7CiAgcmV0dXJuIGl0Owp9OwoKfSx7fV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5Cm1vZHVsZS5leHBvcnRzID0gIV9kZXJlcV8oJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkgewogIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3Owp9KTsKCn0seyIuL19mYWlscyI6NDF9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBpc09iamVjdCA9IF9kZXJlcV8oJy4vX2lzLW9iamVjdCcpOwp2YXIgZG9jdW1lbnQgPSBfZGVyZXFfKCcuL19nbG9iYWwnKS5kb2N1bWVudDsKLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFCnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9Owp9OwoKfSx7Ii4vX2dsb2JhbCI6NDIsIi4vX2lzLW9iamVjdCI6NDl9XSwzODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIElFIDgtIGRvbid0IGVudW0gYnVnIGtleXMKbW9kdWxlLmV4cG9ydHMgPSAoCiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZicKKS5zcGxpdCgnLCcpOwoKfSx7fV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9scwp2YXIgZ2V0S2V5cyA9IF9kZXJlcV8oJy4vX29iamVjdC1rZXlzJyk7CnZhciBnT1BTID0gX2RlcmVxXygnLi9fb2JqZWN0LWdvcHMnKTsKdmFyIHBJRSA9IF9kZXJlcV8oJy4vX29iamVjdC1waWUnKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICB2YXIgcmVzdWx0ID0gZ2V0S2V5cyhpdCk7CiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7CiAgaWYgKGdldFN5bWJvbHMpIHsKICAgIHZhciBzeW1ib2xzID0gZ2V0U3ltYm9scyhpdCk7CiAgICB2YXIgaXNFbnVtID0gcElFLmY7CiAgICB2YXIgaSA9IDA7CiAgICB2YXIga2V5OwogICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpOwogIH0gcmV0dXJuIHJlc3VsdDsKfTsKCn0seyIuL19vYmplY3QtZ29wcyI6NjMsIi4vX29iamVjdC1rZXlzIjo2NiwiLi9fb2JqZWN0LXBpZSI6Njd9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBnbG9iYWwgPSBfZGVyZXFfKCcuL19nbG9iYWwnKTsKdmFyIGNvcmUgPSBfZGVyZXFfKCcuL19jb3JlJyk7CnZhciBjdHggPSBfZGVyZXFfKCcuL19jdHgnKTsKdmFyIGhpZGUgPSBfZGVyZXFfKCcuL19oaWRlJyk7CnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJzsKCnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkgewogIHZhciBJU19GT1JDRUQgPSB0eXBlICYgJGV4cG9ydC5GOwogIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HOwogIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TOwogIHZhciBJU19QUk9UTyA9IHR5cGUgJiAkZXhwb3J0LlA7CiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5COwogIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVzsKICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pOwogIHZhciBleHBQcm90byA9IGV4cG9ydHNbUFJPVE9UWVBFXTsKICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTsKICB2YXIga2V5LCBvd24sIG91dDsKICBpZiAoSVNfR0xPQkFMKSBzb3VyY2UgPSBuYW1lOwogIGZvciAoa2V5IGluIHNvdXJjZSkgewogICAgLy8gY29udGFpbnMgaW4gbmF0aXZlCiAgICBvd24gPSAhSVNfRk9SQ0VEICYmIHRhcmdldCAmJiB0YXJnZXRba2V5XSAhPT0gdW5kZWZpbmVkOwogICAgaWYgKG93biAmJiBrZXkgaW4gZXhwb3J0cykgY29udGludWU7CiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZAogICAgb3V0ID0gb3duID8gdGFyZ2V0W2tleV0gOiBzb3VyY2Vba2V5XTsKICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlcwogICAgZXhwb3J0c1trZXldID0gSVNfR0xPQkFMICYmIHR5cGVvZiB0YXJnZXRba2V5XSAhPSAnZnVuY3Rpb24nID8gc291cmNlW2tleV0KICAgIC8vIGJpbmQgdGltZXJzIHRvIGdsb2JhbCBmb3IgY2FsbCBmcm9tIGV4cG9ydCBjb250ZXh0CiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKQogICAgLy8gd3JhcCBnbG9iYWwgY29uc3RydWN0b3JzIGZvciBwcmV2ZW50IGNoYW5nZSB0aGVtIGluIGxpYnJhcnkKICAgIDogSVNfV1JBUCAmJiB0YXJnZXRba2V5XSA9PSBvdXQgPyAoZnVuY3Rpb24gKEMpIHsKICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykgewogICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQykgewogICAgICAgICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7CiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7CiAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIG5ldyBDKGEpOwogICAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQyhhLCBiKTsKICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpOwogICAgICAgIH0gcmV0dXJuIEMuYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgfTsKICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdOwogICAgICByZXR1cm4gRjsKICAgIC8vIG1ha2Ugc3RhdGljIHZlcnNpb25zIGZvciBwcm90b3R5cGUgbWV0aG9kcwogICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0OwogICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLm1ldGhvZHMuJU5BTUUlCiAgICBpZiAoSVNfUFJPVE8pIHsKICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0OwogICAgICAvLyBleHBvcnQgcHJvdG8gbWV0aG9kcyB0byBjb3JlLiVDT05TVFJVQ1RPUiUucHJvdG90eXBlLiVOQU1FJQogICAgICBpZiAodHlwZSAmICRleHBvcnQuUiAmJiBleHBQcm90byAmJiAhZXhwUHJvdG9ba2V5XSkgaGlkZShleHBQcm90bywga2V5LCBvdXQpOwogICAgfQogIH0KfTsKLy8gdHlwZSBiaXRtYXAKJGV4cG9ydC5GID0gMTsgICAvLyBmb3JjZWQKJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWwKJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWMKJGV4cG9ydC5QID0gODsgICAvLyBwcm90bwokZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmQKJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwCiRleHBvcnQuVSA9IDY0OyAgLy8gc2FmZQokZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWAKbW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0OwoKfSx7Ii4vX2NvcmUiOjMzLCIuL19jdHgiOjM0LCIuL19nbG9iYWwiOjQyLCIuL19oaWRlIjo0NH1dLDQxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykgewogIHRyeSB7CiAgICByZXR1cm4gISFleGVjKCk7CiAgfSBjYXRjaCAoZSkgewogICAgcmV0dXJuIHRydWU7CiAgfQp9OwoKfSx7fV0sNDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOAp2YXIgZ2xvYmFsID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGgKICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZgogIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYwogIDogRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTsKaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZgoKfSx7fV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkgewogIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpOwp9OwoKfSx7fV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgZFAgPSBfZGVyZXFfKCcuL19vYmplY3QtZHAnKTsKdmFyIGNyZWF0ZURlc2MgPSBfZGVyZXFfKCcuL19wcm9wZXJ0eS1kZXNjJyk7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9fZGVzY3JpcHRvcnMnKSA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHsKICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpOwp9IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkgewogIG9iamVjdFtrZXldID0gdmFsdWU7CiAgcmV0dXJuIG9iamVjdDsKfTsKCn0seyIuL19kZXNjcmlwdG9ycyI6MzYsIi4vX29iamVjdC1kcCI6NTgsIi4vX3Byb3BlcnR5LWRlc2MiOjY5fV0sNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgZG9jdW1lbnQgPSBfZGVyZXFfKCcuL19nbG9iYWwnKS5kb2N1bWVudDsKbW9kdWxlLmV4cG9ydHMgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7Cgp9LHsiLi9fZ2xvYmFsIjo0Mn1dLDQ2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSAhX2RlcmVxXygnLi9fZGVzY3JpcHRvcnMnKSAmJiAhX2RlcmVxXygnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZGVyZXFfKCcuL19kb20tY3JlYXRlJykoJ2RpdicpLCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNzsKfSk7Cgp9LHsiLi9fZGVzY3JpcHRvcnMiOjM2LCIuL19kb20tY3JlYXRlIjozNywiLi9fZmFpbHMiOjQxfV0sNDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5ncwp2YXIgY29mID0gX2RlcmVxXygnLi9fY29mJyk7Ci8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMKbW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTsKfTsKCn0seyIuL19jb2YiOjMyfV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyA3LjIuMiBJc0FycmF5KGFyZ3VtZW50KQp2YXIgY29mID0gX2RlcmVxXygnLi9fY29mJyk7Cm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykgewogIHJldHVybiBjb2YoYXJnKSA9PSAnQXJyYXknOwp9OwoKfSx7Ii4vX2NvZiI6MzJ9XSw0OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJzsKfTsKCn0se31dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwp2YXIgY3JlYXRlID0gX2RlcmVxXygnLi9fb2JqZWN0LWNyZWF0ZScpOwp2YXIgZGVzY3JpcHRvciA9IF9kZXJlcV8oJy4vX3Byb3BlcnR5LWRlc2MnKTsKdmFyIHNldFRvU3RyaW5nVGFnID0gX2RlcmVxXygnLi9fc2V0LXRvLXN0cmluZy10YWcnKTsKdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307CgovLyAyNS4xLjIuMS4xICVJdGVyYXRvclByb3RvdHlwZSVbQEBpdGVyYXRvcl0oKQpfZGVyZXFfKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIF9kZXJlcV8oJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsKCm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7CiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7CiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7Cn07Cgp9LHsiLi9faGlkZSI6NDQsIi4vX29iamVjdC1jcmVhdGUiOjU3LCIuL19wcm9wZXJ0eS1kZXNjIjo2OSwiLi9fc2V0LXRvLXN0cmluZy10YWciOjcyLCIuL193a3MiOjg1fV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7CnZhciBMSUJSQVJZID0gX2RlcmVxXygnLi9fbGlicmFyeScpOwp2YXIgJGV4cG9ydCA9IF9kZXJlcV8oJy4vX2V4cG9ydCcpOwp2YXIgcmVkZWZpbmUgPSBfZGVyZXFfKCcuL19yZWRlZmluZScpOwp2YXIgaGlkZSA9IF9kZXJlcV8oJy4vX2hpZGUnKTsKdmFyIGhhcyA9IF9kZXJlcV8oJy4vX2hhcycpOwp2YXIgSXRlcmF0b3JzID0gX2RlcmVxXygnLi9faXRlcmF0b3JzJyk7CnZhciAkaXRlckNyZWF0ZSA9IF9kZXJlcV8oJy4vX2l0ZXItY3JlYXRlJyk7CnZhciBzZXRUb1N0cmluZ1RhZyA9IF9kZXJlcV8oJy4vX3NldC10by1zdHJpbmctdGFnJyk7CnZhciBnZXRQcm90b3R5cGVPZiA9IF9kZXJlcV8oJy4vX29iamVjdC1ncG8nKTsKdmFyIElURVJBVE9SID0gX2RlcmVxXygnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7CnZhciBCVUdHWSA9ICEoW10ua2V5cyAmJiAnbmV4dCcgaW4gW10ua2V5cygpKTsgLy8gU2FmYXJpIGhhcyBidWdneSBpdGVyYXRvcnMgdy9vIGBuZXh0YAp2YXIgRkZfSVRFUkFUT1IgPSAnQEBpdGVyYXRvcic7CnZhciBLRVlTID0gJ2tleXMnOwp2YXIgVkFMVUVTID0gJ3ZhbHVlcyc7Cgp2YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07Cgptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHsKICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7CiAgdmFyIGdldE1ldGhvZCA9IGZ1bmN0aW9uIChraW5kKSB7CiAgICBpZiAoIUJVR0dZICYmIGtpbmQgaW4gcHJvdG8pIHJldHVybiBwcm90b1traW5kXTsKICAgIHN3aXRjaCAoa2luZCkgewogICAgICBjYXNlIEtFWVM6IHJldHVybiBmdW5jdGlvbiBrZXlzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9OwogICAgICBjYXNlIFZBTFVFUzogcmV0dXJuIGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTsKICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07CiAgfTsKICB2YXIgVEFHID0gTkFNRSArICcgSXRlcmF0b3InOwogIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7CiAgdmFyIFZBTFVFU19CVUcgPSBmYWxzZTsKICB2YXIgcHJvdG8gPSBCYXNlLnByb3RvdHlwZTsKICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTsKICB2YXIgJGRlZmF1bHQgPSAoIUJVR0dZICYmICRuYXRpdmUpIHx8IGdldE1ldGhvZChERUZBVUxUKTsKICB2YXIgJGVudHJpZXMgPSBERUZBVUxUID8gIURFRl9WQUxVRVMgPyAkZGVmYXVsdCA6IGdldE1ldGhvZCgnZW50cmllcycpIDogdW5kZWZpbmVkOwogIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTsKICB2YXIgbWV0aG9kcywga2V5LCBJdGVyYXRvclByb3RvdHlwZTsKICAvLyBGaXggbmF0aXZlCiAgaWYgKCRhbnlOYXRpdmUpIHsKICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoJGFueU5hdGl2ZS5jYWxsKG5ldyBCYXNlKCkpKTsKICAgIGlmIChJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7CiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnMKICAgICAgc2V0VG9TdHJpbmdUYWcoSXRlcmF0b3JQcm90b3R5cGUsIFRBRywgdHJ1ZSk7CiAgICAgIC8vIGZpeCBmb3Igc29tZSBvbGQgZW5naW5lcwogICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7CiAgICB9CiAgfQogIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkYKICBpZiAoREVGX1ZBTFVFUyAmJiAkbmF0aXZlICYmICRuYXRpdmUubmFtZSAhPT0gVkFMVUVTKSB7CiAgICBWQUxVRVNfQlVHID0gdHJ1ZTsKICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9OwogIH0KICAvLyBEZWZpbmUgaXRlcmF0b3IKICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHsKICAgIGhpZGUocHJvdG8sIElURVJBVE9SLCAkZGVmYXVsdCk7CiAgfQogIC8vIFBsdWcgZm9yIGxpYnJhcnkKICBJdGVyYXRvcnNbTkFNRV0gPSAkZGVmYXVsdDsKICBJdGVyYXRvcnNbVEFHXSA9IHJldHVyblRoaXM7CiAgaWYgKERFRkFVTFQpIHsKICAgIG1ldGhvZHMgPSB7CiAgICAgIHZhbHVlczogREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKFZBTFVFUyksCiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLAogICAgICBlbnRyaWVzOiAkZW50cmllcwogICAgfTsKICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHsKICAgICAgaWYgKCEoa2V5IGluIHByb3RvKSkgcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTsKICAgIH0gZWxzZSAkZXhwb3J0KCRleHBvcnQuUCArICRleHBvcnQuRiAqIChCVUdHWSB8fCBWQUxVRVNfQlVHKSwgTkFNRSwgbWV0aG9kcyk7CiAgfQogIHJldHVybiBtZXRob2RzOwp9OwoKfSx7Ii4vX2V4cG9ydCI6NDAsIi4vX2hhcyI6NDMsIi4vX2hpZGUiOjQ0LCIuL19pdGVyLWNyZWF0ZSI6NTAsIi4vX2l0ZXJhdG9ycyI6NTMsIi4vX2xpYnJhcnkiOjU0LCIuL19vYmplY3QtZ3BvIjo2NCwiLi9fcmVkZWZpbmUiOjcwLCIuL19zZXQtdG8tc3RyaW5nLXRhZyI6NzIsIi4vX3drcyI6ODV9XSw1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7CiAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBkb25lOiAhIWRvbmUgfTsKfTsKCn0se31dLDUzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB7fTsKCn0se31dLDU0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSB0cnVlOwoKfSx7fV0sNTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgTUVUQSA9IF9kZXJlcV8oJy4vX3VpZCcpKCdtZXRhJyk7CnZhciBpc09iamVjdCA9IF9kZXJlcV8oJy4vX2lzLW9iamVjdCcpOwp2YXIgaGFzID0gX2RlcmVxXygnLi9faGFzJyk7CnZhciBzZXREZXNjID0gX2RlcmVxXygnLi9fb2JqZWN0LWRwJykuZjsKdmFyIGlkID0gMDsKdmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkgewogIHJldHVybiB0cnVlOwp9Owp2YXIgRlJFRVpFID0gIV9kZXJlcV8oJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkgewogIHJldHVybiBpc0V4dGVuc2libGUoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KSk7Cn0pOwp2YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkgewogIHNldERlc2MoaXQsIE1FVEEsIHsgdmFsdWU6IHsKICAgIGk6ICdPJyArICsraWQsIC8vIG9iamVjdCBJRAogICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHMKICB9IH0pOwp9Owp2YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7CiAgLy8gcmV0dXJuIHByaW1pdGl2ZSB3aXRoIHByZWZpeAogIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnID8gaXQgOiAodHlwZW9mIGl0ID09ICdzdHJpbmcnID8gJ1MnIDogJ1AnKSArIGl0OwogIGlmICghaGFzKGl0LCBNRVRBKSkgewogICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3QKICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuICdGJzsKICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhCiAgICBpZiAoIWNyZWF0ZSkgcmV0dXJuICdFJzsKICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhCiAgICBzZXRNZXRhKGl0KTsKICAvLyByZXR1cm4gb2JqZWN0IElECiAgfSByZXR1cm4gaXRbTUVUQV0uaTsKfTsKdmFyIGdldFdlYWsgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkgewogIGlmICghaGFzKGl0LCBNRVRBKSkgewogICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3QKICAgIGlmICghaXNFeHRlbnNpYmxlKGl0KSkgcmV0dXJuIHRydWU7CiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YQogICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTsKICAgIC8vIGFkZCBtaXNzaW5nIG1ldGFkYXRhCiAgICBzZXRNZXRhKGl0KTsKICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEcwogIH0gcmV0dXJuIGl0W01FVEFdLnc7Cn07Ci8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZwp2YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHsKICBpZiAoRlJFRVpFICYmIG1ldGEuTkVFRCAmJiBpc0V4dGVuc2libGUoaXQpICYmICFoYXMoaXQsIE1FVEEpKSBzZXRNZXRhKGl0KTsKICByZXR1cm4gaXQ7Cn07CnZhciBtZXRhID0gbW9kdWxlLmV4cG9ydHMgPSB7CiAgS0VZOiBNRVRBLAogIE5FRUQ6IGZhbHNlLAogIGZhc3RLZXk6IGZhc3RLZXksCiAgZ2V0V2VhazogZ2V0V2VhaywKICBvbkZyZWV6ZTogb25GcmVlemUKfTsKCn0seyIuL19mYWlscyI6NDEsIi4vX2hhcyI6NDMsIi4vX2lzLW9iamVjdCI6NDksIi4vX29iamVjdC1kcCI6NTgsIi4vX3VpZCI6ODJ9XSw1NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKQp2YXIgZ2V0S2V5cyA9IF9kZXJlcV8oJy4vX29iamVjdC1rZXlzJyk7CnZhciBnT1BTID0gX2RlcmVxXygnLi9fb2JqZWN0LWdvcHMnKTsKdmFyIHBJRSA9IF9kZXJlcV8oJy4vX29iamVjdC1waWUnKTsKdmFyIHRvT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8tb2JqZWN0Jyk7CnZhciBJT2JqZWN0ID0gX2RlcmVxXygnLi9faW9iamVjdCcpOwp2YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247CgovLyBzaG91bGQgd29yayB3aXRoIHN5bWJvbHMgYW5kIHNob3VsZCBoYXZlIGRldGVybWluaXN0aWMgcHJvcGVydHkgb3JkZXIgKFY4IGJ1ZykKbW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCBfZGVyZXFfKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHsKICB2YXIgQSA9IHt9OwogIHZhciBCID0ge307CiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmCiAgdmFyIFMgPSBTeW1ib2woKTsKICB2YXIgSyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7CiAgQVtTXSA9IDc7CiAgSy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoaykgeyBCW2tdID0gazsgfSk7CiAgcmV0dXJuICRhc3NpZ24oe30sIEEpW1NdICE9IDcgfHwgT2JqZWN0LmtleXMoJGFzc2lnbih7fSwgQikpLmpvaW4oJycpICE9IEs7Cn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnMKICB2YXIgVCA9IHRvT2JqZWN0KHRhcmdldCk7CiAgdmFyIGFMZW4gPSBhcmd1bWVudHMubGVuZ3RoOwogIHZhciBpbmRleCA9IDE7CiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7CiAgdmFyIGlzRW51bSA9IHBJRS5mOwogIHdoaWxlIChhTGVuID4gaW5kZXgpIHsKICAgIHZhciBTID0gSU9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pOwogICAgdmFyIGtleXMgPSBnZXRTeW1ib2xzID8gZ2V0S2V5cyhTKS5jb25jYXQoZ2V0U3ltYm9scyhTKSkgOiBnZXRLZXlzKFMpOwogICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoOwogICAgdmFyIGogPSAwOwogICAgdmFyIGtleTsKICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldOwogIH0gcmV0dXJuIFQ7Cn0gOiAkYXNzaWduOwoKfSx7Ii4vX2ZhaWxzIjo0MSwiLi9faW9iamVjdCI6NDcsIi4vX29iamVjdC1nb3BzIjo2MywiLi9fb2JqZWN0LWtleXMiOjY2LCIuL19vYmplY3QtcGllIjo2NywiLi9fdG8tb2JqZWN0Ijo4MH1dLDU3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gMTkuMS4yLjIgLyAxNS4yLjMuNSBPYmplY3QuY3JlYXRlKE8gWywgUHJvcGVydGllc10pCnZhciBhbk9iamVjdCA9IF9kZXJlcV8oJy4vX2FuLW9iamVjdCcpOwp2YXIgZFBzID0gX2RlcmVxXygnLi9fb2JqZWN0LWRwcycpOwp2YXIgZW51bUJ1Z0tleXMgPSBfZGVyZXFfKCcuL19lbnVtLWJ1Zy1rZXlzJyk7CnZhciBJRV9QUk9UTyA9IF9kZXJlcV8oJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTsKdmFyIEVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9Owp2YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7CgovLyBDcmVhdGUgb2JqZWN0IHdpdGggZmFrZSBgbnVsbGAgcHJvdG90eXBlOiB1c2UgaWZyYW1lIE9iamVjdCB3aXRoIGNsZWFyZWQgcHJvdG90eXBlCnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkgewogIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnCiAgdmFyIGlmcmFtZSA9IF9kZXJlcV8oJy4vX2RvbS1jcmVhdGUnKSgnaWZyYW1lJyk7CiAgdmFyIGkgPSBlbnVtQnVnS2V5cy5sZW5ndGg7CiAgdmFyIGx0ID0gJzwnOwogIHZhciBndCA9ICc+JzsKICB2YXIgaWZyYW1lRG9jdW1lbnQ7CiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7CiAgX2RlcmVxXygnLi9faHRtbCcpLmFwcGVuZENoaWxkKGlmcmFtZSk7CiAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0Oic7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2NyaXB0LXVybAogIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7CiAgLy8gaHRtbC5yZW1vdmVDaGlsZChpZnJhbWUpOwogIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7CiAgaWZyYW1lRG9jdW1lbnQub3BlbigpOwogIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgJ3NjcmlwdCcgKyBndCArICdkb2N1bWVudC5GPU9iamVjdCcgKyBsdCArICcvc2NyaXB0JyArIGd0KTsKICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpOwogIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GOwogIHdoaWxlIChpLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbaV1dOwogIHJldHVybiBjcmVhdGVEaWN0KCk7Cn07Cgptb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHsKICB2YXIgcmVzdWx0OwogIGlmIChPICE9PSBudWxsKSB7CiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7CiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTsKICAgIEVtcHR5W1BST1RPVFlQRV0gPSBudWxsOwogICAgLy8gYWRkICJfX3Byb3RvX18iIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YgcG9seWZpbGwKICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPOwogIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7CiAgcmV0dXJuIFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IGRQcyhyZXN1bHQsIFByb3BlcnRpZXMpOwp9OwoKfSx7Ii4vX2FuLW9iamVjdCI6MzAsIi4vX2RvbS1jcmVhdGUiOjM3LCIuL19lbnVtLWJ1Zy1rZXlzIjozOCwiLi9faHRtbCI6NDUsIi4vX29iamVjdC1kcHMiOjU5LCIuL19zaGFyZWQta2V5Ijo3M31dLDU4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGFuT2JqZWN0ID0gX2RlcmVxXygnLi9fYW4tb2JqZWN0Jyk7CnZhciBJRThfRE9NX0RFRklORSA9IF9kZXJlcV8oJy4vX2llOC1kb20tZGVmaW5lJyk7CnZhciB0b1ByaW1pdGl2ZSA9IF9kZXJlcV8oJy4vX3RvLXByaW1pdGl2ZScpOwp2YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CgpleHBvcnRzLmYgPSBfZGVyZXFfKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykgewogIGFuT2JqZWN0KE8pOwogIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTsKICBhbk9iamVjdChBdHRyaWJ1dGVzKTsKICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7CiAgICByZXR1cm4gZFAoTywgUCwgQXR0cmlidXRlcyk7CiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9CiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTsKICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTsKICByZXR1cm4gTzsKfTsKCn0seyIuL19hbi1vYmplY3QiOjMwLCIuL19kZXNjcmlwdG9ycyI6MzYsIi4vX2llOC1kb20tZGVmaW5lIjo0NiwiLi9fdG8tcHJpbWl0aXZlIjo4MX1dLDU5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGRQID0gX2RlcmVxXygnLi9fb2JqZWN0LWRwJyk7CnZhciBhbk9iamVjdCA9IF9kZXJlcV8oJy4vX2FuLW9iamVjdCcpOwp2YXIgZ2V0S2V5cyA9IF9kZXJlcV8oJy4vX29iamVjdC1rZXlzJyk7Cgptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXMoTywgUHJvcGVydGllcykgewogIGFuT2JqZWN0KE8pOwogIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTsKICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7CiAgdmFyIGkgPSAwOwogIHZhciBQOwogIHdoaWxlIChsZW5ndGggPiBpKSBkUC5mKE8sIFAgPSBrZXlzW2krK10sIFByb3BlcnRpZXNbUF0pOwogIHJldHVybiBPOwp9OwoKfSx7Ii4vX2FuLW9iamVjdCI6MzAsIi4vX2Rlc2NyaXB0b3JzIjozNiwiLi9fb2JqZWN0LWRwIjo1OCwiLi9fb2JqZWN0LWtleXMiOjY2fV0sNjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgcElFID0gX2RlcmVxXygnLi9fb2JqZWN0LXBpZScpOwp2YXIgY3JlYXRlRGVzYyA9IF9kZXJlcV8oJy4vX3Byb3BlcnR5LWRlc2MnKTsKdmFyIHRvSU9iamVjdCA9IF9kZXJlcV8oJy4vX3RvLWlvYmplY3QnKTsKdmFyIHRvUHJpbWl0aXZlID0gX2RlcmVxXygnLi9fdG8tcHJpbWl0aXZlJyk7CnZhciBoYXMgPSBfZGVyZXFfKCcuL19oYXMnKTsKdmFyIElFOF9ET01fREVGSU5FID0gX2RlcmVxXygnLi9faWU4LWRvbS1kZWZpbmUnKTsKdmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOwoKZXhwb3J0cy5mID0gX2RlcmVxXygnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkgewogIE8gPSB0b0lPYmplY3QoTyk7CiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpOwogIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHsKICAgIHJldHVybiBnT1BEKE8sIFApOwogIH0gY2F0Y2ggKGUpIHsgLyogZW1wdHkgKi8gfQogIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTsKfTsKCn0seyIuL19kZXNjcmlwdG9ycyI6MzYsIi4vX2hhcyI6NDMsIi4vX2llOC1kb20tZGVmaW5lIjo0NiwiLi9fb2JqZWN0LXBpZSI6NjcsIi4vX3Byb3BlcnR5LWRlc2MiOjY5LCIuL190by1pb2JqZWN0Ijo3OCwiLi9fdG8tcHJpbWl0aXZlIjo4MX1dLDYxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gZmFsbGJhY2sgZm9yIElFMTEgYnVnZ3kgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgd2l0aCBpZnJhbWUgYW5kIHdpbmRvdwp2YXIgdG9JT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8taW9iamVjdCcpOwp2YXIgZ09QTiA9IF9kZXJlcV8oJy4vX29iamVjdC1nb3BuJykuZjsKdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7Cgp2YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcwogID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdOwoKdmFyIGdldFdpbmRvd05hbWVzID0gZnVuY3Rpb24gKGl0KSB7CiAgdHJ5IHsKICAgIHJldHVybiBnT1BOKGl0KTsKICB9IGNhdGNoIChlKSB7CiAgICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTsKICB9Cn07Cgptb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkgewogIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJyA/IGdldFdpbmRvd05hbWVzKGl0KSA6IGdPUE4odG9JT2JqZWN0KGl0KSk7Cn07Cgp9LHsiLi9fb2JqZWN0LWdvcG4iOjYyLCIuL190by1pb2JqZWN0Ijo3OH1dLDYyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gMTkuMS4yLjcgLyAxNS4yLjMuNCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKQp2YXIgJGtleXMgPSBfZGVyZXFfKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpOwp2YXIgaGlkZGVuS2V5cyA9IF9kZXJlcV8oJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTsKCmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHx8IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykgewogIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTsKfTsKCn0seyIuL19lbnVtLWJ1Zy1rZXlzIjozOCwiLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwiOjY1fV0sNjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpleHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzOwoKfSx7fV0sNjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyAxOS4xLjIuOSAvIDE1LjIuMy4yIE9iamVjdC5nZXRQcm90b3R5cGVPZihPKQp2YXIgaGFzID0gX2RlcmVxXygnLi9faGFzJyk7CnZhciB0b09iamVjdCA9IF9kZXJlcV8oJy4vX3RvLW9iamVjdCcpOwp2YXIgSUVfUFJPVE8gPSBfZGVyZXFfKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7CnZhciBPYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7Cgptb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoTykgewogIE8gPSB0b09iamVjdChPKTsKICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dOwogIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7CiAgICByZXR1cm4gTy5jb25zdHJ1Y3Rvci5wcm90b3R5cGU7CiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDsKfTsKCn0seyIuL19oYXMiOjQzLCIuL19zaGFyZWQta2V5Ijo3MywiLi9fdG8tb2JqZWN0Ijo4MH1dLDY1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGhhcyA9IF9kZXJlcV8oJy4vX2hhcycpOwp2YXIgdG9JT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8taW9iamVjdCcpOwp2YXIgYXJyYXlJbmRleE9mID0gX2RlcmVxXygnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7CnZhciBJRV9QUk9UTyA9IF9kZXJlcV8oJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTsKCm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHsKICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpOwogIHZhciBpID0gMDsKICB2YXIgcmVzdWx0ID0gW107CiAgdmFyIGtleTsKICBmb3IgKGtleSBpbiBPKSBpZiAoa2V5ICE9IElFX1BST1RPKSBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpOwogIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXMKICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkgewogICAgfmFycmF5SW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTsKICB9CiAgcmV0dXJuIHJlc3VsdDsKfTsKCn0seyIuL19hcnJheS1pbmNsdWRlcyI6MzEsIi4vX2hhcyI6NDMsIi4vX3NoYXJlZC1rZXkiOjczLCIuL190by1pb2JqZWN0Ijo3OH1dLDY2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pCnZhciAka2V5cyA9IF9kZXJlcV8oJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7CnZhciBlbnVtQnVnS2V5cyA9IF9kZXJlcV8oJy4vX2VudW0tYnVnLWtleXMnKTsKCm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7CiAgcmV0dXJuICRrZXlzKE8sIGVudW1CdWdLZXlzKTsKfTsKCn0seyIuL19lbnVtLWJ1Zy1rZXlzIjozOCwiLi9fb2JqZWN0LWtleXMtaW50ZXJuYWwiOjY1fV0sNjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTsKCn0se31dLDY4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzCnZhciAkZXhwb3J0ID0gX2RlcmVxXygnLi9fZXhwb3J0Jyk7CnZhciBjb3JlID0gX2RlcmVxXygnLi9fY29yZScpOwp2YXIgZmFpbHMgPSBfZGVyZXFfKCcuL19mYWlscycpOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGV4ZWMpIHsKICB2YXIgZm4gPSAoY29yZS5PYmplY3QgfHwge30pW0tFWV0gfHwgT2JqZWN0W0tFWV07CiAgdmFyIGV4cCA9IHt9OwogIGV4cFtLRVldID0gZXhlYyhmbik7CiAgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiBmYWlscyhmdW5jdGlvbiAoKSB7IGZuKDEpOyB9KSwgJ09iamVjdCcsIGV4cCk7Cn07Cgp9LHsiLi9fY29yZSI6MzMsIi4vX2V4cG9ydCI6NDAsIi4vX2ZhaWxzIjo0MX1dLDY5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkgewogIHJldHVybiB7CiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLAogICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLAogICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksCiAgICB2YWx1ZTogdmFsdWUKICB9Owp9OwoKfSx7fV0sNzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJy4vX2hpZGUnKTsKCn0seyIuL19oaWRlIjo0NH1dLDcxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuCi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovCnZhciBpc09iamVjdCA9IF9kZXJlcV8oJy4vX2lzLW9iamVjdCcpOwp2YXIgYW5PYmplY3QgPSBfZGVyZXFfKCcuL19hbi1vYmplY3QnKTsKdmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7CiAgYW5PYmplY3QoTyk7CiAgaWYgKCFpc09iamVjdChwcm90bykgJiYgcHJvdG8gIT09IG51bGwpIHRocm93IFR5cGVFcnJvcihwcm90byArICI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhIik7Cn07Cm1vZHVsZS5leHBvcnRzID0gewogIHNldDogT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8ICgnX19wcm90b19fJyBpbiB7fSA/IC8vIGVzbGludC1kaXNhYmxlLWxpbmUKICAgIGZ1bmN0aW9uICh0ZXN0LCBidWdneSwgc2V0KSB7CiAgICAgIHRyeSB7CiAgICAgICAgc2V0ID0gX2RlcmVxXygnLi9fY3R4JykoRnVuY3Rpb24uY2FsbCwgX2RlcmVxXygnLi9fb2JqZWN0LWdvcGQnKS5mKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQsIDIpOwogICAgICAgIHNldCh0ZXN0LCBbXSk7CiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7CiAgICAgIH0gY2F0Y2ggKGUpIHsgYnVnZ3kgPSB0cnVlOyB9CiAgICAgIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykgewogICAgICAgIGNoZWNrKE8sIHByb3RvKTsKICAgICAgICBpZiAoYnVnZ3kpIE8uX19wcm90b19fID0gcHJvdG87CiAgICAgICAgZWxzZSBzZXQoTywgcHJvdG8pOwogICAgICAgIHJldHVybiBPOwogICAgICB9OwogICAgfSh7fSwgZmFsc2UpIDogdW5kZWZpbmVkKSwKICBjaGVjazogY2hlY2sKfTsKCn0seyIuL19hbi1vYmplY3QiOjMwLCIuL19jdHgiOjM0LCIuL19pcy1vYmplY3QiOjQ5LCIuL19vYmplY3QtZ29wZCI6NjB9XSw3MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBkZWYgPSBfZGVyZXFfKCcuL19vYmplY3QtZHAnKS5mOwp2YXIgaGFzID0gX2RlcmVxXygnLi9faGFzJyk7CnZhciBUQUcgPSBfZGVyZXFfKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTsKCm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHsKICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pOwp9OwoKfSx7Ii4vX2hhcyI6NDMsIi4vX29iamVjdC1kcCI6NTgsIi4vX3drcyI6ODV9XSw3MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBzaGFyZWQgPSBfZGVyZXFfKCcuL19zaGFyZWQnKSgna2V5cycpOwp2YXIgdWlkID0gX2RlcmVxXygnLi9fdWlkJyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkgewogIHJldHVybiBzaGFyZWRba2V5XSB8fCAoc2hhcmVkW2tleV0gPSB1aWQoa2V5KSk7Cn07Cgp9LHsiLi9fc2hhcmVkIjo3NCwiLi9fdWlkIjo4Mn1dLDc0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGdsb2JhbCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpOwp2YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7CnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7CiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB7fSk7Cn07Cgp9LHsiLi9fZ2xvYmFsIjo0Mn1dLDc1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIHRvSW50ZWdlciA9IF9kZXJlcV8oJy4vX3RvLWludGVnZXInKTsKdmFyIGRlZmluZWQgPSBfZGVyZXFfKCcuL19kZWZpbmVkJyk7Ci8vIHRydWUgIC0+IFN0cmluZyNhdAovLyBmYWxzZSAtPiBTdHJpbmcjY29kZVBvaW50QXQKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7CiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHsKICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpOwogICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTsKICAgIHZhciBsID0gcy5sZW5ndGg7CiAgICB2YXIgYSwgYjsKICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDsKICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7CiAgICByZXR1cm4gYSA8IDB4ZDgwMCB8fCBhID4gMHhkYmZmIHx8IGkgKyAxID09PSBsIHx8IChiID0gcy5jaGFyQ29kZUF0KGkgKyAxKSkgPCAweGRjMDAgfHwgYiA+IDB4ZGZmZgogICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYQogICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDsKICB9Owp9OwoKfSx7Ii4vX2RlZmluZWQiOjM1LCIuL190by1pbnRlZ2VyIjo3N31dLDc2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIHRvSW50ZWdlciA9IF9kZXJlcV8oJy4vX3RvLWludGVnZXInKTsKdmFyIG1heCA9IE1hdGgubWF4Owp2YXIgbWluID0gTWF0aC5taW47Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHsKICBpbmRleCA9IHRvSW50ZWdlcihpbmRleCk7CiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7Cn07Cgp9LHsiLi9fdG8taW50ZWdlciI6Nzd9XSw3NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDcuMS40IFRvSW50ZWdlcgp2YXIgY2VpbCA9IE1hdGguY2VpbDsKdmFyIGZsb29yID0gTWF0aC5mbG9vcjsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTsKfTsKCn0se31dLDc4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gdG8gaW5kZXhlZCBvYmplY3QsIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzCnZhciBJT2JqZWN0ID0gX2RlcmVxXygnLi9faW9iamVjdCcpOwp2YXIgZGVmaW5lZCA9IF9kZXJlcV8oJy4vX2RlZmluZWQnKTsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHsKICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7Cn07Cgp9LHsiLi9fZGVmaW5lZCI6MzUsIi4vX2lvYmplY3QiOjQ3fV0sNzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyA3LjEuMTUgVG9MZW5ndGgKdmFyIHRvSW50ZWdlciA9IF9kZXJlcV8oJy4vX3RvLWludGVnZXInKTsKdmFyIG1pbiA9IE1hdGgubWluOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxCn07Cgp9LHsiLi9fdG8taW50ZWdlciI6Nzd9XSw4MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudCkKdmFyIGRlZmluZWQgPSBfZGVyZXFfKCcuL19kZWZpbmVkJyk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7Cn07Cgp9LHsiLi9fZGVmaW5lZCI6MzV9XSw4MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKQp2YXIgaXNPYmplY3QgPSBfZGVyZXFfKCcuL19pcy1vYmplY3QnKTsKLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2UKLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmcKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHsKICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIGl0OwogIHZhciBmbiwgdmFsOwogIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsOwogIGlmICh0eXBlb2YgKGZuID0gaXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsOwogIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDsKICB0aHJvdyBUeXBlRXJyb3IoIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZSIpOwp9OwoKfSx7Ii4vX2lzLW9iamVjdCI6NDl9XSw4MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBpZCA9IDA7CnZhciBweCA9IE1hdGgucmFuZG9tKCk7Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkgewogIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7Cn07Cgp9LHt9XSw4MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBnbG9iYWwgPSBfZGVyZXFfKCcuL19nbG9iYWwnKTsKdmFyIGNvcmUgPSBfZGVyZXFfKCcuL19jb3JlJyk7CnZhciBMSUJSQVJZID0gX2RlcmVxXygnLi9fbGlicmFyeScpOwp2YXIgd2tzRXh0ID0gX2RlcmVxXygnLi9fd2tzLWV4dCcpOwp2YXIgZGVmaW5lUHJvcGVydHkgPSBfZGVyZXFfKCcuL19vYmplY3QtZHAnKS5mOwptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7CiAgdmFyICRTeW1ib2wgPSBjb3JlLlN5bWJvbCB8fCAoY29yZS5TeW1ib2wgPSBMSUJSQVJZID8ge30gOiBnbG9iYWwuU3ltYm9sIHx8IHt9KTsKICBpZiAobmFtZS5jaGFyQXQoMCkgIT0gJ18nICYmICEobmFtZSBpbiAkU3ltYm9sKSkgZGVmaW5lUHJvcGVydHkoJFN5bWJvbCwgbmFtZSwgeyB2YWx1ZTogd2tzRXh0LmYobmFtZSkgfSk7Cn07Cgp9LHsiLi9fY29yZSI6MzMsIi4vX2dsb2JhbCI6NDIsIi4vX2xpYnJhcnkiOjU0LCIuL19vYmplY3QtZHAiOjU4LCIuL193a3MtZXh0Ijo4NH1dLDg0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKZXhwb3J0cy5mID0gX2RlcmVxXygnLi9fd2tzJyk7Cgp9LHsiLi9fd2tzIjo4NX1dLDg1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIHN0b3JlID0gX2RlcmVxXygnLi9fc2hhcmVkJykoJ3drcycpOwp2YXIgdWlkID0gX2RlcmVxXygnLi9fdWlkJyk7CnZhciBTeW1ib2wgPSBfZGVyZXFfKCcuL19nbG9iYWwnKS5TeW1ib2w7CnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nOwoKdmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkgewogIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPQogICAgVVNFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV0gfHwgKFVTRV9TWU1CT0wgPyBTeW1ib2wgOiB1aWQpKCdTeW1ib2wuJyArIG5hbWUpKTsKfTsKCiRleHBvcnRzLnN0b3JlID0gc3RvcmU7Cgp9LHsiLi9fZ2xvYmFsIjo0MiwiLi9fc2hhcmVkIjo3NCwiLi9fdWlkIjo4Mn1dLDg2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwp2YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9kZXJlcV8oJy4vX2FkZC10by11bnNjb3BhYmxlcycpOwp2YXIgc3RlcCA9IF9kZXJlcV8oJy4vX2l0ZXItc3RlcCcpOwp2YXIgSXRlcmF0b3JzID0gX2RlcmVxXygnLi9faXRlcmF0b3JzJyk7CnZhciB0b0lPYmplY3QgPSBfZGVyZXFfKCcuL190by1pb2JqZWN0Jyk7CgovLyAyMi4xLjMuNCBBcnJheS5wcm90b3R5cGUuZW50cmllcygpCi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpCi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKCkKLy8gMjIuMS4zLjMwIEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpCm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9faXRlci1kZWZpbmUnKShBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7CiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldAogIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4CiAgdGhpcy5fayA9IGtpbmQ7ICAgICAgICAgICAgICAgIC8vIGtpbmQKLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpCn0sIGZ1bmN0aW9uICgpIHsKICB2YXIgTyA9IHRoaXMuX3Q7CiAgdmFyIGtpbmQgPSB0aGlzLl9rOwogIHZhciBpbmRleCA9IHRoaXMuX2krKzsKICBpZiAoIU8gfHwgaW5kZXggPj0gTy5sZW5ndGgpIHsKICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7CiAgICByZXR1cm4gc3RlcCgxKTsKICB9CiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7CiAgaWYgKGtpbmQgPT0gJ3ZhbHVlcycpIHJldHVybiBzdGVwKDAsIE9baW5kZXhdKTsKICByZXR1cm4gc3RlcCgwLCBbaW5kZXgsIE9baW5kZXhdXSk7Cn0sICd2YWx1ZXMnKTsKCi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJSAoOS40LjQuNiwgOS40LjQuNykKSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTsKCmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTsKYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7CmFkZFRvVW5zY29wYWJsZXMoJ2VudHJpZXMnKTsKCn0seyIuL19hZGQtdG8tdW5zY29wYWJsZXMiOjI5LCIuL19pdGVyLWRlZmluZSI6NTEsIi4vX2l0ZXItc3RlcCI6NTIsIi4vX2l0ZXJhdG9ycyI6NTMsIi4vX3RvLWlvYmplY3QiOjc4fV0sODc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyAxOS4xLjMuMSBPYmplY3QuYXNzaWduKHRhcmdldCwgc291cmNlKQp2YXIgJGV4cG9ydCA9IF9kZXJlcV8oJy4vX2V4cG9ydCcpOwoKJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYsICdPYmplY3QnLCB7IGFzc2lnbjogX2RlcmVxXygnLi9fb2JqZWN0LWFzc2lnbicpIH0pOwoKfSx7Ii4vX2V4cG9ydCI6NDAsIi4vX29iamVjdC1hc3NpZ24iOjU2fV0sODg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgJGV4cG9ydCA9IF9kZXJlcV8oJy4vX2V4cG9ydCcpOwovLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSkKJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogX2RlcmVxXygnLi9fb2JqZWN0LWNyZWF0ZScpIH0pOwoKfSx7Ii4vX2V4cG9ydCI6NDAsIi4vX29iamVjdC1jcmVhdGUiOjU3fV0sODk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgJGV4cG9ydCA9IF9kZXJlcV8oJy4vX2V4cG9ydCcpOwovLyAxOS4xLjIuNCAvIDE1LjIuMy42IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKQokZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFfZGVyZXFfKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogX2RlcmVxXygnLi9fb2JqZWN0LWRwJykuZiB9KTsKCn0seyIuL19kZXNjcmlwdG9ycyI6MzYsIi4vX2V4cG9ydCI6NDAsIi4vX29iamVjdC1kcCI6NTh9XSw5MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKQp2YXIgdG9PYmplY3QgPSBfZGVyZXFfKCcuL190by1vYmplY3QnKTsKdmFyICRnZXRQcm90b3R5cGVPZiA9IF9kZXJlcV8oJy4vX29iamVjdC1ncG8nKTsKCl9kZXJlcV8oJy4vX29iamVjdC1zYXAnKSgnZ2V0UHJvdG90eXBlT2YnLCBmdW5jdGlvbiAoKSB7CiAgcmV0dXJuIGZ1bmN0aW9uIGdldFByb3RvdHlwZU9mKGl0KSB7CiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7CiAgfTsKfSk7Cgp9LHsiLi9fb2JqZWN0LWdwbyI6NjQsIi4vX29iamVjdC1zYXAiOjY4LCIuL190by1vYmplY3QiOjgwfV0sOTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyAxOS4xLjMuMTkgT2JqZWN0LnNldFByb3RvdHlwZU9mKE8sIHByb3RvKQp2YXIgJGV4cG9ydCA9IF9kZXJlcV8oJy4vX2V4cG9ydCcpOwokZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHsgc2V0UHJvdG90eXBlT2Y6IF9kZXJlcV8oJy4vX3NldC1wcm90bycpLnNldCB9KTsKCn0seyIuL19leHBvcnQiOjQwLCIuL19zZXQtcHJvdG8iOjcxfV0sOTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewphcmd1bWVudHNbNF1bMThdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKQp9LHsiZHVwIjoxOH1dLDkzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKJ3VzZSBzdHJpY3QnOwp2YXIgJGF0ID0gX2RlcmVxXygnLi9fc3RyaW5nLWF0JykodHJ1ZSk7CgovLyAyMS4xLjMuMjcgU3RyaW5nLnByb3RvdHlwZVtAQGl0ZXJhdG9yXSgpCl9kZXJlcV8oJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7CiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldAogIHRoaXMuX2kgPSAwOyAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4Ci8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KCkKfSwgZnVuY3Rpb24gKCkgewogIHZhciBPID0gdGhpcy5fdDsKICB2YXIgaW5kZXggPSB0aGlzLl9pOwogIHZhciBwb2ludDsKICBpZiAoaW5kZXggPj0gTy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTsKICBwb2ludCA9ICRhdChPLCBpbmRleCk7CiAgdGhpcy5faSArPSBwb2ludC5sZW5ndGg7CiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9Owp9KTsKCn0seyIuL19pdGVyLWRlZmluZSI6NTEsIi4vX3N0cmluZy1hdCI6NzV9XSw5NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKLy8gRUNNQVNjcmlwdCA2IHN5bWJvbHMgc2hpbQp2YXIgZ2xvYmFsID0gX2RlcmVxXygnLi9fZ2xvYmFsJyk7CnZhciBoYXMgPSBfZGVyZXFfKCcuL19oYXMnKTsKdmFyIERFU0NSSVBUT1JTID0gX2RlcmVxXygnLi9fZGVzY3JpcHRvcnMnKTsKdmFyICRleHBvcnQgPSBfZGVyZXFfKCcuL19leHBvcnQnKTsKdmFyIHJlZGVmaW5lID0gX2RlcmVxXygnLi9fcmVkZWZpbmUnKTsKdmFyIE1FVEEgPSBfZGVyZXFfKCcuL19tZXRhJykuS0VZOwp2YXIgJGZhaWxzID0gX2RlcmVxXygnLi9fZmFpbHMnKTsKdmFyIHNoYXJlZCA9IF9kZXJlcV8oJy4vX3NoYXJlZCcpOwp2YXIgc2V0VG9TdHJpbmdUYWcgPSBfZGVyZXFfKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpOwp2YXIgdWlkID0gX2RlcmVxXygnLi9fdWlkJyk7CnZhciB3a3MgPSBfZGVyZXFfKCcuL193a3MnKTsKdmFyIHdrc0V4dCA9IF9kZXJlcV8oJy4vX3drcy1leHQnKTsKdmFyIHdrc0RlZmluZSA9IF9kZXJlcV8oJy4vX3drcy1kZWZpbmUnKTsKdmFyIGVudW1LZXlzID0gX2RlcmVxXygnLi9fZW51bS1rZXlzJyk7CnZhciBpc0FycmF5ID0gX2RlcmVxXygnLi9faXMtYXJyYXknKTsKdmFyIGFuT2JqZWN0ID0gX2RlcmVxXygnLi9fYW4tb2JqZWN0Jyk7CnZhciBpc09iamVjdCA9IF9kZXJlcV8oJy4vX2lzLW9iamVjdCcpOwp2YXIgdG9JT2JqZWN0ID0gX2RlcmVxXygnLi9fdG8taW9iamVjdCcpOwp2YXIgdG9QcmltaXRpdmUgPSBfZGVyZXFfKCcuL190by1wcmltaXRpdmUnKTsKdmFyIGNyZWF0ZURlc2MgPSBfZGVyZXFfKCcuL19wcm9wZXJ0eS1kZXNjJyk7CnZhciBfY3JlYXRlID0gX2RlcmVxXygnLi9fb2JqZWN0LWNyZWF0ZScpOwp2YXIgZ09QTkV4dCA9IF9kZXJlcV8oJy4vX29iamVjdC1nb3BuLWV4dCcpOwp2YXIgJEdPUEQgPSBfZGVyZXFfKCcuL19vYmplY3QtZ29wZCcpOwp2YXIgJERQID0gX2RlcmVxXygnLi9fb2JqZWN0LWRwJyk7CnZhciAka2V5cyA9IF9kZXJlcV8oJy4vX29iamVjdC1rZXlzJyk7CnZhciBnT1BEID0gJEdPUEQuZjsKdmFyIGRQID0gJERQLmY7CnZhciBnT1BOID0gZ09QTkV4dC5mOwp2YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7CnZhciAkSlNPTiA9IGdsb2JhbC5KU09OOwp2YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTsKdmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnOwp2YXIgSElEREVOID0gd2tzKCdfaGlkZGVuJyk7CnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7CnZhciBpc0VudW0gPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTsKdmFyIFN5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzeW1ib2wtcmVnaXN0cnknKTsKdmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTsKdmFyIE9QU3ltYm9scyA9IHNoYXJlZCgnb3Atc3ltYm9scycpOwp2YXIgT2JqZWN0UHJvdG8gPSBPYmplY3RbUFJPVE9UWVBFXTsKdmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nOwp2YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0OwovLyBEb24ndCB1c2Ugc2V0dGVycyBpbiBRdCBTY3JpcHQsIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8xNzMKdmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7CgovLyBmYWxsYmFjayBmb3Igb2xkIEFuZHJvaWQsIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvdjgvaXNzdWVzL2RldGFpbD9pZD02ODcKdmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkgewogIHJldHVybiBfY3JlYXRlKGRQKHt9LCAnYScsIHsKICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZFAodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH0KICB9KSkuYSAhPSA3Owp9KSA/IGZ1bmN0aW9uIChpdCwga2V5LCBEKSB7CiAgdmFyIHByb3RvRGVzYyA9IGdPUEQoT2JqZWN0UHJvdG8sIGtleSk7CiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07CiAgZFAoaXQsIGtleSwgRCk7CiAgaWYgKHByb3RvRGVzYyAmJiBpdCAhPT0gT2JqZWN0UHJvdG8pIGRQKE9iamVjdFByb3RvLCBrZXksIHByb3RvRGVzYyk7Cn0gOiBkUDsKCnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZykgewogIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7CiAgc3ltLl9rID0gdGFnOwogIHJldHVybiBzeW07Cn07Cgp2YXIgaXNTeW1ib2wgPSBVU0VfTkFUSVZFICYmIHR5cGVvZiAkU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnID8gZnVuY3Rpb24gKGl0KSB7CiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJzsKfSA6IGZ1bmN0aW9uIChpdCkgewogIHJldHVybiBpdCBpbnN0YW5jZW9mICRTeW1ib2w7Cn07Cgp2YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoaXQsIGtleSwgRCkgewogIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7CiAgYW5PYmplY3QoaXQpOwogIGtleSA9IHRvUHJpbWl0aXZlKGtleSwgdHJ1ZSk7CiAgYW5PYmplY3QoRCk7CiAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpKSB7CiAgICBpZiAoIUQuZW51bWVyYWJsZSkgewogICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpOwogICAgICBpdFtISURERU5dW2tleV0gPSB0cnVlOwogICAgfSBlbHNlIHsKICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlOwogICAgICBEID0gX2NyZWF0ZShELCB7IGVudW1lcmFibGU6IGNyZWF0ZURlc2MoMCwgZmFsc2UpIH0pOwogICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzYyhpdCwga2V5LCBEKTsKICB9IHJldHVybiBkUChpdCwga2V5LCBEKTsKfTsKdmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhpdCwgUCkgewogIGFuT2JqZWN0KGl0KTsKICB2YXIga2V5cyA9IGVudW1LZXlzKFAgPSB0b0lPYmplY3QoUCkpOwogIHZhciBpID0gMDsKICB2YXIgbCA9IGtleXMubGVuZ3RoOwogIHZhciBrZXk7CiAgd2hpbGUgKGwgPiBpKSAkZGVmaW5lUHJvcGVydHkoaXQsIGtleSA9IGtleXNbaSsrXSwgUFtrZXldKTsKICByZXR1cm4gaXQ7Cn07CnZhciAkY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGl0LCBQKSB7CiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApOwp9Owp2YXIgJHByb3BlcnR5SXNFbnVtZXJhYmxlID0gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoa2V5KSB7CiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTsKICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8gJiYgaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhPUFN5bWJvbHMsIGtleSkpIHJldHVybiBmYWxzZTsKICByZXR1cm4gRSB8fCAhaGFzKHRoaXMsIGtleSkgfHwgIWhhcyhBbGxTeW1ib2xzLCBrZXkpIHx8IGhhcyh0aGlzLCBISURERU4pICYmIHRoaXNbSElEREVOXVtrZXldID8gRSA6IHRydWU7Cn07CnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHsKICBpdCA9IHRvSU9iamVjdChpdCk7CiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTsKICBpZiAoaXQgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm47CiAgdmFyIEQgPSBnT1BEKGl0LCBrZXkpOwogIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7CiAgcmV0dXJuIEQ7Cn07CnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHsKICB2YXIgbmFtZXMgPSBnT1BOKHRvSU9iamVjdChpdCkpOwogIHZhciByZXN1bHQgPSBbXTsKICB2YXIgaSA9IDA7CiAgdmFyIGtleTsKICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgewogICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTsKICB9IHJldHVybiByZXN1bHQ7Cn07CnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7CiAgdmFyIElTX09QID0gaXQgPT09IE9iamVjdFByb3RvOwogIHZhciBuYW1lcyA9IGdPUE4oSVNfT1AgPyBPUFN5bWJvbHMgOiB0b0lPYmplY3QoaXQpKTsKICB2YXIgcmVzdWx0ID0gW107CiAgdmFyIGkgPSAwOwogIHZhciBrZXk7CiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHsKICAgIGlmIChoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYgKElTX09QID8gaGFzKE9iamVjdFByb3RvLCBrZXkpIDogdHJ1ZSkpIHJlc3VsdC5wdXNoKEFsbFN5bWJvbHNba2V5XSk7CiAgfSByZXR1cm4gcmVzdWx0Owp9OwoKLy8gMTkuNC4xLjEgU3ltYm9sKFtkZXNjcmlwdGlvbl0pCmlmICghVVNFX05BVElWRSkgewogICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7CiAgICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpIHRocm93IFR5cGVFcnJvcignU3ltYm9sIGlzIG5vdCBhIGNvbnN0cnVjdG9yIScpOwogICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7CiAgICB2YXIgJHNldCA9IGZ1bmN0aW9uICh2YWx1ZSkgewogICAgICBpZiAodGhpcyA9PT0gT2JqZWN0UHJvdG8pICRzZXQuY2FsbChPUFN5bWJvbHMsIHZhbHVlKTsKICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7CiAgICAgIHNldFN5bWJvbERlc2ModGhpcywgdGFnLCBjcmVhdGVEZXNjKDEsIHZhbHVlKSk7CiAgICB9OwogICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pOwogICAgcmV0dXJuIHdyYXAodGFnKTsKICB9OwogIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7CiAgICByZXR1cm4gdGhpcy5fazsKICB9KTsKCiAgJEdPUEQuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7CiAgJERQLmYgPSAkZGVmaW5lUHJvcGVydHk7CiAgX2RlcmVxXygnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7CiAgX2RlcmVxXygnLi9fb2JqZWN0LXBpZScpLmYgPSAkcHJvcGVydHlJc0VudW1lcmFibGU7CiAgX2RlcmVxXygnLi9fb2JqZWN0LWdvcHMnKS5mID0gJGdldE93blByb3BlcnR5U3ltYm9sczsKCiAgaWYgKERFU0NSSVBUT1JTICYmICFfZGVyZXFfKCcuL19saWJyYXJ5JykpIHsKICAgIHJlZGVmaW5lKE9iamVjdFByb3RvLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHRydWUpOwogIH0KCiAgd2tzRXh0LmYgPSBmdW5jdGlvbiAobmFtZSkgewogICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTsKICB9Owp9CgokZXhwb3J0KCRleHBvcnQuRyArICRleHBvcnQuVyArICRleHBvcnQuRiAqICFVU0VfTkFUSVZFLCB7IFN5bWJvbDogJFN5bWJvbCB9KTsKCmZvciAodmFyIGVzNlN5bWJvbHMgPSAoCiAgLy8gMTkuNC4yLjIsIDE5LjQuMi4zLCAxOS40LjIuNCwgMTkuNC4yLjYsIDE5LjQuMi44LCAxOS40LjIuOSwgMTkuNC4yLjEwLCAxOS40LjIuMTEsIDE5LjQuMi4xMiwgMTkuNC4yLjEzLCAxOS40LjIuMTQKICAnaGFzSW5zdGFuY2UsaXNDb25jYXRTcHJlYWRhYmxlLGl0ZXJhdG9yLG1hdGNoLHJlcGxhY2Usc2VhcmNoLHNwZWNpZXMsc3BsaXQsdG9QcmltaXRpdmUsdG9TdHJpbmdUYWcsdW5zY29wYWJsZXMnCikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7Cgpmb3IgKHZhciB3ZWxsS25vd25TeW1ib2xzID0gJGtleXMod2tzLnN0b3JlKSwgayA9IDA7IHdlbGxLbm93blN5bWJvbHMubGVuZ3RoID4gazspIHdrc0RlZmluZSh3ZWxsS25vd25TeW1ib2xzW2srK10pOwoKJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ1N5bWJvbCcsIHsKICAvLyAxOS40LjIuMSBTeW1ib2wuZm9yKGtleSkKICAnZm9yJzogZnVuY3Rpb24gKGtleSkgewogICAgcmV0dXJuIGhhcyhTeW1ib2xSZWdpc3RyeSwga2V5ICs9ICcnKQogICAgICA/IFN5bWJvbFJlZ2lzdHJ5W2tleV0KICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpOwogIH0sCiAgLy8gMTkuNC4yLjUgU3ltYm9sLmtleUZvcihzeW0pCiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7CiAgICBpZiAoIWlzU3ltYm9sKHN5bSkpIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCEnKTsKICAgIGZvciAodmFyIGtleSBpbiBTeW1ib2xSZWdpc3RyeSkgaWYgKFN5bWJvbFJlZ2lzdHJ5W2tleV0gPT09IHN5bSkgcmV0dXJuIGtleTsKICB9LAogIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSB0cnVlOyB9LAogIHVzZVNpbXBsZTogZnVuY3Rpb24gKCkgeyBzZXR0ZXIgPSBmYWxzZTsgfQp9KTsKCiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdPYmplY3QnLCB7CiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKQogIGNyZWF0ZTogJGNyZWF0ZSwKICAvLyAxOS4xLjIuNCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykKICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LAogIC8vIDE5LjEuMi4zIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpCiAgZGVmaW5lUHJvcGVydGllczogJGRlZmluZVByb3BlcnRpZXMsCiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKQogIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvciwKICAvLyAxOS4xLjIuNyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhPKQogIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLAogIC8vIDE5LjEuMi44IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTykKICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMKfSk7CgovLyAyNC4zLjIgSlNPTi5zdHJpbmdpZnkodmFsdWUgWywgcmVwbGFjZXIgWywgc3BhY2VdXSkKJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHsKICB2YXIgUyA9ICRTeW1ib2woKTsKICAvLyBNUyBFZGdlIGNvbnZlcnRzIHN5bWJvbCB2YWx1ZXMgdG8gSlNPTiBhcyB7fQogIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbAogIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzCiAgcmV0dXJuIF9zdHJpbmdpZnkoW1NdKSAhPSAnW251bGxdJyB8fCBfc3RyaW5naWZ5KHsgYTogUyB9KSAhPSAne30nIHx8IF9zdHJpbmdpZnkoT2JqZWN0KFMpKSAhPSAne30nOwp9KSksICdKU09OJywgewogIHN0cmluZ2lmeTogZnVuY3Rpb24gc3RyaW5naWZ5KGl0KSB7CiAgICB2YXIgYXJncyA9IFtpdF07CiAgICB2YXIgaSA9IDE7CiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjsKICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTsKICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTsKICAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKSByZXR1cm47IC8vIElFOCByZXR1cm5zIHN0cmluZyBvbiB1bmRlZmluZWQKICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsKICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTsKICAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpIHJldHVybiB2YWx1ZTsKICAgIH07CiAgICBhcmdzWzFdID0gcmVwbGFjZXI7CiAgICByZXR1cm4gX3N0cmluZ2lmeS5hcHBseSgkSlNPTiwgYXJncyk7CiAgfQp9KTsKCi8vIDE5LjQuMy40IFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV0oaGludCkKJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgX2RlcmVxXygnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7Ci8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10Kc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgJ1N5bWJvbCcpOwovLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddCnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7Ci8vIDI0LjMuMyBKU09OW0BAdG9TdHJpbmdUYWddCnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpOwoKfSx7Ii4vX2FuLW9iamVjdCI6MzAsIi4vX2Rlc2NyaXB0b3JzIjozNiwiLi9fZW51bS1rZXlzIjozOSwiLi9fZXhwb3J0Ijo0MCwiLi9fZmFpbHMiOjQxLCIuL19nbG9iYWwiOjQyLCIuL19oYXMiOjQzLCIuL19oaWRlIjo0NCwiLi9faXMtYXJyYXkiOjQ4LCIuL19pcy1vYmplY3QiOjQ5LCIuL19saWJyYXJ5Ijo1NCwiLi9fbWV0YSI6NTUsIi4vX29iamVjdC1jcmVhdGUiOjU3LCIuL19vYmplY3QtZHAiOjU4LCIuL19vYmplY3QtZ29wZCI6NjAsIi4vX29iamVjdC1nb3BuIjo2MiwiLi9fb2JqZWN0LWdvcG4tZXh0Ijo2MSwiLi9fb2JqZWN0LWdvcHMiOjYzLCIuL19vYmplY3Qta2V5cyI6NjYsIi4vX29iamVjdC1waWUiOjY3LCIuL19wcm9wZXJ0eS1kZXNjIjo2OSwiLi9fcmVkZWZpbmUiOjcwLCIuL19zZXQtdG8tc3RyaW5nLXRhZyI6NzIsIi4vX3NoYXJlZCI6NzQsIi4vX3RvLWlvYmplY3QiOjc4LCIuL190by1wcmltaXRpdmUiOjgxLCIuL191aWQiOjgyLCIuL193a3MiOjg1LCIuL193a3MtZGVmaW5lIjo4MywiLi9fd2tzLWV4dCI6ODR9XSw5NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cl9kZXJlcV8oJy4vX3drcy1kZWZpbmUnKSgnYXN5bmNJdGVyYXRvcicpOwoKfSx7Ii4vX3drcy1kZWZpbmUiOjgzfV0sOTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpfZGVyZXFfKCcuL193a3MtZGVmaW5lJykoJ29ic2VydmFibGUnKTsKCn0seyIuL193a3MtZGVmaW5lIjo4M31dLDk3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKX2RlcmVxXygnLi9lczYuYXJyYXkuaXRlcmF0b3InKTsKdmFyIGdsb2JhbCA9IF9kZXJlcV8oJy4vX2dsb2JhbCcpOwp2YXIgaGlkZSA9IF9kZXJlcV8oJy4vX2hpZGUnKTsKdmFyIEl0ZXJhdG9ycyA9IF9kZXJlcV8oJy4vX2l0ZXJhdG9ycycpOwp2YXIgVE9fU1RSSU5HX1RBRyA9IF9kZXJlcV8oJy4vX3drcycpKCd0b1N0cmluZ1RhZycpOwoKdmFyIERPTUl0ZXJhYmxlcyA9ICgnQ1NTUnVsZUxpc3QsQ1NTU3R5bGVEZWNsYXJhdGlvbixDU1NWYWx1ZUxpc3QsQ2xpZW50UmVjdExpc3QsRE9NUmVjdExpc3QsRE9NU3RyaW5nTGlzdCwnICsKICAnRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCwnICsKICAnTWVkaWFMaXN0LE1pbWVUeXBlQXJyYXksTmFtZWROb2RlTWFwLE5vZGVMaXN0LFBhaW50UmVxdWVzdExpc3QsUGx1Z2luLFBsdWdpbkFycmF5LFNWR0xlbmd0aExpc3QsU1ZHTnVtYmVyTGlzdCwnICsKICAnU1ZHUGF0aFNlZ0xpc3QsU1ZHUG9pbnRMaXN0LFNWR1N0cmluZ0xpc3QsU1ZHVHJhbnNmb3JtTGlzdCxTb3VyY2VCdWZmZXJMaXN0LFN0eWxlU2hlZXRMaXN0LFRleHRUcmFja0N1ZUxpc3QsJyArCiAgJ1RleHRUcmFja0xpc3QsVG91Y2hMaXN0Jykuc3BsaXQoJywnKTsKCmZvciAodmFyIGkgPSAwOyBpIDwgRE9NSXRlcmFibGVzLmxlbmd0aDsgaSsrKSB7CiAgdmFyIE5BTUUgPSBET01JdGVyYWJsZXNbaV07CiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07CiAgdmFyIHByb3RvID0gQ29sbGVjdGlvbiAmJiBDb2xsZWN0aW9uLnByb3RvdHlwZTsKICBpZiAocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTsKICBJdGVyYXRvcnNbTkFNRV0gPSBJdGVyYXRvcnMuQXJyYXk7Cn0KCn0seyIuL19nbG9iYWwiOjQyLCIuL19oaWRlIjo0NCwiLi9faXRlcmF0b3JzIjo1MywiLi9fd2tzIjo4NSwiLi9lczYuYXJyYXkuaXRlcmF0b3IiOjg2fV0sOTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKEJ1ZmZlcil7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYAovLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC4KCmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7CiAgaWYgKEFycmF5LmlzQXJyYXkpIHsKICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7CiAgfQogIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nOwp9CmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7CgpmdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJzsKfQpleHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjsKCmZ1bmN0aW9uIGlzTnVsbChhcmcpIHsKICByZXR1cm4gYXJnID09PSBudWxsOwp9CmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsOwoKZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PSBudWxsOwp9CmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDsKCmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJzsKfQpleHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7CgpmdW5jdGlvbiBpc1N0cmluZyhhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7Cn0KZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nOwoKZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnOwp9CmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDsKCmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykgewogIHJldHVybiBhcmcgPT09IHZvaWQgMDsKfQpleHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7CgpmdW5jdGlvbiBpc1JlZ0V4cChyZSkgewogIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nOwp9CmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDsKCmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7Cn0KZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0OwoKZnVuY3Rpb24gaXNEYXRlKGQpIHsKICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJzsKfQpleHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTsKCmZ1bmN0aW9uIGlzRXJyb3IoZSkgewogIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTsKfQpleHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yOwoKZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJzsKfQpleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uOwoKZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2wKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7Cn0KZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlOwoKZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjsKCmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHsKICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pOwp9Cgp9KS5jYWxsKHRoaXMseyJpc0J1ZmZlciI6X2RlcmVxXygiLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzIil9KQp9LHsiLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzIjoxMDN9XSw5OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBvbmNlID0gX2RlcmVxXygnb25jZScpOwoKdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9OwoKdmFyIGlzUmVxdWVzdCA9IGZ1bmN0aW9uKHN0cmVhbSkgewoJcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJzsKfTsKCnZhciBpc0NoaWxkUHJvY2VzcyA9IGZ1bmN0aW9uKHN0cmVhbSkgewoJcmV0dXJuIHN0cmVhbS5zdGRpbyAmJiBBcnJheS5pc0FycmF5KHN0cmVhbS5zdGRpbykgJiYgc3RyZWFtLnN0ZGlvLmxlbmd0aCA9PT0gMwp9OwoKdmFyIGVvcyA9IGZ1bmN0aW9uKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHsKCWlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpOwoJaWYgKCFvcHRzKSBvcHRzID0ge307CgoJY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApOwoKCXZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTsKCXZhciBycyA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKCXZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgKG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZSk7Cgl2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IChvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGUpOwoKCXZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uKCkgewoJCWlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpOwoJfTsKCgl2YXIgb25maW5pc2ggPSBmdW5jdGlvbigpIHsKCQl3cml0YWJsZSA9IGZhbHNlOwoJCWlmICghcmVhZGFibGUpIGNhbGxiYWNrLmNhbGwoc3RyZWFtKTsKCX07CgoJdmFyIG9uZW5kID0gZnVuY3Rpb24oKSB7CgkJcmVhZGFibGUgPSBmYWxzZTsKCQlpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7Cgl9OwoKCXZhciBvbmV4aXQgPSBmdW5jdGlvbihleGl0Q29kZSkgewoJCWNhbGxiYWNrLmNhbGwoc3RyZWFtLCBleGl0Q29kZSA/IG5ldyBFcnJvcignZXhpdGVkIHdpdGggZXJyb3IgY29kZTogJyArIGV4aXRDb2RlKSA6IG51bGwpOwoJfTsKCgl2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikgewoJCWNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpOwoJfTsKCgl2YXIgb25jbG9zZSA9IGZ1bmN0aW9uKCkgewoJCWlmIChyZWFkYWJsZSAmJiAhKHJzICYmIHJzLmVuZGVkKSkgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBuZXcgRXJyb3IoJ3ByZW1hdHVyZSBjbG9zZScpKTsKCQlpZiAod3JpdGFibGUgJiYgISh3cyAmJiB3cy5lbmRlZCkpIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgbmV3IEVycm9yKCdwcmVtYXR1cmUgY2xvc2UnKSk7Cgl9OwoKCXZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbigpIHsKCQlzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7Cgl9OwoKCWlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgewoJCXN0cmVhbS5vbignY29tcGxldGUnLCBvbmZpbmlzaCk7CgkJc3RyZWFtLm9uKCdhYm9ydCcsIG9uY2xvc2UpOwoJCWlmIChzdHJlYW0ucmVxKSBvbnJlcXVlc3QoKTsKCQllbHNlIHN0cmVhbS5vbigncmVxdWVzdCcsIG9ucmVxdWVzdCk7Cgl9IGVsc2UgaWYgKHdyaXRhYmxlICYmICF3cykgeyAvLyBsZWdhY3kgc3RyZWFtcwoJCXN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpOwoJCXN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7Cgl9CgoJaWYgKGlzQ2hpbGRQcm9jZXNzKHN0cmVhbSkpIHN0cmVhbS5vbignZXhpdCcsIG9uZXhpdCk7CgoJc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7CglzdHJlYW0ub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTsKCWlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpOwoJc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpOwoKCXJldHVybiBmdW5jdGlvbigpIHsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2NvbXBsZXRlJywgb25maW5pc2gpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignYWJvcnQnLCBvbmNsb3NlKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ3JlcXVlc3QnLCBvbnJlcXVlc3QpOwoJCWlmIChzdHJlYW0ucmVxKSBzdHJlYW0ucmVxLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7CgkJc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmxlZ2FjeWZpbmlzaCk7CgkJc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9ubGVnYWN5ZmluaXNoKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2V4aXQnLCBvbmV4aXQpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpOwoJCXN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTsKCQlzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7Cgl9Owp9OwoKbW9kdWxlLmV4cG9ydHMgPSBlb3M7Cgp9LHsib25jZSI6MTE1fV0sMTAwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkgewogIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTsKICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkOwp9Cm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyOwoKLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54CkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7CkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDsKCi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZQovLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLgpFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwOwoKLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzCi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHsKICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKQogICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTsKICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuOwogIHJldHVybiB0aGlzOwp9OwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkgewogIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7CgogIGlmICghdGhpcy5fZXZlbnRzKQogICAgdGhpcy5fZXZlbnRzID0ge307CgogIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy4KICBpZiAodHlwZSA9PT0gJ2Vycm9yJykgewogICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHwKICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHsKICAgICAgZXIgPSBhcmd1bWVudHNbMV07CiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7CiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50CiAgICAgIH0gZWxzZSB7CiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlcgogICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCAiZXJyb3IiIGV2ZW50LiAoJyArIGVyICsgJyknKTsKICAgICAgICBlcnIuY29udGV4dCA9IGVyOwogICAgICAgIHRocm93IGVycjsKICAgICAgfQogICAgfQogIH0KCiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTsKCiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKQogICAgcmV0dXJuIGZhbHNlOwoKICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkgewogICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7CiAgICAgIC8vIGZhc3QgY2FzZXMKICAgICAgY2FzZSAxOgogICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAyOgogICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDM6CiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTsKICAgICAgICBicmVhazsKICAgICAgLy8gc2xvd2VyCiAgICAgIGRlZmF1bHQ6CiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7CiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTsKICAgIH0KICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7CiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsKICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTsKICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7CiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspCiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTsKICB9CgogIHJldHVybiB0cnVlOwp9OwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7CiAgdmFyIG07CgogIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpCiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpOwoKICBpZiAoIXRoaXMuX2V2ZW50cykKICAgIHRoaXMuX2V2ZW50cyA9IHt9OwoKICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSAibmV3TGlzdGVuZXIiISBCZWZvcmUKICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCAibmV3TGlzdGVuZXIiLgogIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpCiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwKICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/CiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7CgogIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKQogICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuCiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjsKICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKQogICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLgogICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpOwogIGVsc2UKICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LgogICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdOwoKICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVhawogIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7CiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHsKICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVyczsKICAgIH0gZWxzZSB7CiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVyczsKICAgIH0KCiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkgewogICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTsKICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArCiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArCiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsCiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7CiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTAKICAgICAgICBjb25zb2xlLnRyYWNlKCk7CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiB0aGlzOwp9OwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikgewogIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpCiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpOwoKICB2YXIgZmlyZWQgPSBmYWxzZTsKCiAgZnVuY3Rpb24gZygpIHsKICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7CgogICAgaWYgKCFmaXJlZCkgewogICAgICBmaXJlZCA9IHRydWU7CiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgICB9CiAgfQoKICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7CiAgdGhpcy5vbih0eXBlLCBnKTsKCiAgcmV0dXJuIHRoaXM7Cn07CgovLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZApFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHsKICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTsKCiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSkKICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7CgogIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pCiAgICByZXR1cm4gdGhpczsKCiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTsKICBsZW5ndGggPSBsaXN0Lmxlbmd0aDsKICBwb3NpdGlvbiA9IC0xOwoKICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwKICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7CiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdOwogICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikKICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTsKCiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkgewogICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykgewogICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwKICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkgewogICAgICAgIHBvc2l0aW9uID0gaTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQoKICAgIGlmIChwb3NpdGlvbiA8IDApCiAgICAgIHJldHVybiB0aGlzOwoKICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgewogICAgICBsaXN0Lmxlbmd0aCA9IDA7CiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07CiAgICB9IGVsc2UgewogICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7CiAgICB9CgogICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikKICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTsKICB9CgogIHJldHVybiB0aGlzOwp9OwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7CiAgdmFyIGtleSwgbGlzdGVuZXJzOwoKICBpZiAoIXRoaXMuX2V2ZW50cykKICAgIHJldHVybiB0aGlzOwoKICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0CiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHsKICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKQogICAgICB0aGlzLl9ldmVudHMgPSB7fTsKICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSkKICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTsKICAgIHJldHVybiB0aGlzOwogIH0KCiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzCiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHsKICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykgewogICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTsKICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTsKICAgIH0KICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpOwogICAgdGhpcy5fZXZlbnRzID0ge307CiAgICByZXR1cm4gdGhpczsKICB9CgogIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTsKCiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkgewogICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpOwogIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7CiAgICAvLyBMSUZPIG9yZGVyCiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aCkKICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTsKICB9CiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTsKCiAgcmV0dXJuIHRoaXM7Cn07CgpFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHsKICB2YXIgcmV0OwogIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pCiAgICByZXQgPSBbXTsKICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpCiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTsKICBlbHNlCiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTsKICByZXR1cm4gcmV0Owp9OwoKRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkgewogIGlmICh0aGlzLl9ldmVudHMpIHsKICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdOwoKICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKQogICAgICByZXR1cm4gMTsKICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpCiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDsKICB9CiAgcmV0dXJuIDA7Cn07CgpFdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHsKICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpOwp9OwoKZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJzsKfQoKZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInOwp9CgpmdW5jdGlvbiBpc09iamVjdChhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsOwp9CgpmdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHsKICByZXR1cm4gYXJnID09PSB2b2lkIDA7Cn0KCn0se31dLDEwMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7CiAgdmFyIGUsIG0KICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMQogIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxCiAgdmFyIGVCaWFzID0gZU1heCA+PiAxCiAgdmFyIG5CaXRzID0gLTcKICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwCiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxCiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV0KCiAgaSArPSBkCgogIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpCiAgcyA+Pj0gKC1uQml0cykKICBuQml0cyArPSBlTGVuCiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge30KCiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSkKICBlID4+PSAoLW5CaXRzKQogIG5CaXRzICs9IG1MZW4KICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fQoKICBpZiAoZSA9PT0gMCkgewogICAgZSA9IDEgLSBlQmlhcwogIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkgewogICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpCiAgfSBlbHNlIHsKICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbikKICAgIGUgPSBlIC0gZUJpYXMKICB9CiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbikKfQoKZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykgewogIHZhciBlLCBtLCBjCiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEKICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMQogIHZhciBlQmlhcyA9IGVNYXggPj4gMQogIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCkKICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpCiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xCiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDAKCiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSkKCiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHsKICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMAogICAgZSA9IGVNYXgKICB9IGVsc2UgewogICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpCiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7CiAgICAgIGUtLQogICAgICBjICo9IDIKICAgIH0KICAgIGlmIChlICsgZUJpYXMgPj0gMSkgewogICAgICB2YWx1ZSArPSBydCAvIGMKICAgIH0gZWxzZSB7CiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKQogICAgfQogICAgaWYgKHZhbHVlICogYyA+PSAyKSB7CiAgICAgIGUrKwogICAgICBjIC89IDIKICAgIH0KCiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHsKICAgICAgbSA9IDAKICAgICAgZSA9IGVNYXgKICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHsKICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pCiAgICAgIGUgPSBlICsgZUJpYXMKICAgIH0gZWxzZSB7CiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKQogICAgICBlID0gMAogICAgfQogIH0KCiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge30KCiAgZSA9IChlIDw8IG1MZW4pIHwgbQogIGVMZW4gKz0gbUxlbgogIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge30KCiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4Cn0KCn0se31dLDEwMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykgewogIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlCiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHsKICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yCiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwgewogICAgICBjb25zdHJ1Y3RvcjogewogICAgICAgIHZhbHVlOiBjdG9yLAogICAgICAgIGVudW1lcmFibGU6IGZhbHNlLAogICAgICAgIHdyaXRhYmxlOiB0cnVlLAogICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogICAgICB9CiAgICB9KTsKICB9Owp9IGVsc2UgewogIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzCiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHsKICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yCiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fQogICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZQogICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKQogICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yCiAgfQp9Cgp9LHt9XSwxMDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovKiEKICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlcgogKgogKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPgogKiBAbGljZW5zZSAgTUlUCiAqLwoKLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZwovLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5Cm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikgewogIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpCn0KCmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHsKICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKQp9CgovLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LgpmdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikgewogIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKQp9Cgp9LHt9XSwxMDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewp2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZzsKCm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7CiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nOwp9OwoKfSx7fV0sMTA1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKInVzZSBzdHJpY3QiOwoKLy8gdWludDMyICh0d28ncyBjb21wbGVtZW50KSBtYXgKLy8gbW9yZSBjb25zZXJ2YXRpdmUgdGhhbiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUgp2YXIgTUFYID0gNDI5NDk2NzI5NTsKdmFyIGlkQ291bnRlciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWCk7Cgptb2R1bGUuZXhwb3J0cyA9IGdldFVuaXF1ZUlkOwoKZnVuY3Rpb24gZ2V0VW5pcXVlSWQoKSB7CiAgaWRDb3VudGVyID0gKGlkQ291bnRlciArIDEpICUgTUFYOwogIHJldHVybiBpZENvdW50ZXI7Cn0KCn0se31dLDEwNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBnZXRVbmlxdWVJZCA9IF9kZXJlcV8oJy4vZ2V0VW5pcXVlSWQnKTsKCm1vZHVsZS5leHBvcnRzID0gY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmU7CgpmdW5jdGlvbiBjcmVhdGVJZFJlbWFwTWlkZGxld2FyZSgpIHsKICByZXR1cm4gZnVuY3Rpb24gKHJlcSwgcmVzLCBuZXh0LCBlbmQpIHsKICAgIHZhciBvcmlnaW5hbElkID0gcmVxLmlkOwogICAgdmFyIG5ld0lkID0gZ2V0VW5pcXVlSWQoKTsKICAgIHJlcS5pZCA9IG5ld0lkOwogICAgcmVzLmlkID0gbmV3SWQ7CiAgICBuZXh0KGZ1bmN0aW9uIChkb25lKSB7CiAgICAgIHJlcS5pZCA9IG9yaWdpbmFsSWQ7CiAgICAgIHJlcy5pZCA9IG9yaWdpbmFsSWQ7CiAgICAgIGRvbmUoKTsKICAgIH0pOwogIH07Cn0KCn0seyIuL2dldFVuaXF1ZUlkIjoxMDV9XSwxMDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7Cgp2YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjaycpOwoKdmFyIF9jbGFzc0NhbGxDaGVjazMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGFzc0NhbGxDaGVjazIpOwoKdmFyIF9jcmVhdGVDbGFzczIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MnKTsKCnZhciBfY3JlYXRlQ2xhc3MzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlQ2xhc3MyKTsKCmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9Cgp2YXIgYXN5bmMgPSBfZGVyZXFfKCdhc3luYycpOwp2YXIgSnNvblJwY0Vycm9yID0gX2RlcmVxXygnanNvbi1ycGMtZXJyb3InKTsKCnZhciBScGNFbmdpbmUgPSBmdW5jdGlvbiAoKSB7CiAgZnVuY3Rpb24gUnBjRW5naW5lKCkgewogICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgUnBjRW5naW5lKTsKCiAgICB0aGlzLl9taWRkbGV3YXJlID0gW107CiAgfQoKICAvLwogIC8vIFB1YmxpYwogIC8vCgogICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKFJwY0VuZ2luZSwgW3sKICAgIGtleTogJ3B1c2gnLAogICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2gobWlkZGxld2FyZSkgewogICAgICB0aGlzLl9taWRkbGV3YXJlLnB1c2gobWlkZGxld2FyZSk7CiAgICB9CiAgfSwgewogICAga2V5OiAnaGFuZGxlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGUocmVxLCBjYikgewogICAgICAvLyBiYXRjaCByZXF1ZXN0IHN1cHBvcnQKICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVxKSkgewogICAgICAgIGFzeW5jLm1hcChyZXEsIHRoaXMuX2hhbmRsZS5iaW5kKHRoaXMpLCBjYik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpcy5faGFuZGxlKHJlcSwgY2IpOwogICAgICB9CiAgICB9CgogICAgLy8KICAgIC8vIFByaXZhdGUKICAgIC8vCgogIH0sIHsKICAgIGtleTogJ19oYW5kbGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGUocmVxLCBjYikgewogICAgICAvLyBjcmVhdGUgcmVzcG9uc2Ugb2JqCiAgICAgIHZhciByZXMgPSB7CiAgICAgICAgaWQ6IHJlcS5pZCwKICAgICAgICBqc29ucnBjOiByZXEuanNvbnJwYwogICAgICAgIC8vIHByb2Nlc3MgYWxsIG1pZGRsZXdhcmUKICAgICAgfTt0aGlzLl9ydW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBmdW5jdGlvbiAoZXJyLCBpc0NvbXBsZXRlKSB7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgLy8gcHJlcGFyZSBlcnJvciBtZXNzYWdlCiAgICAgICAgICByZXMuZXJyb3IgPSBuZXcgSnNvblJwY0Vycm9yLkludGVybmFsRXJyb3IoZXJyKTsKICAgICAgICAgIC8vIHJldHVybiBlcnJvci1maXJzdCBhbmQgcmVzIHdpdGggZXJyCiAgICAgICAgICByZXR1cm4gY2IoZXJyLCByZXMpOwogICAgICAgIH0KICAgICAgICAvLyBmYWlsIGlmIG5vdCBjb21wbGV0ZWQKICAgICAgICBpZiAoIWlzQ29tcGxldGUpIHsKICAgICAgICAgIHJldHVybiBjYihuZXcgRXJyb3IoJ1JwY0VuZ2luZSAtIG5vdGhpbmcgZW5kZWQgcmVxdWVzdCcpKTsKICAgICAgICB9CiAgICAgICAgLy8gcmV0dXJuIHJlc3BvbnNlCiAgICAgICAgY2IobnVsbCwgcmVzKTsKICAgICAgfSk7CiAgICB9CiAgfSwgewogICAga2V5OiAnX3J1bk1pZGRsZXdhcmUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9ydW5NaWRkbGV3YXJlKHJlcSwgcmVzLCBjYikgewogICAgICB2YXIgc2VsZiA9IHRoaXM7CiAgICAgIC8vIGZvciBjbGltYmluZyBiYWNrIHVwIHRoZSBzdGFjawogICAgICB2YXIgcmV0dXJuSGFuZGxlcnMgPSBbXTsKICAgICAgLy8gZmxhZyBmb3Igc3RhY2sgcmV0dXJuCiAgICAgIHZhciBpc0NvbXBsZXRlID0gZmFsc2U7CgogICAgICAvLyBmbG93CiAgICAgIGFzeW5jLnNlcmllcyhbcnVuQWxsTWlkZGxld2FyZSwgcnVuUmV0dXJuSGFuZGxlcnNdLCBjb21wbGV0ZVJlcXVlc3QpOwoKICAgICAgLy8gZG93biBzdGFjayBvZiBtaWRkbGV3YXJlLCBjYWxsIGFuZCBjb2xsZWN0IG9wdGlvbmFsIHJldHVybkhhbmRsZXJzCiAgICAgIGZ1bmN0aW9uIHJ1bkFsbE1pZGRsZXdhcmUoY2IpIHsKICAgICAgICBhc3luYy5tYXBTZXJpZXMoc2VsZi5fbWlkZGxld2FyZSwgZWFjaE1pZGRsZXdhcmUsIGNiKTsKICAgICAgfQoKICAgICAgLy8gY2xpbWJzIHRoZSBzdGFjayBjYWxsaW5nIHJldHVybiBoYW5kbGVycwogICAgICBmdW5jdGlvbiBydW5SZXR1cm5IYW5kbGVycyhjYikgewogICAgICAgIHZhciBiYWNrU3RhY2sgPSByZXR1cm5IYW5kbGVycy5maWx0ZXIoQm9vbGVhbikucmV2ZXJzZSgpOwogICAgICAgIGFzeW5jLmVhY2hTZXJpZXMoYmFja1N0YWNrLCBmdW5jdGlvbiAoaGFuZGxlciwgbmV4dCkgewogICAgICAgICAgcmV0dXJuIGhhbmRsZXIobmV4dCk7CiAgICAgICAgfSwgY29tcGxldGVSZXF1ZXN0KTsKICAgICAgfQoKICAgICAgLy8gcnVucyBhbiBpbmRpdmlkdWFsIG1pZGRsZXdhcmUKICAgICAgZnVuY3Rpb24gZWFjaE1pZGRsZXdhcmUobWlkZGxld2FyZSwgY2IpIHsKICAgICAgICAvLyBza2lwIG1pZGRsZXdhcmUgaWYgY29tcGxldGVkCiAgICAgICAgaWYgKGlzQ29tcGxldGUpIHJldHVybiBjYigpOwogICAgICAgIC8vIHJ1biBpbmRpdmlkdWFsIG1pZGRsZXdhcmUKICAgICAgICBtaWRkbGV3YXJlKHJlcSwgcmVzLCBuZXh0LCBlbmQpOwoKICAgICAgICBmdW5jdGlvbiBuZXh0KHJldHVybkhhbmRsZXIpIHsKICAgICAgICAgIC8vIGFkZCByZXR1cm4gaGFuZGxlcgogICAgICAgICAgcmV0dXJuSGFuZGxlcnMucHVzaChyZXR1cm5IYW5kbGVyKTsKICAgICAgICAgIGNiKCk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGVuZChlcnIpIHsKICAgICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpOwogICAgICAgICAgLy8gbWFyayBhcyBjb21wbGV0ZWQKICAgICAgICAgIGlzQ29tcGxldGUgPSB0cnVlOwogICAgICAgICAgY2IoKTsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIC8vIHJldHVybnMsIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgaXQgZW5kZWQKICAgICAgZnVuY3Rpb24gY29tcGxldGVSZXF1ZXN0KGVycikgewogICAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpOwogICAgICAgIGNiKG51bGwsIGlzQ29tcGxldGUpOwogICAgICB9CiAgICB9CiAgfV0pOwogIHJldHVybiBScGNFbmdpbmU7Cn0oKTsKCm1vZHVsZS5leHBvcnRzID0gUnBjRW5naW5lOwoKfSx7ImFzeW5jIjo0LCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2siOjEyLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MiOjEzLCJqc29uLXJwYy1lcnJvciI6MTA4fV0sMTA4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2xpYi9lcnJvcnMnKTsKfSx7Ii4vbGliL2Vycm9ycyI6MTA5fV0sMTA5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKdmFyIGluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTsKCnZhciBKc29uUnBjRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLCBjb2RlLCBkYXRhKSB7CiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEpzb25ScGNFcnJvcikpIHsKICAgIHJldHVybiBuZXcgSnNvblJwY0Vycm9yKG1lc3NhZ2UsIGNvZGUsIGRhdGEpOwogIH0KCiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTsKICB0aGlzLmNvZGUgPSBjb2RlOwoKICBpZiAodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnKSB7CiAgICB0aGlzLmRhdGEgPSBkYXRhOwogIH0KfTsKCmluaGVyaXRzKEpzb25ScGNFcnJvciwgRXJyb3IpOwoKdmFyIFBhcnNlRXJyb3IgPSBmdW5jdGlvbigpIHsKICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFyc2VFcnJvcikpIHsKICAgIHJldHVybiBuZXcgUGFyc2VFcnJvcigpOwogIH0KCiAgSnNvblJwY0Vycm9yLmNhbGwodGhpcywgJ1BhcnNlIGVycm9yJywgLTMyNzAwKTsKfTsKCmluaGVyaXRzKFBhcnNlRXJyb3IsIEpzb25ScGNFcnJvcik7Cgp2YXIgSW52YWxpZFJlcXVlc3QgPSBmdW5jdGlvbigpIHsKICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW52YWxpZFJlcXVlc3QpKSB7CiAgICByZXR1cm4gbmV3IEludmFsaWRSZXF1ZXN0KCk7CiAgfQoKICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCAnSW52YWxpZCBSZXF1ZXN0JywgLTMyNjAwKTsKfTsKCmluaGVyaXRzKEludmFsaWRSZXF1ZXN0LCBKc29uUnBjRXJyb3IpOwoKdmFyIE1ldGhvZE5vdEZvdW5kID0gZnVuY3Rpb24oKSB7CiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1ldGhvZE5vdEZvdW5kKSkgewogICAgcmV0dXJuIG5ldyBNZXRob2ROb3RGb3VuZCgpOwogIH0KCiAgSnNvblJwY0Vycm9yLmNhbGwodGhpcywgJ01ldGhvZCBub3QgZm91bmQnLCAtMzI2MDEpOwp9OwoKaW5oZXJpdHMoTWV0aG9kTm90Rm91bmQsIEpzb25ScGNFcnJvcik7Cgp2YXIgSW52YWxpZFBhcmFtcyA9IGZ1bmN0aW9uKCkgewogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbnZhbGlkUGFyYW1zKSkgewogICAgcmV0dXJuIG5ldyBJbnZhbGlkUGFyYW1zKCk7CiAgfQoKICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCAnSW52YWxpZCBwYXJhbXMnLCAtMzI2MDIpOwp9OwoKaW5oZXJpdHMoSW52YWxpZFBhcmFtcywgSnNvblJwY0Vycm9yKTsKCnZhciBJbnRlcm5hbEVycm9yID0gZnVuY3Rpb24oZXJyKSB7CiAgdmFyIG1lc3NhZ2U7CgogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbnRlcm5hbEVycm9yKSkgewogICAgcmV0dXJuIG5ldyBJbnRlcm5hbEVycm9yKGVycik7CiAgfQoKICBpZiAoZXJyICYmIGVyci5tZXNzYWdlKSB7CiAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7CiAgfSBlbHNlIHsKICAgIG1lc3NhZ2UgPSAnSW50ZXJuYWwgZXJyb3InOwogIH0KCiAgSnNvblJwY0Vycm9yLmNhbGwodGhpcywgbWVzc2FnZSwgLTMyNjAzKTsKfTsKCmluaGVyaXRzKEludGVybmFsRXJyb3IsIEpzb25ScGNFcnJvcik7Cgp2YXIgU2VydmVyRXJyb3IgPSBmdW5jdGlvbihjb2RlKSB7CiAgaWYgKGNvZGUgPCAtMzIwOTkgfHwgY29kZSA+IC0zMjAwMCkgewogICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVycm9yIGNvZGUnKTsKICB9CgogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZXJ2ZXJFcnJvcikpIHsKICAgIHJldHVybiBuZXcgU2VydmVyRXJyb3IoY29kZSk7CiAgfQoKICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCAnU2VydmVyIGVycm9yJywgY29kZSk7Cn07Cgppbmhlcml0cyhTZXJ2ZXJFcnJvciwgSnNvblJwY0Vycm9yKTsKCkpzb25ScGNFcnJvci5QYXJzZUVycm9yID0gUGFyc2VFcnJvcjsKSnNvblJwY0Vycm9yLkludmFsaWRSZXF1ZXN0ID0gSW52YWxpZFJlcXVlc3Q7Ckpzb25ScGNFcnJvci5NZXRob2ROb3RGb3VuZCA9IE1ldGhvZE5vdEZvdW5kOwpKc29uUnBjRXJyb3IuSW52YWxpZFBhcmFtcyA9IEludmFsaWRQYXJhbXM7Ckpzb25ScGNFcnJvci5JbnRlcm5hbEVycm9yID0gSW50ZXJuYWxFcnJvcjsKSnNvblJwY0Vycm9yLlNlcnZlckVycm9yID0gU2VydmVyRXJyb3I7Cgptb2R1bGUuZXhwb3J0cyA9IEpzb25ScGNFcnJvcjsKCgoKfSx7ImluaGVyaXRzIjoxMDJ9XSwxMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewpjb25zdCBEdXBsZXhTdHJlYW0gPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0nKS5EdXBsZXgKCm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU3RyZWFtTWlkZGxld2FyZQoKZnVuY3Rpb24gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSgpIHsKICBjb25zdCBpZE1hcCA9IHt9CiAgY29uc3Qgc3RyZWFtID0gbmV3IER1cGxleFN0cmVhbSh7IG9iamVjdE1vZGU6IHRydWUsIHJlYWQsIHdyaXRlIH0pCgogIGNvbnN0IG1pZGRsZXdhcmUgPSAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4gewogICAgLy8gd3JpdGUgcmVxIHRvIHN0cmVhbQogICAgc3RyZWFtLnB1c2gocmVxKQogICAgLy8gcmVnaXN0ZXIgcmVxdWVzdCBvbiBpZCBtYXAKICAgIGlkTWFwW3JlcS5pZF0gPSB7IHJlcSwgcmVzLCBuZXh0LCBlbmQgfQogIH0KCiAgbWlkZGxld2FyZS5zdHJlYW0gPSBzdHJlYW0KICAKICByZXR1cm4gbWlkZGxld2FyZQoKICBmdW5jdGlvbiByZWFkICgpIHsKICAgIHJldHVybiBmYWxzZQogIH0KCiAgZnVuY3Rpb24gd3JpdGUgKHJlcywgZW5jb2RpbmcsIGNiKSB7CiAgICAvLyBjb25zb2xlLmxvZyhyZXMsIGVuY29kaW5nLCBjYikKICAgIGNvbnN0IGNvbnRleHQgPSBpZE1hcFtyZXMuaWRdCiAgICBpZiAoIWNvbnRleHQpIGNiKG5ldyBFcnJvcihgU3RyZWFtTWlkZGxld2FyZSAtIFVua25vd24gcmVzcG9uc2UgaWQgJHtyZXMuaWR9YCkpCiAgICBkZWxldGUgaWRNYXBbcmVzLmlkXQogICAgLy8gY29weSB3aG9sZSByZXMgb250byBvcmlnaW5hbCByZXMKICAgIE9iamVjdC5hc3NpZ24oY29udGV4dC5yZXMsIHJlcykKICAgIC8vIHJ1biBjYWxsYmFjayBvbiBlbXB0eSBzdGFjaywKICAgIC8vIHByZXZlbnQgaW50ZXJuYWwgc3RyZWFtLWhhbmRsZXIgZnJvbSBjYXRjaGluZyBlcnJvcnMKICAgIHNldFRpbWVvdXQoY29udGV4dC5lbmQpCiAgICAvLyBjb250aW51ZSBwcm9jZXNzaW5nIHN0cmVhbQogICAgY2IoKQogIH0KCn0KfSx7InJlYWRhYmxlLXN0cmVhbSI6MTI5fV0sMTExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLyoKKiBsb2dsZXZlbCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbAoqCiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeQoqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4KKi8KKGZ1bmN0aW9uIChyb290LCBkZWZpbml0aW9uKSB7CiAgICAidXNlIHN0cmljdCI7CiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7CiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pOwogICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykgewogICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpOwogICAgfSBlbHNlIHsKICAgICAgICByb290LmxvZyA9IGRlZmluaXRpb24oKTsKICAgIH0KfSh0aGlzLCBmdW5jdGlvbiAoKSB7CiAgICAidXNlIHN0cmljdCI7CgogICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZQogICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9OwogICAgdmFyIHVuZGVmaW5lZFR5cGUgPSAidW5kZWZpbmVkIjsKCiAgICB2YXIgbG9nTWV0aG9kcyA9IFsKICAgICAgICAidHJhY2UiLAogICAgICAgICJkZWJ1ZyIsCiAgICAgICAgImluZm8iLAogICAgICAgICJ3YXJuIiwKICAgICAgICAiZXJyb3IiCiAgICBdOwoKICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTYKICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7CiAgICAgICAgdmFyIG1ldGhvZCA9IG9ialttZXRob2ROYW1lXTsKICAgICAgICBpZiAodHlwZW9mIG1ldGhvZC5iaW5kID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7CiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmcKICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KG1ldGhvZCwgW29iaiwgYXJndW1lbnRzXSk7CiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudgogICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzCiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHsKICAgICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2RlYnVnJykgewogICAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7CiAgICAgICAgfQoKICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUpIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzCiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7CiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlLmxvZyAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gbm9vcDsKICAgICAgICB9CiAgICB9CgogICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseQoKICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcyhsZXZlbCwgbG9nZ2VyTmFtZSkgewogICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovCiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2dNZXRob2RzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHZhciBtZXRob2ROYW1lID0gbG9nTWV0aG9kc1tpXTsKICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID8KICAgICAgICAgICAgICAgIG5vb3AgOgogICAgICAgICAgICAgICAgdGhpcy5tZXRob2RGYWN0b3J5KG1ldGhvZE5hbWUsIGxldmVsLCBsb2dnZXJOYW1lKTsKICAgICAgICB9CgogICAgICAgIC8vIERlZmluZSBsb2cubG9nIGFzIGFuIGFsaWFzIGZvciBsb2cuZGVidWcKICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7CiAgICB9CgogICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LgogICAgLy8gV2UgYnVpbGQgcmVhbE1ldGhvZCgpIHJlcGxhY2VtZW50cyBoZXJlIHRoYXQgcmVnZW5lcmF0ZSBsb2dnaW5nIG1ldGhvZHMKICAgIGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHsKICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IHVuZGVmaW5lZFR5cGUpIHsKICAgICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHRoaXMsIGxldmVsLCBsb2dnZXJOYW1lKTsKICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTsKICAgICAgICAgICAgfQogICAgICAgIH07CiAgICB9CgogICAgLy8gQnkgZGVmYXVsdCwgd2UgdXNlIGNsb3NlbHkgYm91bmQgcmVhbCBtZXRob2RzIHdoZXJldmVyIHBvc3NpYmxlLCBhbmQKICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uCiAgICBmdW5jdGlvbiBkZWZhdWx0TWV0aG9kRmFjdG9yeShtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkgewogICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovCiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHwKICAgICAgICAgICAgICAgZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfQoKICAgIGZ1bmN0aW9uIExvZ2dlcihuYW1lLCBkZWZhdWx0TGV2ZWwsIGZhY3RvcnkpIHsKICAgICAgdmFyIHNlbGYgPSB0aGlzOwogICAgICB2YXIgY3VycmVudExldmVsOwogICAgICB2YXIgc3RvcmFnZUtleSA9ICJsb2dsZXZlbCI7CiAgICAgIGlmIChuYW1lKSB7CiAgICAgICAgc3RvcmFnZUtleSArPSAiOiIgKyBuYW1lOwogICAgICB9CgogICAgICBmdW5jdGlvbiBwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlKGxldmVsTnVtKSB7CiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpOwoKICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlKSByZXR1cm47CgogICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGUKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTsKICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9CgogICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrCiAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPQogICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgIj0iICsgbGV2ZWxOYW1lICsgIjsiOwogICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fQogICAgICB9CgogICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHsKICAgICAgICAgIHZhciBzdG9yZWRMZXZlbDsKCiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSkgcmV0dXJuOwoKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldOwogICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fQoKICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nCiAgICAgICAgICBpZiAodHlwZW9mIHN0b3JlZExldmVsID09PSB1bmRlZmluZWRUeXBlKSB7CiAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7CiAgICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IGNvb2tpZS5pbmRleE9mKAogICAgICAgICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgIj0iKTsKICAgICAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkgewogICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9CiAgICAgICAgICB9CgogICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC4KICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkOwogICAgICAgICAgfQoKICAgICAgICAgIHJldHVybiBzdG9yZWRMZXZlbDsKICAgICAgfQoKICAgICAgLyoKICAgICAgICoKICAgICAgICogUHVibGljIGxvZ2dlciBBUEkgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsIGZvciBkZXRhaWxzCiAgICAgICAqCiAgICAgICAqLwoKICAgICAgc2VsZi5uYW1lID0gbmFtZTsKCiAgICAgIHNlbGYubGV2ZWxzID0geyAiVFJBQ0UiOiAwLCAiREVCVUciOiAxLCAiSU5GTyI6IDIsICJXQVJOIjogMywKICAgICAgICAgICJFUlJPUiI6IDQsICJTSUxFTlQiOiA1fTsKCiAgICAgIHNlbGYubWV0aG9kRmFjdG9yeSA9IGZhY3RvcnkgfHwgZGVmYXVsdE1ldGhvZEZhY3Rvcnk7CgogICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIGN1cnJlbnRMZXZlbDsKICAgICAgfTsKCiAgICAgIHNlbGYuc2V0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwsIHBlcnNpc3QpIHsKICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09ICJzdHJpbmciICYmIHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldOwogICAgICAgICAgfQogICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gIm51bWJlciIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHsKICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSBsZXZlbDsKICAgICAgICAgICAgICBpZiAocGVyc2lzdCAhPT0gZmFsc2UpIHsgIC8vIGRlZmF1bHRzIHRvIHRydWUKICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYsIGxldmVsLCBuYW1lKTsKICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICJObyBjb25zb2xlIGF2YWlsYWJsZSBmb3IgbG9nZ2luZyI7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aHJvdyAibG9nLnNldExldmVsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBsZXZlbDogIiArIGxldmVsOwogICAgICAgICAgfQogICAgICB9OwoKICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHsKICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkgewogICAgICAgICAgICAgIHNlbGYuc2V0TGV2ZWwobGV2ZWwsIGZhbHNlKTsKICAgICAgICAgIH0KICAgICAgfTsKCiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkgewogICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7CiAgICAgIH07CgogICAgICBzZWxmLmRpc2FibGVBbGwgPSBmdW5jdGlvbihwZXJzaXN0KSB7CiAgICAgICAgICBzZWxmLnNldExldmVsKHNlbGYubGV2ZWxzLlNJTEVOVCwgcGVyc2lzdCk7CiAgICAgIH07CgogICAgICAvLyBJbml0aWFsaXplIHdpdGggdGhlIHJpZ2h0IGxldmVsCiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpOwogICAgICBpZiAoaW5pdGlhbExldmVsID09IG51bGwpIHsKICAgICAgICAgIGluaXRpYWxMZXZlbCA9IGRlZmF1bHRMZXZlbCA9PSBudWxsID8gIldBUk4iIDogZGVmYXVsdExldmVsOwogICAgICB9CiAgICAgIHNlbGYuc2V0TGV2ZWwoaW5pdGlhbExldmVsLCBmYWxzZSk7CiAgICB9CgogICAgLyoKICAgICAqCiAgICAgKiBUb3AtbGV2ZWwgQVBJCiAgICAgKgogICAgICovCgogICAgdmFyIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7CgogICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307CiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7CiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAic3RyaW5nIiB8fCBuYW1lID09PSAiIikgewogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiWW91IG11c3Qgc3VwcGx5IGEgbmFtZSB3aGVuIGNyZWF0aW5nIGEgbG9nZ2VyLiIpOwogICAgICAgIH0KCiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdOwogICAgICAgIGlmICghbG9nZ2VyKSB7CiAgICAgICAgICBsb2dnZXIgPSBfbG9nZ2Vyc0J5TmFtZVtuYW1lXSA9IG5ldyBMb2dnZXIoCiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGxvZ2dlcjsKICAgIH07CgogICAgLy8gR3JhYiB0aGUgY3VycmVudCBnbG9iYWwgbG9nIHZhcmlhYmxlIGluIGNhc2Ugb2Ygb3ZlcndyaXRlCiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7CiAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHsKICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJgogICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7CiAgICAgICAgICAgIHdpbmRvdy5sb2cgPSBfbG9nOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7CiAgICB9OwoKICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VycyA9IGZ1bmN0aW9uIGdldExvZ2dlcnMoKSB7CiAgICAgICAgcmV0dXJuIF9sb2dnZXJzQnlOYW1lOwogICAgfTsKCiAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjsKfSkpOwoKfSx7fV0sMTEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKY29uc3QgeyBEdXBsZXggfSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbScpCmNvbnN0IGVuZE9mU3RyZWFtID0gX2RlcmVxXygnZW5kLW9mLXN0cmVhbScpCmNvbnN0IG9uY2UgPSBfZGVyZXFfKCdvbmNlJykKY29uc3Qgbm9vcCA9ICgpID0+IHt9Cgpjb25zdCBJR05PUkVfU1VCU1RSRUFNID0ge30KCgpjbGFzcyBPYmplY3RNdWx0aXBsZXggZXh0ZW5kcyBEdXBsZXggewoKICBjb25zdHJ1Y3Rvcihfb3B0cyA9IHt9KSB7CiAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgX29wdHMsIHsKICAgICAgb2JqZWN0TW9kZTogdHJ1ZSwKICAgIH0pCiAgICBzdXBlcihvcHRzKQoKICAgIHRoaXMuX3N1YnN0cmVhbXMgPSB7fQogIH0KCiAgY3JlYXRlU3RyZWFtIChuYW1lKSB7CiAgICAvLyB2YWxpZGF0ZSBuYW1lCiAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcignT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eScpCiAgICBpZiAodGhpcy5fc3Vic3RyZWFtc1tuYW1lXSkgdGhyb3cgbmV3IEVycm9yKCdPYmplY3RNdWx0aXBsZXggLSBTdWJzdHJlYW0gZm9yIG5hbWUgIiR7bmFtZX0iIGFscmVhZHkgZXhpc3RzJykKCiAgICAvLyBjcmVhdGUgc3Vic3RyZWFtCiAgICBjb25zdCBzdWJzdHJlYW0gPSBuZXcgU3Vic3RyZWFtKHsgcGFyZW50OiB0aGlzLCBuYW1lOiBuYW1lIH0pCiAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gc3Vic3RyZWFtCgogICAgLy8gbGlzdGVuIGZvciBwYXJlbnQgc3RyZWFtIHRvIGVuZAogICAgYW55U3RyZWFtRW5kKHRoaXMsIChlcnIpID0+IHsKICAgICAgc3Vic3RyZWFtLmRlc3Ryb3koZXJyKQogICAgfSkKCiAgICByZXR1cm4gc3Vic3RyZWFtCiAgfQoKICAvLyBpZ25vcmUgc3RyZWFtcyAoZG9udCBkaXNwbGF5IG9ycGhhbmVkIGRhdGEgd2FybmluZykKICBpZ25vcmVTdHJlYW0gKG5hbWUpIHsKICAgIC8vIHZhbGlkYXRlIG5hbWUKICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKCdPYmplY3RNdWx0aXBsZXggLSBuYW1lIG11c3Qgbm90IGJlIGVtcHR5JykKICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB0aHJvdyBuZXcgRXJyb3IoJ09iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSAiJHtuYW1lfSIgYWxyZWFkeSBleGlzdHMnKQogICAgLy8gc2V0CiAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gSUdOT1JFX1NVQlNUUkVBTQogIH0KCiAgLy8gc3RyZWFtIHBsdW1iaW5nCgogIF9yZWFkICgpIHt9CgogIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7CiAgICAvLyBwYXJzZSBtZXNzYWdlCiAgICBjb25zdCBuYW1lID0gY2h1bmsubmFtZQogICAgY29uc3QgZGF0YSA9IGNodW5rLmRhdGEKICAgIGlmICghbmFtZSkgewogICAgICBjb25zb2xlLndhcm4oYE9iamVjdE11bHRpcGxleCAtIG1hbGZvcm1lZCBjaHVuayB3aXRob3V0IG5hbWUgIiR7Y2h1bmt9ImApCiAgICAgIHJldHVybiBjYWxsYmFjaygpCiAgICB9CgogICAgLy8gZ2V0IGNvcnJlc3BvbmRpbmcgc3Vic3RyZWFtCiAgICBjb25zdCBzdWJzdHJlYW0gPSB0aGlzLl9zdWJzdHJlYW1zW25hbWVdCiAgICBpZiAoIXN1YnN0cmVhbSkgewogICAgICBjb25zb2xlLndhcm4oYE9iamVjdE11bHRpcGxleCAtIG9ycGhhbmVkIGRhdGEgZm9yIHN0cmVhbSAiJHtuYW1lfSJgKQogICAgICByZXR1cm4gY2FsbGJhY2soKQogICAgfQoKICAgIC8vIHB1c2ggZGF0YSBpbnRvIHN1YnN0cmVhbQogICAgaWYgKHN1YnN0cmVhbSAhPT0gSUdOT1JFX1NVQlNUUkVBTSkgewogICAgICBzdWJzdHJlYW0ucHVzaChkYXRhKQogICAgfQoKICAgIGNhbGxiYWNrKCkKICB9Cgp9CgoKY2xhc3MgU3Vic3RyZWFtIGV4dGVuZHMgRHVwbGV4IHsKCiAgY29uc3RydWN0b3IgKHsgcGFyZW50LCBuYW1lIH0pIHsKICAgIHN1cGVyKHsKICAgICAgb2JqZWN0TW9kZTogdHJ1ZSwKICAgIH0pCgogICAgdGhpcy5fcGFyZW50ID0gcGFyZW50CiAgICB0aGlzLl9uYW1lID0gbmFtZQogIH0KCiAgX3JlYWQgKCkge30KCiAgX3dyaXRlIChjaHVuaywgZW5jLCBjYWxsYmFjaykgewogICAgdGhpcy5fcGFyZW50LnB1c2goewogICAgICBuYW1lOiB0aGlzLl9uYW1lLAogICAgICBkYXRhOiBjaHVuaywKICAgIH0pCiAgICBjYWxsYmFjaygpCiAgfQoKfQoKbW9kdWxlLmV4cG9ydHMgPSBPYmplY3RNdWx0aXBsZXgKCi8vIHV0aWwKCmZ1bmN0aW9uIGFueVN0cmVhbUVuZChzdHJlYW0sIF9jYikgewogIGNvbnN0IGNiID0gb25jZShfY2IpCiAgZW5kT2ZTdHJlYW0oc3RyZWFtLCB7IHJlYWRhYmxlOiBmYWxzZSB9LCBjYikKICBlbmRPZlN0cmVhbShzdHJlYW0sIHsgd3JpdGFibGU6IGZhbHNlIH0sIGNiKQp9Cn0seyJlbmQtb2Ytc3RyZWFtIjo5OSwib25jZSI6MTE1LCJyZWFkYWJsZS1zdHJlYW0iOjEyOX1dLDExMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBfYXNzaWduID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9hc3NpZ24nKTsKCnZhciBfYXNzaWduMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Fzc2lnbik7Cgp2YXIgX3R5cGVvZjIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mJyk7Cgp2YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTsKCnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTsKCnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpOwoKdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTsKCnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTsKCnZhciBfY3JlYXRlQ2xhc3MyID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7Cgp2YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7Cgp2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTsKCnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7Cgp2YXIgX2luaGVyaXRzMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpOwoKdmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpOwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCnZhciBleHRlbmQgPSBfZGVyZXFfKCd4dGVuZCcpOwp2YXIgRXZlbnRFbWl0dGVyID0gX2RlcmVxXygnZXZlbnRzJyk7Cgp2YXIgT2JzZXJ2YWJsZVN0b3JlID0gZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHsKICAoMCwgX2luaGVyaXRzMy5kZWZhdWx0KShPYnNlcnZhYmxlU3RvcmUsIF9FdmVudEVtaXR0ZXIpOwoKICBmdW5jdGlvbiBPYnNlcnZhYmxlU3RvcmUoKSB7CiAgICB2YXIgaW5pdFN0YXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTsKICAgICgwLCBfY2xhc3NDYWxsQ2hlY2szLmRlZmF1bHQpKHRoaXMsIE9ic2VydmFibGVTdG9yZSk7CgogICAgLy8gc2V0IGluaXQgc3RhdGUKICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKE9ic2VydmFibGVTdG9yZS5fX3Byb3RvX18gfHwgKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoT2JzZXJ2YWJsZVN0b3JlKSkuY2FsbCh0aGlzKSk7CgogICAgX3RoaXMuX3N0YXRlID0gaW5pdFN0YXRlOwogICAgcmV0dXJuIF90aGlzOwogIH0KCiAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgZ2V0U3RhdGUKCgogICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKE9ic2VydmFibGVTdG9yZSwgW3sKICAgIGtleTogJ2dldFN0YXRlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZSgpIHsKICAgICAgcmV0dXJuIHRoaXMuX2dldFN0YXRlKCk7CiAgICB9CgogICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgcHV0U3RhdGUKCiAgfSwgewogICAga2V5OiAncHV0U3RhdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIHB1dFN0YXRlKG5ld1N0YXRlKSB7CiAgICAgIHRoaXMuX3B1dFN0YXRlKG5ld1N0YXRlKTsKICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCBuZXdTdGF0ZSk7CiAgICB9CiAgfSwgewogICAga2V5OiAndXBkYXRlU3RhdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHBhcnRpYWxTdGF0ZSkgewogICAgICAvLyBpZiBub24tbnVsbCBvYmplY3QsIG1lcmdlCiAgICAgIGlmIChwYXJ0aWFsU3RhdGUgJiYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkocGFydGlhbFN0YXRlKSkgPT09ICdvYmplY3QnKSB7CiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpOwogICAgICAgIHZhciBuZXdTdGF0ZSA9ICgwLCBfYXNzaWduMi5kZWZhdWx0KSh7fSwgc3RhdGUsIHBhcnRpYWxTdGF0ZSk7CiAgICAgICAgdGhpcy5wdXRTdGF0ZShuZXdTdGF0ZSk7CiAgICAgICAgLy8gaWYgbm90IG9iamVjdCwgdXNlIG5ldyB2YWx1ZQogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMucHV0U3RhdGUocGFydGlhbFN0YXRlKTsKICAgICAgfQogICAgfQoKICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzCgogIH0sIHsKICAgIGtleTogJ3N1YnNjcmliZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlKGhhbmRsZXIpIHsKICAgICAgdGhpcy5vbigndXBkYXRlJywgaGFuZGxlcik7CiAgICB9CgogICAgLy8gdW5zdWJzY3JpYmUgdG8gY2hhbmdlcwoKICB9LCB7CiAgICBrZXk6ICd1bnN1YnNjcmliZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gdW5zdWJzY3JpYmUoaGFuZGxlcikgewogICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVyKTsKICAgIH0KCiAgICAvLwogICAgLy8gcHJpdmF0ZQogICAgLy8KCiAgICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2UKCiAgfSwgewogICAga2V5OiAnX2dldFN0YXRlJywKICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RhdGUoKSB7CiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTsKICAgIH0KCiAgICAvLyB3cml0ZSB0byBwZXJzaXN0ZW5jZQoKICB9LCB7CiAgICBrZXk6ICdfcHV0U3RhdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9wdXRTdGF0ZShuZXdTdGF0ZSkgewogICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlOwogICAgfQogIH1dKTsKICByZXR1cm4gT2JzZXJ2YWJsZVN0b3JlOwp9KEV2ZW50RW1pdHRlcik7Cgptb2R1bGUuZXhwb3J0cyA9IE9ic2VydmFibGVTdG9yZTsKCn0seyJiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbiI6NSwiYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mIjo4LCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2siOjEyLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3MiOjEzLCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHMiOjE0LCJiYWJlbC1ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiI6MTUsImJhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YiOjE2LCJldmVudHMiOjEwMCwieHRlbmQiOjE0MX1dLDExNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBfZ2V0UHJvdG90eXBlT2YgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2YnKTsKCnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpOwoKdmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfZGVyZXFfKCdiYWJlbC1ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snKTsKCnZhciBfY2xhc3NDYWxsQ2hlY2szID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NDYWxsQ2hlY2syKTsKCnZhciBfY3JlYXRlQ2xhc3MyID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJyk7Cgp2YXIgX2NyZWF0ZUNsYXNzMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUNsYXNzMik7Cgp2YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2RlcmVxXygnYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nKTsKCnZhciBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMik7Cgp2YXIgX2luaGVyaXRzMiA9IF9kZXJlcV8oJ2JhYmVsLXJ1bnRpbWUvaGVscGVycy9pbmhlcml0cycpOwoKdmFyIF9pbmhlcml0czMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbmhlcml0czIpOwoKZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH0KCnZhciBEdXBsZXhTdHJlYW0gPSBfZGVyZXFfKCdzdHJlYW0nKS5EdXBsZXg7Cgptb2R1bGUuZXhwb3J0cyA9IGFzU3RyZWFtOwoKZnVuY3Rpb24gYXNTdHJlYW0ob2JzU3RvcmUpIHsKICByZXR1cm4gbmV3IE9ic1N0b3JlU3RyZWFtKG9ic1N0b3JlKTsKfQoKLy8KLy8KLy8KLy8KCnZhciBPYnNTdG9yZVN0cmVhbSA9IGZ1bmN0aW9uIChfRHVwbGV4U3RyZWFtKSB7CiAgKDAsIF9pbmhlcml0czMuZGVmYXVsdCkoT2JzU3RvcmVTdHJlYW0sIF9EdXBsZXhTdHJlYW0pOwoKICBmdW5jdGlvbiBPYnNTdG9yZVN0cmVhbShvYnNTdG9yZSkgewogICAgKDAsIF9jbGFzc0NhbGxDaGVjazMuZGVmYXVsdCkodGhpcywgT2JzU3RvcmVTdHJlYW0pOwoKICAgIC8vIGRvbnQgYnVmZmVyIG91dGdvaW5nIHVwZGF0ZXMKICAgIHZhciBfdGhpcyA9ICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjMuZGVmYXVsdCkodGhpcywgKE9ic1N0b3JlU3RyZWFtLl9fcHJvdG9fXyB8fCAoMCwgX2dldFByb3RvdHlwZU9mMi5kZWZhdWx0KShPYnNTdG9yZVN0cmVhbSkpLmNhbGwodGhpcywgewogICAgICAvLyBwYXNzIHZhbHVlcywgbm90IHNlcmlhbGl6YXRpb25zCiAgICAgIG9iamVjdE1vZGU6IHRydWUKICAgIH0pKTsKCiAgICBfdGhpcy5yZXN1bWUoKTsKICAgIC8vIHN1YnNjcmliZSB0byBvYnNTdG9yZSBjaGFuZ2VzCiAgICBfdGhpcy5vYnNTdG9yZSA9IG9ic1N0b3JlOwogICAgX3RoaXMub2JzU3RvcmUuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdGF0ZSkgewogICAgICByZXR1cm4gX3RoaXMucHVzaChzdGF0ZSk7CiAgICB9KTsKICAgIHJldHVybiBfdGhpczsKICB9CgogIC8vIGVtaXQgY3VycmVudCBzdGF0ZSBvbiBuZXcgZGVzdGluYXRpb24KCgogICgwLCBfY3JlYXRlQ2xhc3MzLmRlZmF1bHQpKE9ic1N0b3JlU3RyZWFtLCBbewogICAga2V5OiAncGlwZScsCiAgICB2YWx1ZTogZnVuY3Rpb24gcGlwZShkZXN0LCBvcHRpb25zKSB7CiAgICAgIHZhciByZXN1bHQgPSBEdXBsZXhTdHJlYW0ucHJvdG90eXBlLnBpcGUuY2FsbCh0aGlzLCBkZXN0LCBvcHRpb25zKTsKICAgICAgZGVzdC53cml0ZSh0aGlzLm9ic1N0b3JlLmdldFN0YXRlKCkpOwogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQoKICAgIC8vIHdyaXRlIGZyb20gaW5jb21taW5nIHN0cmVhbSB0byBzdGF0ZQoKICB9LCB7CiAgICBrZXk6ICdfd3JpdGUnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7CiAgICAgIHRoaXMub2JzU3RvcmUucHV0U3RhdGUoY2h1bmspOwogICAgICBjYWxsYmFjaygpOwogICAgfQoKICAgIC8vIG5vb3AgLSBvdXRnb2luZyBzdHJlYW0gaXMgYXNraW5nIHVzIGlmIHdlIGhhdmUgZGF0YSB3ZSBhcmVudCBnaXZpbmcgaXQKCiAgfSwgewogICAga2V5OiAnX3JlYWQnLAogICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWFkKHNpemUpIHt9CiAgfV0pOwogIHJldHVybiBPYnNTdG9yZVN0cmVhbTsKfShEdXBsZXhTdHJlYW0pOwoKfSx7ImJhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZiI6OCwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrIjoxMiwiYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzIjoxMywiYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzIjoxNCwiYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4iOjE1LCJzdHJlYW0iOjEzM31dLDExNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciB3cmFwcHkgPSBfZGVyZXFfKCd3cmFwcHknKQptb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKQptb2R1bGUuZXhwb3J0cy5zdHJpY3QgPSB3cmFwcHkob25jZVN0cmljdCkKCm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHsKICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHsKICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBvbmNlKHRoaXMpCiAgICB9LAogICAgY29uZmlndXJhYmxlOiB0cnVlCiAgfSkKCiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2VTdHJpY3QnLCB7CiAgICB2YWx1ZTogZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gb25jZVN0cmljdCh0aGlzKQogICAgfSwKICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZQogIH0pCn0pCgpmdW5jdGlvbiBvbmNlIChmbikgewogIHZhciBmID0gZnVuY3Rpb24gKCkgewogICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZQogICAgZi5jYWxsZWQgPSB0cnVlCiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykKICB9CiAgZi5jYWxsZWQgPSBmYWxzZQogIHJldHVybiBmCn0KCmZ1bmN0aW9uIG9uY2VTdHJpY3QgKGZuKSB7CiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7CiAgICBpZiAoZi5jYWxsZWQpCiAgICAgIHRocm93IG5ldyBFcnJvcihmLm9uY2VFcnJvcikKICAgIGYuY2FsbGVkID0gdHJ1ZQogICAgcmV0dXJuIGYudmFsdWUgPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpCiAgfQogIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCcKICBmLm9uY2VFcnJvciA9IG5hbWUgKyAiIHNob3VsZG4ndCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2UiCiAgZi5jYWxsZWQgPSBmYWxzZQogIHJldHVybiBmCn0KCn0seyJ3cmFwcHkiOjE0MH1dLDExNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CmNvbnN0IER1cGxleFN0cmVhbSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbScpLkR1cGxleApjb25zdCBpbmhlcml0cyA9IF9kZXJlcV8oJ3V0aWwnKS5pbmhlcml0cwoKbW9kdWxlLmV4cG9ydHMgPSBQb3N0TWVzc2FnZVN0cmVhbQoKaW5oZXJpdHMoUG9zdE1lc3NhZ2VTdHJlYW0sIER1cGxleFN0cmVhbSkKCmZ1bmN0aW9uIFBvc3RNZXNzYWdlU3RyZWFtIChvcHRzKSB7CiAgRHVwbGV4U3RyZWFtLmNhbGwodGhpcywgewogICAgb2JqZWN0TW9kZTogdHJ1ZSwKICB9KQoKICB0aGlzLl9uYW1lID0gb3B0cy5uYW1lCiAgdGhpcy5fdGFyZ2V0ID0gb3B0cy50YXJnZXQKICB0aGlzLl90YXJnZXRXaW5kb3cgPSBvcHRzLnRhcmdldFdpbmRvdyB8fCB3aW5kb3cKICB0aGlzLl9vcmlnaW4gPSAob3B0cy50YXJnZXRXaW5kb3cgPyAnKicgOiBsb2NhdGlvbi5vcmlnaW4pCgogIC8vIGluaXRpYWxpemF0aW9uIGZsYWdzCiAgdGhpcy5faW5pdCA9IGZhbHNlCiAgdGhpcy5faGF2ZVN5biA9IGZhbHNlCgogIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcyksIGZhbHNlKQogIC8vIHNlbmQgc3luY29yaXphdGlvbiBtZXNzYWdlCiAgdGhpcy5fd3JpdGUoJ1NZTicsIG51bGwsIG5vb3ApCiAgdGhpcy5jb3JrKCkKfQoKLy8gcHJpdmF0ZQpQb3N0TWVzc2FnZVN0cmVhbS5wcm90b3R5cGUuX29uTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkgewogIHZhciBtc2cgPSBldmVudC5kYXRhCgogIC8vIHZhbGlkYXRlIG1lc3NhZ2UKICBpZiAodGhpcy5fb3JpZ2luICE9PSAnKicgJiYgZXZlbnQub3JpZ2luICE9PSB0aGlzLl9vcmlnaW4pIHJldHVybgogIGlmIChldmVudC5zb3VyY2UgIT09IHRoaXMuX3RhcmdldFdpbmRvdykgcmV0dXJuCiAgaWYgKHR5cGVvZiBtc2cgIT09ICdvYmplY3QnKSByZXR1cm4KICBpZiAobXNnLnRhcmdldCAhPT0gdGhpcy5fbmFtZSkgcmV0dXJuCiAgaWYgKCFtc2cuZGF0YSkgcmV0dXJuCgogIGlmICghdGhpcy5faW5pdCkgewogICAgaWYgKG1zZy5kYXRhID09PSAnU1lOJykgewogICAgICB0aGlzLl9oYXZlU3luID0gdHJ1ZQogICAgICB0aGlzLl93cml0ZSgnQUNLJywgbnVsbCwgbm9vcCkKICAgIH0gZWxzZSBpZiAobXNnLmRhdGEgPT09ICdBQ0snKSB7CiAgICAgIHRoaXMuX2luaXQgPSB0cnVlCiAgICAgIGlmICghdGhpcy5faGF2ZVN5bikgewogICAgICAgIHRoaXMuX3dyaXRlKCdBQ0snLCBudWxsLCBub29wKQogICAgICB9CiAgICAgIHRoaXMudW5jb3JrKCkKICAgIH0KICB9IGVsc2UgewogICAgLy8gZm9yd2FyZCBtZXNzYWdlCiAgICB0cnkgewogICAgICB0aGlzLnB1c2gobXNnLmRhdGEpCiAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycikKICAgIH0KICB9Cn0KCi8vIHN0cmVhbSBwbHVtYmluZwpQb3N0TWVzc2FnZVN0cmVhbS5wcm90b3R5cGUuX3JlYWQgPSBub29wCgpQb3N0TWVzc2FnZVN0cmVhbS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYikgewogIHZhciBtZXNzYWdlID0gewogICAgdGFyZ2V0OiB0aGlzLl90YXJnZXQsCiAgICBkYXRhOiBkYXRhLAogIH0KICB0aGlzLl90YXJnZXRXaW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZSwgdGhpcy5fb3JpZ2luKQogIGNiKCkKfQoKLy8gdXRpbAoKZnVuY3Rpb24gbm9vcCAoKSB7fQoKfSx7InJlYWRhYmxlLXN0cmVhbSI6MTI5LCJ1dGlsIjoxMzh9XSwxMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MpewondXNlIHN0cmljdCc7CgppZiAoIXByb2Nlc3MudmVyc2lvbiB8fAogICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8CiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHsKICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrOwp9IGVsc2UgewogIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzcy5uZXh0VGljazsKfQoKZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHsKICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCciY2FsbGJhY2siIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpOwogIH0KICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsKICB2YXIgYXJncywgaTsKICBzd2l0Y2ggKGxlbikgewogIGNhc2UgMDoKICBjYXNlIDE6CiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7CiAgY2FzZSAyOgogICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkgewogICAgICBmbi5jYWxsKG51bGwsIGFyZzEpOwogICAgfSk7CiAgY2FzZSAzOgogICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkgewogICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpOwogICAgfSk7CiAgY2FzZSA0OgogICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7CiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7CiAgICB9KTsKICBkZWZhdWx0OgogICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTsKICAgIGkgPSAwOwogICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkgewogICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07CiAgICB9CiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7CiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpOwogICAgfSk7CiAgfQp9Cgp9KS5jYWxsKHRoaXMsX2RlcmVxXygnX3Byb2Nlc3MnKSkKfSx7Il9wcm9jZXNzIjoxOX1dLDExODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CnZhciBvbmNlID0gX2RlcmVxXygnb25jZScpCnZhciBlb3MgPSBfZGVyZXFfKCdlbmQtb2Ytc3RyZWFtJykKdmFyIGZzID0gX2RlcmVxXygnZnMnKSAvLyB3ZSBvbmx5IG5lZWQgZnMgdG8gZ2V0IHRoZSBSZWFkU3RyZWFtIGFuZCBXcml0ZVN0cmVhbSBwcm90b3R5cGVzCgp2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9Cgp2YXIgaXNGbiA9IGZ1bmN0aW9uIChmbikgewogIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicKfQoKdmFyIGlzRlMgPSBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgaWYgKCFmcykgcmV0dXJuIGZhbHNlIC8vIGJyb3dzZXIKICByZXR1cm4gKHN0cmVhbSBpbnN0YW5jZW9mIChmcy5SZWFkU3RyZWFtIHx8IG5vb3ApIHx8IHN0cmVhbSBpbnN0YW5jZW9mIChmcy5Xcml0ZVN0cmVhbSB8fCBub29wKSkgJiYgaXNGbihzdHJlYW0uY2xvc2UpCn0KCnZhciBpc1JlcXVlc3QgPSBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgaXNGbihzdHJlYW0uYWJvcnQpCn0KCnZhciBkZXN0cm95ZXIgPSBmdW5jdGlvbiAoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykgewogIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaykKCiAgdmFyIGNsb3NlZCA9IGZhbHNlCiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHsKICAgIGNsb3NlZCA9IHRydWUKICB9KQoKICBlb3Moc3RyZWFtLCB7cmVhZGFibGU6IHJlYWRpbmcsIHdyaXRhYmxlOiB3cml0aW5nfSwgZnVuY3Rpb24gKGVycikgewogICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycikKICAgIGNsb3NlZCA9IHRydWUKICAgIGNhbGxiYWNrKCkKICB9KQoKICB2YXIgZGVzdHJveWVkID0gZmFsc2UKICByZXR1cm4gZnVuY3Rpb24gKGVycikgewogICAgaWYgKGNsb3NlZCkgcmV0dXJuCiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm4KICAgIGRlc3Ryb3llZCA9IHRydWUKCiAgICBpZiAoaXNGUyhzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmNsb3NlKG5vb3ApIC8vIHVzZSBjbG9zZSBmb3IgZnMgc3RyZWFtcyB0byBhdm9pZCBmZCBsZWFrcwogICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCkgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnQKCiAgICBpZiAoaXNGbihzdHJlYW0uZGVzdHJveSkpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpCgogICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFcnJvcignc3RyZWFtIHdhcyBkZXN0cm95ZWQnKSkKICB9Cn0KCnZhciBjYWxsID0gZnVuY3Rpb24gKGZuKSB7CiAgZm4oKQp9Cgp2YXIgcGlwZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykgewogIHJldHVybiBmcm9tLnBpcGUodG8pCn0KCnZhciBwdW1wID0gZnVuY3Rpb24gKCkgewogIHZhciBzdHJlYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKQogIHZhciBjYWxsYmFjayA9IGlzRm4oc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdIHx8IG5vb3ApICYmIHN0cmVhbXMucG9wKCkgfHwgbm9vcAoKICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF0KICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB0aHJvdyBuZXcgRXJyb3IoJ3B1bXAgcmVxdWlyZXMgdHdvIHN0cmVhbXMgcGVyIG1pbmltdW0nKQoKICB2YXIgZXJyb3IKICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7CiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDEKICAgIHZhciB3cml0aW5nID0gaSA+IDAKICAgIHJldHVybiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBmdW5jdGlvbiAoZXJyKSB7CiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyCiAgICAgIGlmIChlcnIpIGRlc3Ryb3lzLmZvckVhY2goY2FsbCkKICAgICAgaWYgKHJlYWRpbmcpIHJldHVybgogICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpCiAgICAgIGNhbGxiYWNrKGVycm9yKQogICAgfSkKICB9KQoKICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSkKfQoKbW9kdWxlLmV4cG9ydHMgPSBwdW1wCgp9LHsiZW5kLW9mLXN0cmVhbSI6OTksImZzIjoxOCwib25jZSI6MTE1fV0sMTE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpOwoKfSx7Ii4vbGliL19zdHJlYW1fZHVwbGV4LmpzIjoxMjB9XSwxMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgovLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLgovLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzcwovLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tCi8vIFdyaXRhYmxlLgoKJ3VzZSBzdHJpY3QnOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KCnZhciBwcm9jZXNzTmV4dFRpY2sgPSBfZGVyZXFfKCdwcm9jZXNzLW5leHRpY2stYXJncycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikgewogIHZhciBrZXlzID0gW107CiAgZm9yICh2YXIga2V5IGluIG9iaikgewogICAga2V5cy5wdXNoKGtleSk7CiAgfXJldHVybiBrZXlzOwp9OwovKjwvcmVwbGFjZW1lbnQ+Ki8KCm1vZHVsZS5leHBvcnRzID0gRHVwbGV4OwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTsKdXRpbC5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKdmFyIFJlYWRhYmxlID0gX2RlcmVxXygnLi9fc3RyZWFtX3JlYWRhYmxlJyk7CnZhciBXcml0YWJsZSA9IF9kZXJlcV8oJy4vX3N0cmVhbV93cml0YWJsZScpOwoKdXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTsKCnZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpOwpmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHsKICB2YXIgbWV0aG9kID0ga2V5c1t2XTsKICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07Cn0KCmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7CiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpOwoKICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpOwogIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7CgogIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7CgogIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7CgogIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7CiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7CgogIHRoaXMub25jZSgnZW5kJywgb25lbmQpOwp9CgovLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyCmZ1bmN0aW9uIG9uZW5kKCkgewogIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsCiAgLy8gdGhlbiB3ZSdyZSBvay4KICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjsKCiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLgogIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLgogIHByb2Nlc3NOZXh0VGljayhvbkVuZE5ULCB0aGlzKTsKfQoKZnVuY3Rpb24gb25FbmROVChzZWxmKSB7CiAgc2VsZi5lbmQoKTsKfQoKT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7CiAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7CiAgfSwKICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgewogICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtCiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0CiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkgewogICAgICByZXR1cm47CiAgICB9CgogICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseQogICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkCiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlOwogICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTsKICB9Cn0pOwoKRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7CiAgdGhpcy5wdXNoKG51bGwpOwogIHRoaXMuZW5kKCk7CgogIHByb2Nlc3NOZXh0VGljayhjYiwgZXJyKTsKfTsKCmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHsKICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykgewogICAgZih4c1tpXSwgaSk7CiAgfQp9Cn0seyIuL19zdHJlYW1fcmVhZGFibGUiOjEyMiwiLi9fc3RyZWFtX3dyaXRhYmxlIjoxMjQsImNvcmUtdXRpbC1pcyI6OTgsImluaGVyaXRzIjoxMDIsInByb2Nlc3MtbmV4dGljay1hcmdzIjoxMTd9XSwxMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgovLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS4KLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uCi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuCgondXNlIHN0cmljdCc7Cgptb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoOwoKdmFyIFRyYW5zZm9ybSA9IF9kZXJlcV8oJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTsKCi8qPHJlcGxhY2VtZW50PiovCnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7CnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7CgpmdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7CiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTsKCiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7Cn0KClBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKICBjYihudWxsLCBjaHVuayk7Cn07Cn0seyIuL19zdHJlYW1fdHJhbnNmb3JtIjoxMjMsImNvcmUtdXRpbC1pcyI6OTgsImluaGVyaXRzIjoxMDJ9XSwxMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewooZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXsKLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuCi8vCi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhCi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUKLy8gIlNvZnR3YXJlIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZwovLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsCi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQKLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlCi8vIGZvbGxvd2luZyBjb25kaXRpb25zOgovLwovLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZAovLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS4KLy8KLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MKLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRgovLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOCi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLAovLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IKLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRQovLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLgoKJ3VzZSBzdHJpY3QnOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KCnZhciBwcm9jZXNzTmV4dFRpY2sgPSBfZGVyZXFfKCdwcm9jZXNzLW5leHRpY2stYXJncycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7CgovKjxyZXBsYWNlbWVudD4qLwp2YXIgaXNBcnJheSA9IF9kZXJlcV8oJ2lzYXJyYXknKTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgRHVwbGV4OwovKjwvcmVwbGFjZW1lbnQ+Ki8KClJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIEVFID0gX2RlcmVxXygnZXZlbnRzJykuRXZlbnRFbWl0dGVyOwoKdmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7CiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDsKfTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgU3RyZWFtID0gX2RlcmVxXygnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8vIFRPRE8oYm1ldXJlcik6IENoYW5nZSB0aGlzIGJhY2sgdG8gY29uc3Qgb25jZSBob2xlIGNoZWNrcyBhcmUKLy8gcHJvcGVybHkgb3B0aW1pemVkIGF3YXkgZWFybHkgaW4gSWduaXRpb24rVHVyYm9GYW4uCi8qPHJlcGxhY2VtZW50PiovCnZhciBCdWZmZXIgPSBfZGVyZXFfKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjsKdmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTsKZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykgewogIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7Cn0KZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHsKICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTsKfQovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7CnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBkZWJ1Z1V0aWwgPSBfZGVyZXFfKCd1dGlsJyk7CnZhciBkZWJ1ZyA9IHZvaWQgMDsKaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHsKICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7Cn0gZWxzZSB7CiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTsKfQovKjwvcmVwbGFjZW1lbnQ+Ki8KCnZhciBCdWZmZXJMaXN0ID0gX2RlcmVxXygnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTsKdmFyIGRlc3Ryb3lJbXBsID0gX2RlcmVxXygnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTsKdmFyIFN0cmluZ0RlY29kZXI7Cgp1dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pOwoKdmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTsKCmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHsKICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93bgogIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLgogIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHsKICAgIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOwogIH0gZWxzZSB7CiAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55CiAgICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHMKICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGUKICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay4KICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dOwogIH0KfQoKZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHsKICBEdXBsZXggPSBEdXBsZXggfHwgX2RlcmVxXygnLi9fc3RyZWFtX2R1cGxleCcpOwoKICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKCiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG8KICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheQogIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlOwoKICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsKCiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXIKICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zICJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyIgogIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7CiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDsKICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTsKCiAgLy8gY2FzdCB0byBpbnRzLgogIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTsKCiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGUKICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhbgogIC8vIGFycmF5LnNoaWZ0KCkKICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7CiAgdGhpcy5sZW5ndGggPSAwOwogIHRoaXMucGlwZXMgPSBudWxsOwogIHRoaXMucGlwZXNDb3VudCA9IDA7CiAgdGhpcy5mbG93aW5nID0gbnVsbDsKICB0aGlzLmVuZGVkID0gZmFsc2U7CiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7CiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7CgogIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWQKICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZQogIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCAibGF0ZXIiIHNob3VsZCBnZW5lcmFsbHkgYWxzbwogIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuCiAgdGhpcy5zeW5jID0gdHJ1ZTsKCiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXkKICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi4KICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlOwogIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7CiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlOwogIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7CgogIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZAogIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7CgogIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmcKICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuCiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLgogIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnOwoKICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpcwogIHRoaXMuYXdhaXREcmFpbiA9IDA7CgogIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWQKICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7CgogIHRoaXMuZGVjb2RlciA9IG51bGw7CiAgdGhpcy5lbmNvZGluZyA9IG51bGw7CiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHsKICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IF9kZXJlcV8oJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7CiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTsKICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nOwogIH0KfQoKZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykgewogIER1cGxleCA9IER1cGxleCB8fCBfZGVyZXFfKCcuL19zdHJlYW1fZHVwbGV4Jyk7CgogIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7CgogIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTsKCiAgLy8gbGVnYWN5CiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7CgogIGlmIChvcHRpb25zKSB7CiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDsKCiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTsKICB9CgogIFN0cmVhbS5jYWxsKHRoaXMpOwp9CgpPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywgewogIGdldDogZnVuY3Rpb24gKCkgewogICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7CiAgfSwKICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkgewogICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtCiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0CiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHsKICAgICAgcmV0dXJuOwogICAgfQoKICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHkKICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZAogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTsKICB9Cn0pOwoKUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95OwpSZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTsKUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHsKICB0aGlzLnB1c2gobnVsbCk7CiAgY2IoZXJyKTsKfTsKCi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLgovLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCwKLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZAovLyB3cml0ZSgpIHNvbWUgbW9yZS4KUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICB2YXIgc2tpcENodW5rQ2hlY2s7CgogIGlmICghc3RhdGUub2JqZWN0TW9kZSkgewogICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHsKICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7CiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHsKICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7CiAgICAgICAgZW5jb2RpbmcgPSAnJzsKICAgICAgfQogICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7CiAgICB9CiAgfSBlbHNlIHsKICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTsKICB9CgogIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTsKfTsKCi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpClJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7CiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTsKfTsKCmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwogIGlmIChjaHVuayA9PT0gbnVsbCkgewogICAgc3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTsKICB9IGVsc2UgewogICAgdmFyIGVyOwogICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTsKICAgIGlmIChlcikgewogICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkgewogICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7CiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTsKICAgICAgfQoKICAgICAgaWYgKGFkZFRvRnJvbnQpIHsKICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTsKICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkgewogICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykgewogICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTsKICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7CiAgICAgICAgfQogICAgICB9CiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7CiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTsKICAgIH0KICB9CgogIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpOwp9CgpmdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkgewogIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykgewogICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7CiAgICBzdHJlYW0ucmVhZCgwKTsKICB9IGVsc2UgewogICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby4KICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDsKICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7CgogICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7CiAgfQogIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7Cn0KCmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHsKICB2YXIgZXI7CiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHsKICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpOwogIH0KICByZXR1cm4gZXI7Cn0KCi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuCi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lCi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLAovLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYQovLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXQKLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXIKLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC4KZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7CiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTsKfQoKUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkgewogIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlOwp9OwoKLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuClJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHsKICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSBfZGVyZXFfKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyOwogIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7CiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYzsKICByZXR1cm4gdGhpczsKfTsKCi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUIKdmFyIE1BWF9IV00gPSAweDgwMDAwMDsKZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikgewogIGlmIChuID49IE1BWF9IV00pIHsKICAgIG4gPSBNQVhfSFdNOwogIH0gZWxzZSB7CiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW4KICAgIC8vIHRpbnkgYW1vdW50cwogICAgbi0tOwogICAgbiB8PSBuID4+PiAxOwogICAgbiB8PSBuID4+PiAyOwogICAgbiB8PSBuID4+PiA0OwogICAgbiB8PSBuID4+PiA4OwogICAgbiB8PSBuID4+PiAxNjsKICAgIG4rKzsKICB9CiAgcmV0dXJuIG47Cn0KCi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nCi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuCmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHsKICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7CiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxOwogIGlmIChuICE9PSBuKSB7CiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWUKICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDsKICB9CiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uCiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7CiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjsKICAvLyBEb24ndCBoYXZlIGVub3VnaAogIGlmICghc3RhdGUuZW5kZWQpIHsKICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICByZXR1cm4gMDsKICB9CiAgcmV0dXJuIHN0YXRlLmxlbmd0aDsKfQoKLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy4KUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikgewogIGRlYnVnKCdyZWFkJywgbik7CiAgbiA9IHBhcnNlSW50KG4sIDEwKTsKICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlOwogIHZhciBuT3JpZyA9IG47CgogIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKCiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZQogIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXIKICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi4KICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkgewogICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpOwogICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7CiAgICByZXR1cm4gbnVsbDsKICB9CgogIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsKCiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLgogIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7CiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTsKICAgIHJldHVybiBudWxsOwogIH0KCiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZQogIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpbgogIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWQKICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlCiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW4KICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC4KICAvLwogIC8vIFNvLCB0aGUgc3RlcHMgYXJlOgogIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG8KICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLgogIC8vCiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC4KICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXMKICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW4KICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlCiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy4KICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGwKICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0CiAgLy8gJ3JlYWRhYmxlJyBldGMuCiAgLy8KICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uCgogIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy4KICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlOwogIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTsKCiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lCiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykgewogICAgZG9SZWFkID0gdHJ1ZTsKICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7CiAgfQoKICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeQogIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS4KICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykgewogICAgZG9SZWFkID0gZmFsc2U7CiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7CiAgfSBlbHNlIGlmIChkb1JlYWQpIHsKICAgIGRlYnVnKCdkbyByZWFkJyk7CiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTsKICAgIHN0YXRlLnN5bmMgPSB0cnVlOwogICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC4KICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7CiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kCiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspOwogICAgc3RhdGUuc3luYyA9IGZhbHNlOwogICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSwKICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci4KICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTsKICB9CgogIHZhciByZXQ7CiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsOwoKICBpZiAocmV0ID09PSBudWxsKSB7CiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwogICAgbiA9IDA7CiAgfSBlbHNlIHsKICAgIHN0YXRlLmxlbmd0aCAtPSBuOwogIH0KCiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgewogICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93CiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuCiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwoKICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay4KICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7CiAgfQoKICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpOwoKICByZXR1cm4gcmV0Owp9OwoKZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47CiAgaWYgKHN0YXRlLmRlY29kZXIpIHsKICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7CiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7CiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTsKICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoOwogICAgfQogIH0KICBzdGF0ZS5lbmRlZCA9IHRydWU7CgogIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLgogIGVtaXRSZWFkYWJsZShzdHJlYW0pOwp9CgovLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXIKLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyCi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC4KZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkgewogIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTsKICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTsKICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkgewogICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpOwogICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTsKICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTsKICB9Cn0KCmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7CiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTsKICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTsKICBmbG93KHN0cmVhbSk7Cn0KCi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsCi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWQKLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWYKLy8gaXQncyBpbiBwcm9ncmVzcy4KLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSwKLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS4KZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkgewogICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlOwogICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTsKICB9Cn0KCmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHsKICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoOwogIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykgewogICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7CiAgICBzdHJlYW0ucmVhZCgwKTsKICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkKICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy4KICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7CiAgfQogIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7Cn0KCi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy4KLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC4KLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsICJsZW5ndGgiIGlzIHNvbWV3aGF0Ci8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC4KUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHsKICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTsKfTsKClJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7CiAgdmFyIHNyYyA9IHRoaXM7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKCiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7CiAgICBjYXNlIDA6CiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDsKICAgICAgYnJlYWs7CiAgICBjYXNlIDE6CiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTsKICAgICAgYnJlYWs7CiAgICBkZWZhdWx0OgogICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpOwogICAgICBicmVhazsKICB9CiAgc3RhdGUucGlwZXNDb3VudCArPSAxOwogIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7CgogIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7CgogIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7CiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3NOZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pOwoKICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7CiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHsKICAgIGRlYnVnKCdvbnVucGlwZScpOwogICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHsKICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkgewogICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7CiAgICAgICAgY2xlYW51cCgpOwogICAgICB9CiAgICB9CiAgfQoKICBmdW5jdGlvbiBvbmVuZCgpIHsKICAgIGRlYnVnKCdvbmVuZCcpOwogICAgZGVzdC5lbmQoKTsKICB9CgogIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXIKICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKCkKICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpcwogIC8vIHRvbyBzbG93LgogIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTsKICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pOwoKICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7CiAgZnVuY3Rpb24gY2xlYW51cCgpIHsKICAgIGRlYnVnKCdjbGVhbnVwJyk7CiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuCiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7CiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTsKICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTsKICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7CgogICAgY2xlYW5lZFVwID0gdHJ1ZTsKCiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzCiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnQKICAgIC8vIGZsb3dpbmcgYWdhaW4uCiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuCiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuCiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7CiAgfQoKICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cAogIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlCiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy4KICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uCiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTsKICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpOwogIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykgewogICAgZGVidWcoJ29uZGF0YScpOwogICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlOwogICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspOwogICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHsKICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlCiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlCiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuCiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLgogICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7CiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTsKICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrOwogICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlOwogICAgICB9CiAgICAgIHNyYy5wYXVzZSgpOwogICAgfQogIH0KCiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuCiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLgogIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHsKICAgIGRlYnVnKCdvbmVycm9yJywgZXIpOwogICAgdW5waXBlKCk7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpOwogICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTsKICB9CgogIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy4KICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7CgogIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuCiAgZnVuY3Rpb24gb25jbG9zZSgpIHsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTsKICAgIHVucGlwZSgpOwogIH0KICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7CiAgZnVuY3Rpb24gb25maW5pc2goKSB7CiAgICBkZWJ1Zygnb25maW5pc2gnKTsKICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7CiAgICB1bnBpcGUoKTsKICB9CiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7CgogIGZ1bmN0aW9uIHVucGlwZSgpIHsKICAgIGRlYnVnKCd1bnBpcGUnKTsKICAgIHNyYy51bnBpcGUoZGVzdCk7CiAgfQoKICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0bwogIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7CgogIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS4KICBpZiAoIXN0YXRlLmZsb3dpbmcpIHsKICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpOwogICAgc3JjLnJlc3VtZSgpOwogIH0KCiAgcmV0dXJuIGRlc3Q7Cn07CgpmdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHsKICByZXR1cm4gZnVuY3Rpb24gKCkgewogICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlOwogICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7CiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tOwogICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkgewogICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsKICAgICAgZmxvdyhzcmMpOwogICAgfQogIH07Cn0KClJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkgewogIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07CgogIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy4KICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7CgogIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS4KICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgewogICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuCiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7CgogICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7CgogICAgLy8gZ290IGEgbWF0Y2guCiAgICBzdGF0ZS5waXBlcyA9IG51bGw7CiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDsKICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTsKICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pOwogICAgcmV0dXJuIHRoaXM7CiAgfQoKICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLgoKICBpZiAoIWRlc3QpIHsKICAgIC8vIHJlbW92ZSBhbGwuCiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlczsKICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50OwogICAgc3RhdGUucGlwZXMgPSBudWxsOwogICAgc3RhdGUucGlwZXNDb3VudCA9IDA7CiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7CgogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykgewogICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTsKICAgIH1yZXR1cm4gdGhpczsKICB9CgogIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuCiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7CiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7CgogIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7CiAgc3RhdGUucGlwZXNDb3VudCAtPSAxOwogIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdOwoKICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pOwoKICByZXR1cm4gdGhpczsKfTsKCi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3IKLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmcKUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikgewogIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTsKCiAgaWYgKGV2ID09PSAnZGF0YScpIHsKICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZAogICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7CiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykgewogICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHsKICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOwogICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsKICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7CiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpOwogICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkgewogICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTsKICAgICAgfQogICAgfQogIH0KCiAgcmV0dXJuIHJlczsKfTsKUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uOwoKZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7CiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpOwogIHNlbGYucmVhZCgwKTsKfQoKLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSQovLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuClJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICBpZiAoIXN0YXRlLmZsb3dpbmcpIHsKICAgIGRlYnVnKCdyZXN1bWUnKTsKICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOwogICAgcmVzdW1lKHRoaXMsIHN0YXRlKTsKICB9CiAgcmV0dXJuIHRoaXM7Cn07CgpmdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkgewogIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7CiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlOwogICAgcHJvY2Vzc05leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpOwogIH0KfQoKZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7CiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpOwogICAgc3RyZWFtLnJlYWQoMCk7CiAgfQoKICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTsKICBzdGF0ZS5hd2FpdERyYWluID0gMDsKICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7CiAgZmxvdyhzdHJlYW0pOwogIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTsKfQoKUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkgewogIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpOwogIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7CiAgICBkZWJ1ZygncGF1c2UnKTsKICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlOwogICAgdGhpcy5lbWl0KCdwYXVzZScpOwogIH0KICByZXR1cm4gdGhpczsKfTsKCmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwogIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7CiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge30KfQoKLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS4KLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLgovLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS4KUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTsKICB2YXIgcGF1c2VkID0gZmFsc2U7CgogIHZhciBzZWxmID0gdGhpczsKICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHsKICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpOwogICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7CiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7CiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7CiAgICB9CgogICAgc2VsZi5wdXNoKG51bGwpOwogIH0pOwoKICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHsKICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTsKICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOwoKICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZQogICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuOwoKICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspOwogICAgaWYgKCFyZXQpIHsKICAgICAgcGF1c2VkID0gdHJ1ZTsKICAgICAgc3RyZWFtLnBhdXNlKCk7CiAgICB9CiAgfSk7CgogIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy4KICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy4KICBmb3IgKHZhciBpIGluIHN0cmVhbSkgewogICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7CiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7CiAgICAgICAgfTsKICAgICAgfShpKTsKICAgIH0KICB9CgogIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy4KICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykgewogICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgc2VsZi5lbWl0LmJpbmQoc2VsZiwga1Byb3h5RXZlbnRzW25dKSk7CiAgfQoKICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlCiAgLy8gdW5kZXJseWluZyBzdHJlYW0uCiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7CiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pOwogICAgaWYgKHBhdXNlZCkgewogICAgICBwYXVzZWQgPSBmYWxzZTsKICAgICAgc3RyZWFtLnJlc3VtZSgpOwogICAgfQogIH07CgogIHJldHVybiBzZWxmOwp9OwoKLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LgpSZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDsKCi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy4KLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC4KLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmcKLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS4KZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHsKICAvLyBub3RoaW5nIGJ1ZmZlcmVkCiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7CgogIHZhciByZXQ7CiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7CiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3QKICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTsKICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpOwogIH0gZWxzZSB7CiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdAogICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7CiAgfQoKICByZXR1cm4gcmV0Owp9CgovLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuCi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nCi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuCmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7CiAgdmFyIHJldDsKICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkgewogICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MKICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pOwogICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTsKICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkgewogICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoCiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7CiAgfSBlbHNlIHsKICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlcgogICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7CiAgfQogIHJldHVybiByZXQ7Cn0KCi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEKLy8gY2h1bmtzLgovLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZwovLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LgpmdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7CiAgdmFyIHAgPSBsaXN0LmhlYWQ7CiAgdmFyIGMgPSAxOwogIHZhciByZXQgPSBwLmRhdGE7CiAgbiAtPSByZXQubGVuZ3RoOwogIHdoaWxlIChwID0gcC5uZXh0KSB7CiAgICB2YXIgc3RyID0gcC5kYXRhOwogICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjsKICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7CiAgICBuIC09IG5iOwogICAgaWYgKG4gPT09IDApIHsKICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7CiAgICAgICAgKytjOwogICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbGlzdC5oZWFkID0gcDsKICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpOwogICAgICB9CiAgICAgIGJyZWFrOwogICAgfQogICAgKytjOwogIH0KICBsaXN0Lmxlbmd0aCAtPSBjOwogIHJldHVybiByZXQ7Cn0KCi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy4KLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmcKLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS4KZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkgewogIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7CiAgdmFyIHAgPSBsaXN0LmhlYWQ7CiAgdmFyIGMgPSAxOwogIHAuZGF0YS5jb3B5KHJldCk7CiAgbiAtPSBwLmRhdGEubGVuZ3RoOwogIHdoaWxlIChwID0gcC5uZXh0KSB7CiAgICB2YXIgYnVmID0gcC5kYXRhOwogICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjsKICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTsKICAgIG4gLT0gbmI7CiAgICBpZiAobiA9PT0gMCkgewogICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHsKICAgICAgICArK2M7CiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDsKICAgICAgfSBlbHNlIHsKICAgICAgICBsaXN0LmhlYWQgPSBwOwogICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7CiAgICAgIH0KICAgICAgYnJlYWs7CiAgICB9CiAgICArK2M7CiAgfQogIGxpc3QubGVuZ3RoIC09IGM7CiAgcmV0dXJuIHJldDsKfQoKZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlOwoKICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhCiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLgogIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJyJlbmRSZWFkYWJsZSgpIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpOwoKICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHsKICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTsKICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTsKICB9Cn0KCmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkgewogIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LgogIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHsKICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlOwogICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7CiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7CiAgfQp9CgpmdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7CiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHsKICAgIGYoeHNbaV0sIGkpOwogIH0KfQoKZnVuY3Rpb24gaW5kZXhPZih4cywgeCkgewogIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7CiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpOwogIH0KICByZXR1cm4gLTE7Cn0KfSkuY2FsbCh0aGlzLF9kZXJlcV8oJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSkKfSx7Ii4vX3N0cmVhbV9kdXBsZXgiOjEyMCwiLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QiOjEyNSwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kiOjEyNiwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbSI6MTI3LCJfcHJvY2VzcyI6MTksImNvcmUtdXRpbC1pcyI6OTgsImV2ZW50cyI6MTAwLCJpbmhlcml0cyI6MTAyLCJpc2FycmF5IjoxMDQsInByb2Nlc3MtbmV4dGljay1hcmdzIjoxMTcsInNhZmUtYnVmZmVyIjoxMzIsInN0cmluZ19kZWNvZGVyLyI6MTM0LCJ1dGlsIjoxOH1dLDEyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG8KLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSAiZmlsdGVyIiwKLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmUKLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZAovLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pCi8vCi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGEKLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsCi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlbgovLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuCi8vCi8vIEhlcmUncyBob3cgdGhpcyB3b3JrczoKLy8KLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlCi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYikKLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlcwovLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsCi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC4KLy8KLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW4KLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGUKLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlCi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0Ci8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50bwovLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuCi8vCi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSwKLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlciwKLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZwovLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpcwovLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55Ci8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW4KLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsCi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW4KLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsCi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkCi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuCi8vCi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmsKLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbAovLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC4KCid1c2Ugc3RyaWN0JzsKCm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtOwoKdmFyIER1cGxleCA9IF9kZXJlcV8oJy4vX3N0cmVhbV9kdXBsZXgnKTsKCi8qPHJlcGxhY2VtZW50PiovCnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7CnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpOwoKZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7CiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkgewogICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpOwogIH07CgogIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlOwogIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7CiAgdGhpcy53cml0ZWNiID0gbnVsbDsKICB0aGlzLndyaXRlY2h1bmsgPSBudWxsOwogIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7Cn0KCmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHsKICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlOwogIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlOwoKICB2YXIgY2IgPSB0cy53cml0ZWNiOwoKICBpZiAoIWNiKSB7CiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7CiAgfQoKICB0cy53cml0ZWNodW5rID0gbnVsbDsKICB0cy53cml0ZWNiID0gbnVsbDsKCiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTsKCiAgY2IoZXIpOwoKICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7CiAgcnMucmVhZGluZyA9IGZhbHNlOwogIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgewogICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspOwogIH0KfQoKZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHsKICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7CgogIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpOwoKICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTsKCiAgdmFyIHN0cmVhbSA9IHRoaXM7CgogIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLgogIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsKCiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzCiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZQogIC8vIHN5bmMgZ3VhcmQgZmxhZy4KICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTsKCiAgaWYgKG9wdGlvbnMpIHsKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtOwoKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoOwogIH0KCiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLgogIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24gKCkgewogICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7CiAgICAgIGRvbmUoc3RyZWFtLCBlciwgZGF0YSk7CiAgICB9KTtlbHNlIGRvbmUoc3RyZWFtKTsKICB9KTsKfQoKVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykgewogIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTsKICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTsKfTsKCi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIQovLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuCi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuCi8vCi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dAovLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLgovLwovLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzcwovLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91Ci8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuClRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7Cn07CgpUcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7CiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7CiAgdHMud3JpdGVjYiA9IGNiOwogIHRzLndyaXRlY2h1bmsgPSBjaHVuazsKICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7CiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHsKICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7CiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTsKICB9Cn07CgovLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLgovLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLgovLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLgpUcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHsKICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTsKCiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7CiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlOwogICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTsKICB9IGVsc2UgewogICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpbgogICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuCiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTsKICB9Cn07CgpUcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHsKICB2YXIgX3RoaXMgPSB0aGlzOwoKICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikgewogICAgY2IoZXJyMik7CiAgICBfdGhpcy5lbWl0KCdjbG9zZScpOwogIH0pOwp9OwoKZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7CiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpOwoKICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpOwoKICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zCiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkCiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlOwogIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7CgogIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7CgogIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpOwoKICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7Cn0KfSx7Ii4vX3N0cmVhbV9kdXBsZXgiOjEyMCwiY29yZS11dGlsLWlzIjo5OCwiaW5oZXJpdHMiOjEwMn1dLDEyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgovLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy4KLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsCi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLgoKJ3VzZSBzdHJpY3QnOwoKLyo8cmVwbGFjZW1lbnQ+Ki8KCnZhciBwcm9jZXNzTmV4dFRpY2sgPSBfZGVyZXFfKCdwcm9jZXNzLW5leHRpY2stYXJncycpOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7CgovKiA8cmVwbGFjZW1lbnQ+ICovCmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHsKICB0aGlzLmNodW5rID0gY2h1bms7CiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nOwogIHRoaXMuY2FsbGJhY2sgPSBjYjsKICB0aGlzLm5leHQgPSBudWxsOwp9CgovLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3QKLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtCmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHsKICB2YXIgX3RoaXMgPSB0aGlzOwoKICB0aGlzLm5leHQgPSBudWxsOwogIHRoaXMuZW50cnkgPSBudWxsOwogIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkgewogICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTsKICB9Owp9Ci8qIDwvcmVwbGFjZW1lbnQ+ICovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrOwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBEdXBsZXg7Ci8qPC9yZXBsYWNlbWVudD4qLwoKV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7CgovKjxyZXBsYWNlbWVudD4qLwp2YXIgdXRpbCA9IF9kZXJlcV8oJ2NvcmUtdXRpbC1pcycpOwp1dGlsLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTsKLyo8L3JlcGxhY2VtZW50PiovCgovKjxyZXBsYWNlbWVudD4qLwp2YXIgaW50ZXJuYWxVdGlsID0gewogIGRlcHJlY2F0ZTogX2RlcmVxXygndXRpbC1kZXByZWNhdGUnKQp9OwovKjwvcmVwbGFjZW1lbnQ+Ki8KCi8qPHJlcGxhY2VtZW50PiovCnZhciBTdHJlYW0gPSBfZGVyZXFfKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7Ci8qPC9yZXBsYWNlbWVudD4qLwoKLyo8cmVwbGFjZW1lbnQ+Ki8KdmFyIEJ1ZmZlciA9IF9kZXJlcV8oJ3NhZmUtYnVmZmVyJykuQnVmZmVyOwp2YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9OwpmdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7CiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTsKfQpmdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikgewogIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5Owp9Ci8qPC9yZXBsYWNlbWVudD4qLwoKdmFyIGRlc3Ryb3lJbXBsID0gX2RlcmVxXygnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTsKCnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7CgpmdW5jdGlvbiBub3AoKSB7fQoKZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHsKICBEdXBsZXggPSBEdXBsZXggfHwgX2RlcmVxXygnLi9fc3RyZWFtX2R1cGxleCcpOwoKICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsKCiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtCiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLgogIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlOwoKICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTsKCiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIHdyaXRlKCkgc3RhcnRzIHJldHVybmluZyBmYWxzZQogIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmCiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKQogIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7CiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDsKICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTsKCiAgLy8gY2FzdCB0byBpbnRzLgogIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTsKCiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZAogIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsKCiAgLy8gZHJhaW4gZXZlbnQgZmxhZy4KICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOwogIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpCiAgdGhpcy5lbmRpbmcgPSBmYWxzZTsKICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkCiAgdGhpcy5lbmRlZCA9IGZhbHNlOwogIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZAogIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsKCiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkCiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsKCiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/CiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nCiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC4KICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlOwogIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsKCiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZwogIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS4KICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guCiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7CgogIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50CiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZwogIC8vIHNvY2tldCBvciBmaWxlLgogIHRoaXMubGVuZ3RoID0gMDsKCiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS4KICB0aGlzLndyaXRpbmcgPSBmYWxzZTsKCiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbAogIHRoaXMuY29ya2VkID0gMDsKCiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksCiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnkKICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCAibGF0ZXIiIHNob3VsZCBnZW5lcmFsbHkgYWxzbwogIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLgogIHRoaXMuc3luYyA9IHRydWU7CgogIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2gKICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndAogIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLgogIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOwoKICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpCiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7CiAgICBvbndyaXRlKHN0cmVhbSwgZXIpOwogIH07CgogIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKQogIHRoaXMud3JpdGVjYiA9IG51bGw7CgogIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC4KICB0aGlzLndyaXRlbGVuID0gMDsKCiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsOwogIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CgogIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzCiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkCiAgdGhpcy5wZW5kaW5nY2IgPSAwOwoKICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzCiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXMKICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7CgogIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluCiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsKCiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHMKICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsKCiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5cwogIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d28KICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpOwp9CgpXcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7CiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDsKICB2YXIgb3V0ID0gW107CiAgd2hpbGUgKGN1cnJlbnQpIHsKICAgIG91dC5wdXNoKGN1cnJlbnQpOwogICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDsKICB9CiAgcmV0dXJuIG91dDsKfTsKCihmdW5jdGlvbiAoKSB7CiAgdHJ5IHsKICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHsKICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTsKICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpCiAgICB9KTsKICB9IGNhdGNoIChfKSB7fQp9KSgpOwoKLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsCi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS4KdmFyIHJlYWxIYXNJbnN0YW5jZTsKaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykgewogIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdOwogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7CiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkgewogICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7CgogICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7CiAgICB9CiAgfSk7Cn0gZWxzZSB7CiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkgewogICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7CiAgfTsKfQoKZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykgewogIER1cGxleCA9IER1cGxleCB8fCBfZGVyZXFfKCcuL19zdHJlYW1fZHVwbGV4Jyk7CgogIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLgogIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYAogIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC4KCiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlCiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yCiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLgogIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHsKICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7CiAgfQoKICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7CgogIC8vIGxlZ2FjeS4KICB0aGlzLndyaXRhYmxlID0gdHJ1ZTsKCiAgaWYgKG9wdGlvbnMpIHsKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlOwoKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2OwoKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95OwoKICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsOwogIH0KCiAgU3RyZWFtLmNhbGwodGhpcyk7Cn0KCi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy4KV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7CiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTsKfTsKCmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikgewogIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7CiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2IKICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7Cn0KCi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXIKLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZAovLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuCmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7CiAgdmFyIHZhbGlkID0gdHJ1ZTsKICB2YXIgZXIgPSBmYWxzZTsKCiAgaWYgKGNodW5rID09PSBudWxsKSB7CiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7CiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHsKICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpOwogIH0KICBpZiAoZXIpIHsKICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTsKICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpOwogICAgdmFsaWQgPSBmYWxzZTsKICB9CiAgcmV0dXJuIHZhbGlkOwp9CgpXcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CiAgdmFyIHJldCA9IGZhbHNlOwogIHZhciBpc0J1ZiA9IF9pc1VpbnQ4QXJyYXkoY2h1bmspICYmICFzdGF0ZS5vYmplY3RNb2RlOwoKICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHsKICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7CiAgfQoKICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7CiAgICBjYiA9IGVuY29kaW5nOwogICAgZW5jb2RpbmcgPSBudWxsOwogIH0KCiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7CgogIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wOwoKICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHsKICAgIHN0YXRlLnBlbmRpbmdjYisrOwogICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpOwogIH0KCiAgcmV0dXJuIHJldDsKfTsKCldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkgewogIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CgogIHN0YXRlLmNvcmtlZCsrOwp9OwoKV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHsKICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlOwoKICBpZiAoc3RhdGUuY29ya2VkKSB7CiAgICBzdGF0ZS5jb3JrZWQtLTsKCiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7CiAgfQp9OwoKV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykgewogIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLgogIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7CiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTsKICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nOwogIHJldHVybiB0aGlzOwp9OwoKZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykgewogIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7CiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7CiAgfQogIHJldHVybiBjaHVuazsKfQoKLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzCi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlCi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuCmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHsKICBpZiAoIWlzQnVmKSB7CiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTsKICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHsKICAgICAgaXNCdWYgPSB0cnVlOwogICAgICBlbmNvZGluZyA9ICdidWZmZXInOwogICAgICBjaHVuayA9IG5ld0NodW5rOwogICAgfQogIH0KICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7CgogIHN0YXRlLmxlbmd0aCArPSBsZW47CgogIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrOwogIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLgogIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlOwoKICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHsKICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDsKICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7CiAgICAgIGNodW5rOiBjaHVuaywKICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLAogICAgICBpc0J1ZjogaXNCdWYsCiAgICAgIGNhbGxiYWNrOiBjYiwKICAgICAgbmV4dDogbnVsbAogICAgfTsKICAgIGlmIChsYXN0KSB7CiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7CiAgICB9IGVsc2UgewogICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0OwogICAgfQogICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTsKICB9IGVsc2UgewogICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTsKICB9CgogIHJldHVybiByZXQ7Cn0KCmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHsKICBzdGF0ZS53cml0ZWxlbiA9IGxlbjsKICBzdGF0ZS53cml0ZWNiID0gY2I7CiAgc3RhdGUud3JpdGluZyA9IHRydWU7CiAgc3RhdGUuc3luYyA9IHRydWU7CiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpOwogIHN0YXRlLnN5bmMgPSBmYWxzZTsKfQoKZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikgewogIC0tc3RhdGUucGVuZGluZ2NiOwoKICBpZiAoc3luYykgewogICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseQogICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2sKICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpOwogICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW4KICAgIC8vIGFmdGVyIGVycm9yCiAgICBwcm9jZXNzTmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpOwogICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7CiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7CiAgfSBlbHNlIHsKICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZgogICAgLy8gaXQgaXMgYXN5bmMKICAgIGNiKGVyKTsKICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlOwogICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpOwogICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdAogICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvcgogICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7CiAgfQp9CgpmdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHsKICBzdGF0ZS53cml0aW5nID0gZmFsc2U7CiAgc3RhdGUud3JpdGVjYiA9IG51bGw7CiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuOwogIHN0YXRlLndyaXRlbGVuID0gMDsKfQoKZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7CiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlOwogIHZhciBzeW5jID0gc3RhdGUuc3luYzsKICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiOwoKICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpOwoKICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2UgewogICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXQKICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpOwoKICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHsKICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7CiAgICB9CgogICAgaWYgKHN5bmMpIHsKICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki8KICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpOwogICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki8KICAgIH0gZWxzZSB7CiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTsKICAgIH0KICB9Cn0KCmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7CiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpOwogIHN0YXRlLnBlbmRpbmdjYi0tOwogIGNiKCk7CiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7Cn0KCi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0Ci8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm4KLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci4KZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHsKICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikgewogICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7CiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTsKICB9Cn0KCi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0CmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHsKICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTsKICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7CgogIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7CiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpCiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50OwogICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTsKICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7CiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTsKCiAgICB2YXIgY291bnQgPSAwOwogICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlOwogICAgd2hpbGUgKGVudHJ5KSB7CiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTsKICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlOwogICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7CiAgICAgIGNvdW50ICs9IDE7CiAgICB9CiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7CgogICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpOwoKICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lCiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGUKICAgIHN0YXRlLnBlbmRpbmdjYisrOwogICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CiAgICBpZiAoaG9sZGVyLm5leHQpIHsKICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7CiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDsKICAgIH0gZWxzZSB7CiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTsKICAgIH0KICB9IGVsc2UgewogICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZQogICAgd2hpbGUgKGVudHJ5KSB7CiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rOwogICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZzsKICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7CiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDsKCiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7CiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDsKICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW4KICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy4KICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseQogICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS4KICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHsKICAgICAgICBicmVhazsKICAgICAgfQogICAgfQoKICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7CiAgfQoKICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7CiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7CiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOwp9CgpXcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHsKICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTsKfTsKCldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDsKCldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikgewogIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7CgogIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHsKICAgIGNiID0gY2h1bms7CiAgICBjaHVuayA9IG51bGw7CiAgICBlbmNvZGluZyA9IG51bGw7CiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHsKICAgIGNiID0gZW5jb2Rpbmc7CiAgICBlbmNvZGluZyA9IG51bGw7CiAgfQoKICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpOwoKICAvLyAuZW5kKCkgZnVsbHkgdW5jb3JrcwogIGlmIChzdGF0ZS5jb3JrZWQpIHsKICAgIHN0YXRlLmNvcmtlZCA9IDE7CiAgICB0aGlzLnVuY29yaygpOwogIH0KCiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLgogIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTsKfTsKCmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHsKICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nOwp9CmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7CiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7CiAgICBzdGF0ZS5wZW5kaW5nY2ItLTsKICAgIGlmIChlcnIpIHsKICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTsKICAgIH0KICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTsKICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTsKICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpOwogIH0pOwp9CmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7CiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHsKICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykgewogICAgICBzdGF0ZS5wZW5kaW5nY2IrKzsKICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlOwogICAgICBwcm9jZXNzTmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTsKICAgIH0gZWxzZSB7CiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTsKICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpOwogICAgfQogIH0KfQoKZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkgewogIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7CiAgaWYgKG5lZWQpIHsKICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTsKICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHsKICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlOwogICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7CiAgICB9CiAgfQogIHJldHVybiBuZWVkOwp9CgpmdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikgewogIHN0YXRlLmVuZGluZyA9IHRydWU7CiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7CiAgaWYgKGNiKSB7CiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpOwogIH0KICBzdGF0ZS5lbmRlZCA9IHRydWU7CiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7Cn0KCmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHsKICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5OwogIGNvcmtSZXEuZW50cnkgPSBudWxsOwogIHdoaWxlIChlbnRyeSkgewogICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7CiAgICBzdGF0ZS5wZW5kaW5nY2ItLTsKICAgIGNiKGVycik7CiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7CiAgfQogIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHsKICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTsKICB9IGVsc2UgewogICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTsKICB9Cn0KCk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7CiAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDsKICB9LAogIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW0KICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQKICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgICByZXR1cm47CiAgICB9CgogICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseQogICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkCiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlOwogIH0KfSk7CgpXcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7CldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95OwpXcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikgewogIHRoaXMuZW5kKCk7CiAgY2IoZXJyKTsKfTsKfSkuY2FsbCh0aGlzLF9kZXJlcV8oJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSkKfSx7Ii4vX3N0cmVhbV9kdXBsZXgiOjEyMCwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kiOjEyNiwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbSI6MTI3LCJfcHJvY2VzcyI6MTksImNvcmUtdXRpbC1pcyI6OTgsImluaGVyaXRzIjoxMDIsInByb2Nlc3MtbmV4dGljay1hcmdzIjoxMTcsInNhZmUtYnVmZmVyIjoxMzIsInV0aWwtZGVwcmVjYXRlIjoxMzV9XSwxMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewondXNlIHN0cmljdCc7CgovKjxyZXBsYWNlbWVudD4qLwoKZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsgfSB9Cgp2YXIgQnVmZmVyID0gX2RlcmVxXygnc2FmZS1idWZmZXInKS5CdWZmZXI7Ci8qPC9yZXBsYWNlbWVudD4qLwoKZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7CiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpOwp9Cgptb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsKICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkgewogICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpOwoKICAgIHRoaXMuaGVhZCA9IG51bGw7CiAgICB0aGlzLnRhaWwgPSBudWxsOwogICAgdGhpcy5sZW5ndGggPSAwOwogIH0KCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikgewogICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07CiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7CiAgICB0aGlzLnRhaWwgPSBlbnRyeTsKICAgICsrdGhpcy5sZW5ndGg7CiAgfTsKCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikgewogICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTsKICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7CiAgICB0aGlzLmhlYWQgPSBlbnRyeTsKICAgICsrdGhpcy5sZW5ndGg7CiAgfTsKCiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHsKICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuOwogICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhOwogICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7CiAgICAtLXRoaXMubGVuZ3RoOwogICAgcmV0dXJuIHJldDsKICB9OwoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkgewogICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDsKICAgIHRoaXMubGVuZ3RoID0gMDsKICB9OwoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7CiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJzsKICAgIHZhciBwID0gdGhpcy5oZWFkOwogICAgdmFyIHJldCA9ICcnICsgcC5kYXRhOwogICAgd2hpbGUgKHAgPSBwLm5leHQpIHsKICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7CiAgICB9cmV0dXJuIHJldDsKICB9OwoKICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikgewogICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApOwogICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7CiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApOwogICAgdmFyIHAgPSB0aGlzLmhlYWQ7CiAgICB2YXIgaSA9IDA7CiAgICB3aGlsZSAocCkgewogICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTsKICAgICAgaSArPSBwLmRhdGEubGVuZ3RoOwogICAgICBwID0gcC5uZXh0OwogICAgfQogICAgcmV0dXJuIHJldDsKICB9OwoKICByZXR1cm4gQnVmZmVyTGlzdDsKfSgpOwp9LHsic2FmZS1idWZmZXIiOjEzMn1dLDEyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCi8qPHJlcGxhY2VtZW50PiovCgp2YXIgcHJvY2Vzc05leHRUaWNrID0gX2RlcmVxXygncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTsKLyo8L3JlcGxhY2VtZW50PiovCgovLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJCmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikgewogIHZhciBfdGhpcyA9IHRoaXM7CgogIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7CiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDsKCiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7CiAgICBpZiAoY2IpIHsKICAgICAgY2IoZXJyKTsKICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7CiAgICAgIHByb2Nlc3NOZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTsKICAgIH0KICAgIHJldHVybjsKICB9CgogIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlcgogIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrcwoKICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlOwogIH0KCiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbAogIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7CiAgfQoKICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7CiAgICBpZiAoIWNiICYmIGVycikgewogICAgICBwcm9jZXNzTmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpOwogICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHsKICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlOwogICAgICB9CiAgICB9IGVsc2UgaWYgKGNiKSB7CiAgICAgIGNiKGVycik7CiAgICB9CiAgfSk7Cn0KCmZ1bmN0aW9uIHVuZGVzdHJveSgpIHsKICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkgewogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTsKICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlOwogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlOwogICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7CiAgfQoKICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkgewogICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTsKICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7CiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlOwogIH0KfQoKZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7CiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7Cn0KCm1vZHVsZS5leHBvcnRzID0gewogIGRlc3Ryb3k6IGRlc3Ryb3ksCiAgdW5kZXN0cm95OiB1bmRlc3Ryb3kKfTsKfSx7InByb2Nlc3MtbmV4dGljay1hcmdzIjoxMTd9XSwxMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewptb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjsKCn0seyJldmVudHMiOjEwMH1dLDEyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cm1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoCgp9LHsiLi9yZWFkYWJsZSI6MTI5fV0sMTI5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpOwpleHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7CmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzOwpleHBvcnRzLldyaXRhYmxlID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpOwpleHBvcnRzLkR1cGxleCA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7CmV4cG9ydHMuVHJhbnNmb3JtID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTsKZXhwb3J0cy5QYXNzVGhyb3VnaCA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTsKCn0seyIuL2xpYi9fc3RyZWFtX2R1cGxleC5qcyI6MTIwLCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIjoxMjEsIi4vbGliL19zdHJlYW1fcmVhZGFibGUuanMiOjEyMiwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiOjEyMywiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcyI6MTI0fV0sMTMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtCgp9LHsiLi9yZWFkYWJsZSI6MTI5fV0sMTMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7Cgp9LHsiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcyI6MTI0fV0sMTMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqLwp2YXIgYnVmZmVyID0gX2RlcmVxXygnYnVmZmVyJykKdmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXIKCi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnMKZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkgewogIGZvciAodmFyIGtleSBpbiBzcmMpIHsKICAgIGRzdFtrZXldID0gc3JjW2tleV0KICB9Cn0KaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykgewogIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyCn0gZWxzZSB7CiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJykKICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKQogIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlcgp9CgpmdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpCn0KCi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXIKY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcikKClNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkgewogIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKQogIH0KICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKQp9CgpTYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7CiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpCiAgfQogIHZhciBidWYgPSBCdWZmZXIoc2l6ZSkKICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7CiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgewogICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZykKICAgIH0gZWxzZSB7CiAgICAgIGJ1Zi5maWxsKGZpbGwpCiAgICB9CiAgfSBlbHNlIHsKICAgIGJ1Zi5maWxsKDApCiAgfQogIHJldHVybiBidWYKfQoKU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7CiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpCiAgfQogIHJldHVybiBCdWZmZXIoc2l6ZSkKfQoKU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkgewogIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKQogIH0KICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSkKfQoKfSx7ImJ1ZmZlciI6MjB9XSwxMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewovLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy4KLy8KLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEKLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZQovLyAiU29mdHdhcmUiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nCi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwKLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdAovLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUKLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6Ci8vCi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkCi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLgovLwovLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgIkFTIElTIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUwovLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GCi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4KLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sCi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUgovLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFCi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuCgptb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTsKCnZhciBFRSA9IF9kZXJlcV8oJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjsKdmFyIGluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTsKCmluaGVyaXRzKFN0cmVhbSwgRUUpOwpTdHJlYW0uUmVhZGFibGUgPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTsKU3RyZWFtLldyaXRhYmxlID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7ClN0cmVhbS5EdXBsZXggPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7ClN0cmVhbS5UcmFuc2Zvcm0gPSBfZGVyZXFfKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7ClN0cmVhbS5QYXNzVGhyb3VnaCA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpOwoKLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LngKU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTsKCgoKLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudAovLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLgoKZnVuY3Rpb24gU3RyZWFtKCkgewogIEVFLmNhbGwodGhpcyk7Cn0KClN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHsKICB2YXIgc291cmNlID0gdGhpczsKCiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7CiAgICBpZiAoZGVzdC53cml0YWJsZSkgewogICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkgewogICAgICAgIHNvdXJjZS5wYXVzZSgpOwogICAgICB9CiAgICB9CiAgfQoKICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpOwoKICBmdW5jdGlvbiBvbmRyYWluKCkgewogICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7CiAgICAgIHNvdXJjZS5yZXN1bWUoKTsKICAgIH0KICB9CgogIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7CgogIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW4KICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS4KICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHsKICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpOwogICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpOwogIH0KCiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7CiAgZnVuY3Rpb24gb25lbmQoKSB7CiAgICBpZiAoZGlkT25FbmQpIHJldHVybjsKICAgIGRpZE9uRW5kID0gdHJ1ZTsKCiAgICBkZXN0LmVuZCgpOwogIH0KCgogIGZ1bmN0aW9uIG9uY2xvc2UoKSB7CiAgICBpZiAoZGlkT25FbmQpIHJldHVybjsKICAgIGRpZE9uRW5kID0gdHJ1ZTsKCiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7CiAgfQoKICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuCiAgZnVuY3Rpb24gb25lcnJvcihlcikgewogICAgY2xlYW51cCgpOwogICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHsKICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS4KICAgIH0KICB9CgogIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTsKICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpOwoKICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLgogIGZ1bmN0aW9uIGNsZWFudXAoKSB7CiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpOwogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTsKCiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTsKICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTsKCiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7CiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpOwoKICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7CiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7CgogICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTsKICB9CgogIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7CiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApOwoKICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApOwoKICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpOwoKICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKQogIHJldHVybiBkZXN0Owp9OwoKfSx7ImV2ZW50cyI6MTAwLCJpbmhlcml0cyI6MTAyLCJyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIjoxMTksInJlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyI6MTI4LCJyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiOjEyOSwicmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyI6MTMwLCJyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiOjEzMX1dLDEzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7Cid1c2Ugc3RyaWN0JzsKCnZhciBCdWZmZXIgPSBfZGVyZXFfKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjsKCnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7CiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nOwogIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkgewogICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6CiAgICAgIHJldHVybiB0cnVlOwogICAgZGVmYXVsdDoKICAgICAgcmV0dXJuIGZhbHNlOwogIH0KfTsKCmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHsKICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JzsKICB2YXIgcmV0cmllZDsKICB3aGlsZSAodHJ1ZSkgewogICAgc3dpdGNoIChlbmMpIHsKICAgICAgY2FzZSAndXRmOCc6CiAgICAgIGNhc2UgJ3V0Zi04JzoKICAgICAgICByZXR1cm4gJ3V0ZjgnOwogICAgICBjYXNlICd1Y3MyJzoKICAgICAgY2FzZSAndWNzLTInOgogICAgICBjYXNlICd1dGYxNmxlJzoKICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgIHJldHVybiAndXRmMTZsZSc7CiAgICAgIGNhc2UgJ2xhdGluMSc6CiAgICAgIGNhc2UgJ2JpbmFyeSc6CiAgICAgICAgcmV0dXJuICdsYXRpbjEnOwogICAgICBjYXNlICdiYXNlNjQnOgogICAgICBjYXNlICdhc2NpaSc6CiAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgcmV0dXJuIGVuYzsKICAgICAgZGVmYXVsdDoKICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWQKICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgcmV0cmllZCA9IHRydWU7CiAgICB9CiAgfQp9OwoKLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lCi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3MKZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7CiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTsKICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTsKICByZXR1cm4gbmVuYyB8fCBlbmM7Cn0KCi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2YKLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlCi8vIGNoYXJhY3RlcnMuCmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7CmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHsKICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpOwogIHZhciBuYjsKICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHsKICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7CiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7CiAgICAgIG5iID0gNDsKICAgICAgYnJlYWs7CiAgICBjYXNlICd1dGY4JzoKICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDsKICAgICAgbmIgPSA0OwogICAgICBicmVhazsKICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7CiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kOwogICAgICBuYiA9IDM7CiAgICAgIGJyZWFrOwogICAgZGVmYXVsdDoKICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlOwogICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDsKICAgICAgcmV0dXJuOwogIH0KICB0aGlzLmxhc3ROZWVkID0gMDsKICB0aGlzLmxhc3RUb3RhbCA9IDA7CiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7Cn0KClN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1ZikgewogIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7CiAgdmFyIHI7CiAgdmFyIGk7CiAgaWYgKHRoaXMubGFzdE5lZWQpIHsKICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7CiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7CiAgICBpID0gdGhpcy5sYXN0TmVlZDsKICAgIHRoaXMubGFzdE5lZWQgPSAwOwogIH0gZWxzZSB7CiAgICBpID0gMDsKICB9CiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpOwogIHJldHVybiByIHx8ICcnOwp9OwoKU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDsKCi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyClN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDsKCi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIKU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7CiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkgewogICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTsKICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTsKICB9CiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTsKICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7Cn07CgovLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhCi8vIGNvbnRpbnVhdGlvbiBieXRlLgpmdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHsKICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDsKICByZXR1cm4gLTE7Cn0KCi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW4KLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNCkKLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC4KZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHsKICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxOwogIGlmIChqIDwgaSkgcmV0dXJuIDA7CiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pOwogIGlmIChuYiA+PSAwKSB7CiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxOwogICAgcmV0dXJuIG5iOwogIH0KICBpZiAoLS1qIDwgaSkgcmV0dXJuIDA7CiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7CiAgaWYgKG5iID49IDApIHsKICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7CiAgICByZXR1cm4gbmI7CiAgfQogIGlmICgtLWogPCBpKSByZXR1cm4gMDsKICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTsKICBpZiAobmIgPj0gMCkgewogICAgaWYgKG5iID4gMCkgewogICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7CiAgICB9CiAgICByZXR1cm4gbmI7CiAgfQogIHJldHVybiAwOwp9CgovLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXMKLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3QKLy8gb25lLCB3ZSAicmVwbGFjZSIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aAovLyBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzICgnXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2RpbmcKLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZQovLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLgovLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhCi8vIGxvb3AuCmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7CiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkgewogICAgc2VsZi5sYXN0TmVlZCA9IDA7CiAgICByZXR1cm4gJ1x1ZmZmZCcucmVwZWF0KHApOwogIH0KICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHsKICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHsKICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7CiAgICAgIHJldHVybiAnXHVmZmZkJy5yZXBlYXQocCArIDEpOwogICAgfQogICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7CiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHsKICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjsKICAgICAgICByZXR1cm4gJ1x1ZmZmZCcucmVwZWF0KHAgKyAyKTsKICAgICAgfQogICAgfQogIH0KfQoKLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLgpmdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7CiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7CiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7CiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7CiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkgewogICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7CiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7CiAgfQogIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpOwogIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDsKfQoKLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhCi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZAovLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS4KZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7CiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpOwogIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpOwogIHRoaXMubGFzdFRvdGFsID0gdG90YWw7CiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTsKICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpOwogIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpOwp9CgovLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGZvciBlYWNoIGJ1ZmZlcmVkIGJ5dGUgb2YgYSAocGFydGlhbCkKLy8gY2hhcmFjdGVyIG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBvdXRwdXQuCmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7CiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnOwogIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcdWZmZmQnLnJlcGVhdCh0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQpOwogIHJldHVybiByOwp9CgovLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlbgovLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaAovLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG8KLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS4KZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkgewogIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkgewogICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTsKICAgIGlmIChyKSB7CiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7CiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikgewogICAgICAgIHRoaXMubGFzdE5lZWQgPSAyOwogICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDsKICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTsKICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTsKICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByOwogIH0KICB0aGlzLmxhc3ROZWVkID0gMTsKICB0aGlzLmxhc3RUb3RhbCA9IDI7CiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07CiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTsKfQoKLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2UKLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuCmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1ZikgewogIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJzsKICBpZiAodGhpcy5sYXN0TmVlZCkgewogICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDsKICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7CiAgfQogIHJldHVybiByOwp9CgpmdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkgewogIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7CiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpOwogIHRoaXMubGFzdE5lZWQgPSAzIC0gbjsKICB0aGlzLmxhc3RUb3RhbCA9IDM7CiAgaWYgKG4gPT09IDEpIHsKICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdOwogIH0gZWxzZSB7CiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTsKICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdOwogIH0KICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7Cn0KCmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHsKICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7CiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpOwogIHJldHVybiByOwp9CgovLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpCmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1ZikgewogIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7Cn0KCmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHsKICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJzsKfQp9LHsic2FmZS1idWZmZXIiOjEzMn1dLDEzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7CihmdW5jdGlvbiAoZ2xvYmFsKXsKCi8qKgogKiBNb2R1bGUgZXhwb3J0cy4KICovCgptb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTsKCi8qKgogKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLgogKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LgogKgogKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC4KICoKICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zCiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLgogKgogKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnMKICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC4KICoKICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlCiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkCiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgImRlcHJlY2F0ZWQiIHZlcnNpb24gb2YgYGZuYAogKiBAYXBpIHB1YmxpYwogKi8KCmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykgewogIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkgewogICAgcmV0dXJuIGZuOwogIH0KCiAgdmFyIHdhcm5lZCA9IGZhbHNlOwogIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7CiAgICBpZiAoIXdhcm5lZCkgewogICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTsKICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkgewogICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zb2xlLndhcm4obXNnKTsKICAgICAgfQogICAgICB3YXJuZWQgPSB0cnVlOwogICAgfQogICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7CiAgfQoKICByZXR1cm4gZGVwcmVjYXRlZDsKfQoKLyoqCiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuCiAqCiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lCiAqIEByZXR1cm5zIHtCb29sZWFufQogKiBAYXBpIHByaXZhdGUKICovCgpmdW5jdGlvbiBjb25maWcgKG5hbWUpIHsKICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lcwogIHRyeSB7CiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTsKICB9IGNhdGNoIChfKSB7CiAgICByZXR1cm4gZmFsc2U7CiAgfQogIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdOwogIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlOwogIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7Cn0KCn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSAidW5kZWZpbmVkIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAidW5kZWZpbmVkIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiA/IHdpbmRvdyA6IHt9KQp9LHt9XSwxMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpewphcmd1bWVudHNbNF1bMTAyXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cykKfSx7ImR1cCI6MTAyfV0sMTM3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHsKICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnCiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbicKICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJwogICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7Cn0KfSx7fV0sMTM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7Ci8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLgovLwovLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYQovLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlCi8vICJTb2Z0d2FyZSIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcKLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLAovLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0Ci8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZQovLyBmb2xsb3dpbmcgY29uZGl0aW9uczoKLy8KLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQKLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuCi8vCi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCAiQVMgSVMiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTCi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YKLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTgovLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwKLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SCi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUKLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS4KCnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nOwpleHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHsKICBpZiAoIWlzU3RyaW5nKGYpKSB7CiAgICB2YXIgb2JqZWN0cyA9IFtdOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsKICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7CiAgICB9CiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7CiAgfQoKICB2YXIgaSA9IDE7CiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7CiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoOwogIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHsKICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnOwogICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDsKICAgIHN3aXRjaCAoeCkgewogICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTsKICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7CiAgICAgIGNhc2UgJyVqJzoKICAgICAgICB0cnkgewogICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7CiAgICAgICAgfSBjYXRjaCAoXykgewogICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJzsKICAgICAgICB9CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgcmV0dXJuIHg7CiAgICB9CiAgfSk7CiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHsKICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7CiAgICAgIHN0ciArPSAnICcgKyB4OwogICAgfSBlbHNlIHsKICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7CiAgICB9CiAgfQogIHJldHVybiBzdHI7Cn07CgoKLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC4KLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC4KLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC4KZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7CiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC4KICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7CiAgICByZXR1cm4gZnVuY3Rpb24oKSB7CiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogICAgfTsKICB9CgogIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHsKICAgIHJldHVybiBmbjsKICB9CgogIHZhciB3YXJuZWQgPSBmYWxzZTsKICBmdW5jdGlvbiBkZXByZWNhdGVkKCkgewogICAgaWYgKCF3YXJuZWQpIHsKICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikgewogICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpOwogICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikgewogICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7CiAgICAgIH0KICAgICAgd2FybmVkID0gdHJ1ZTsKICAgIH0KICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpOwogIH0KCiAgcmV0dXJuIGRlcHJlY2F0ZWQ7Cn07CgoKdmFyIGRlYnVncyA9IHt9Owp2YXIgZGVidWdFbnZpcm9uOwpleHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7CiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpCiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnOwogIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpOwogIGlmICghZGVidWdzW3NldF0pIHsKICAgIGlmIChuZXcgUmVnRXhwKCdcXGInICsgc2V0ICsgJ1xcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7CiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDsKICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHsKICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTsKICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTsKICAgICAgfTsKICAgIH0gZWxzZSB7CiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTsKICAgIH0KICB9CiAgcmV0dXJuIGRlYnVnc1tzZXRdOwp9OwoKCi8qKgogKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0CiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLgogKgogKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LgogKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LgogKi8KLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqLwpmdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykgewogIC8vIGRlZmF1bHQgb3B0aW9ucwogIHZhciBjdHggPSB7CiAgICBzZWVuOiBbXSwKICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yCiAgfTsKICAvLyBsZWdhY3kuLi4KICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07CiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTsKICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7CiAgICAvLyBsZWdhY3kuLi4KICAgIGN0eC5zaG93SGlkZGVuID0gb3B0czsKICB9IGVsc2UgaWYgKG9wdHMpIHsKICAgIC8vIGdvdCBhbiAib3B0aW9ucyIgb2JqZWN0CiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTsKICB9CiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9ucwogIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7CiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7CiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7CiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlOwogIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7CiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpOwp9CmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7CgoKLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzCmluc3BlY3QuY29sb3JzID0gewogICdib2xkJyA6IFsxLCAyMl0sCiAgJ2l0YWxpYycgOiBbMywgMjNdLAogICd1bmRlcmxpbmUnIDogWzQsIDI0XSwKICAnaW52ZXJzZScgOiBbNywgMjddLAogICd3aGl0ZScgOiBbMzcsIDM5XSwKICAnZ3JleScgOiBbOTAsIDM5XSwKICAnYmxhY2snIDogWzMwLCAzOV0sCiAgJ2JsdWUnIDogWzM0LCAzOV0sCiAgJ2N5YW4nIDogWzM2LCAzOV0sCiAgJ2dyZWVuJyA6IFszMiwgMzldLAogICdtYWdlbnRhJyA6IFszNSwgMzldLAogICdyZWQnIDogWzMxLCAzOV0sCiAgJ3llbGxvdycgOiBbMzMsIDM5XQp9OwoKLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlCmluc3BlY3Quc3R5bGVzID0gewogICdzcGVjaWFsJzogJ2N5YW4nLAogICdudW1iZXInOiAneWVsbG93JywKICAnYm9vbGVhbic6ICd5ZWxsb3cnLAogICd1bmRlZmluZWQnOiAnZ3JleScsCiAgJ251bGwnOiAnYm9sZCcsCiAgJ3N0cmluZyc6ICdncmVlbicsCiAgJ2RhdGUnOiAnbWFnZW50YScsCiAgLy8gIm5hbWUiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nCiAgJ3JlZ2V4cCc6ICdyZWQnCn07CgoKZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkgewogIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07CgogIGlmIChzdHlsZSkgewogICAgcmV0dXJuICdcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArCiAgICAgICAgICAgJ1x1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nOwogIH0gZWxzZSB7CiAgICByZXR1cm4gc3RyOwogIH0KfQoKCmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7CiAgcmV0dXJuIHN0cjsKfQoKCmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7CiAgdmFyIGhhc2ggPSB7fTsKCiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkgewogICAgaGFzaFt2YWxdID0gdHJ1ZTsKICB9KTsKCiAgcmV0dXJuIGhhc2g7Cn0KCgpmdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHsKICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuCiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0CiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmCiAgICAgIHZhbHVlICYmCiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiYKICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsCiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJgogICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay4KICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkgewogICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpOwogICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7CiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpOwogICAgfQogICAgcmV0dXJuIHJldDsKICB9CgogIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzCiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTsKICBpZiAocHJpbWl0aXZlKSB7CiAgICByZXR1cm4gcHJpbWl0aXZlOwogIH0KCiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LgogIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpOwogIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpOwoKICBpZiAoY3R4LnNob3dIaWRkZW4pIHsKICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7CiAgfQoKICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlCiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHgKICBpZiAoaXNFcnJvcih2YWx1ZSkKICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7CiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpOwogIH0KCiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLgogIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkgewogICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7CiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7CiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7CiAgICB9CiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7CiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7CiAgICB9CiAgICBpZiAoaXNEYXRlKHZhbHVlKSkgewogICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7CiAgICB9CiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHsKICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTsKICAgIH0KICB9CgogIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107CgogIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXkKICBpZiAoaXNBcnJheSh2YWx1ZSkpIHsKICAgIGFycmF5ID0gdHJ1ZTsKICAgIGJyYWNlcyA9IFsnWycsICddJ107CiAgfQoKICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnMKICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHsKICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7CiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJzsKICB9CgogIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzCiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkgewogICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7CiAgfQoKICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGUKICBpZiAoaXNEYXRlKHZhbHVlKSkgewogICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpOwogIH0KCiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvcgogIGlmIChpc0Vycm9yKHZhbHVlKSkgewogICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTsKICB9CgogIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkgewogICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07CiAgfQoKICBpZiAocmVjdXJzZVRpbWVzIDwgMCkgewogICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkgewogICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7CiAgICB9CiAgfQoKICBjdHguc2Vlbi5wdXNoKHZhbHVlKTsKCiAgdmFyIG91dHB1dDsKICBpZiAoYXJyYXkpIHsKICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpOwogIH0gZWxzZSB7CiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHsKICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpOwogICAgfSk7CiAgfQoKICBjdHguc2Vlbi5wb3AoKTsKCiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTsKfQoKCmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7CiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSkKICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpOwogIGlmIChpc1N0cmluZyh2YWx1ZSkpIHsKICAgIHZhciBzaW1wbGUgPSAnXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL14ifCIkL2csICcnKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCAiXFwnIikKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcIi9nLCAnIicpICsgJ1wnJzsKICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTsKICB9CiAgaWYgKGlzTnVtYmVyKHZhbHVlKSkKICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7CiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpCiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTsKICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgIm9iamVjdCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLgogIGlmIChpc051bGwodmFsdWUpKQogICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTsKfQoKCmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7CiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJzsKfQoKCmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHsKICB2YXIgb3V0cHV0ID0gW107CiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHsKICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkgewogICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLAogICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7CiAgICB9IGVsc2UgewogICAgICBvdXRwdXQucHVzaCgnJyk7CiAgICB9CiAgfQogIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHsKICAgIGlmICgha2V5Lm1hdGNoKC9eXGQrJC8pKSB7CiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsCiAgICAgICAgICBrZXksIHRydWUpKTsKICAgIH0KICB9KTsKICByZXR1cm4gb3V0cHV0Owp9CgoKZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkgewogIHZhciBuYW1lLCBzdHIsIGRlc2M7CiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9OwogIGlmIChkZXNjLmdldCkgewogICAgaWYgKGRlc2Muc2V0KSB7CiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpOwogICAgfSBlbHNlIHsKICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTsKICAgIH0KICB9IGVsc2UgewogICAgaWYgKGRlc2Muc2V0KSB7CiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7CiAgICB9CiAgfQogIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHsKICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7CiAgfQogIGlmICghc3RyKSB7CiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHsKICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7CiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpOwogICAgICB9CiAgICAgIGlmIChzdHIuaW5kZXhPZignXG4nKSA+IC0xKSB7CiAgICAgICAgaWYgKGFycmF5KSB7CiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHsKICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lOwogICAgICAgICAgfSkuam9pbignXG4nKS5zdWJzdHIoMik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN0ciA9ICdcbicgKyBzdHIuc3BsaXQoJ1xuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHsKICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTsKICAgICAgICAgIH0pLmpvaW4oJ1xuJyk7CiAgICAgICAgfQogICAgICB9CiAgICB9IGVsc2UgewogICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7CiAgICB9CiAgfQogIGlmIChpc1VuZGVmaW5lZChuYW1lKSkgewogICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxkKyQvKSkgewogICAgICByZXR1cm4gc3RyOwogICAgfQogICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTsKICAgIGlmIChuYW1lLm1hdGNoKC9eIihbYS16QS1aX11bYS16QS1aXzAtOV0qKSIkLykpIHsKICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7CiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpOwogICAgfSBlbHNlIHsKICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCAiXFwnIikKICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwiL2csICciJykKICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF4ifCIkKS9nLCAiJyIpOwogICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpOwogICAgfQogIH0KCiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyOwp9CgoKZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHsKICB2YXIgbnVtTGluZXNFc3QgPSAwOwogIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikgewogICAgbnVtTGluZXNFc3QrKzsKICAgIGlmIChjdXIuaW5kZXhPZignXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrOwogICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXHUwMDFiXFtcZFxkP20vZywgJycpLmxlbmd0aCArIDE7CiAgfSwgMCk7CgogIGlmIChsZW5ndGggPiA2MCkgewogICAgcmV0dXJuIGJyYWNlc1swXSArCiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xuICcpICsKICAgICAgICAgICAnICcgKwogICAgICAgICAgIG91dHB1dC5qb2luKCcsXG4gICcpICsKICAgICAgICAgICAnICcgKwogICAgICAgICAgIGJyYWNlc1sxXTsKICB9CgogIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07Cn0KCgovLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmAKLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuCmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHsKICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7Cn0KZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTsKCmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nOwp9CmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuOwoKZnVuY3Rpb24gaXNOdWxsKGFyZykgewogIHJldHVybiBhcmcgPT09IG51bGw7Cn0KZXhwb3J0cy5pc051bGwgPSBpc051bGw7CgpmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHsKICByZXR1cm4gYXJnID09IG51bGw7Cn0KZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkOwoKZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7CiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInOwp9CmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjsKCmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJzsKfQpleHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7CgpmdW5jdGlvbiBpc1N5bWJvbChhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7Cn0KZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sOwoKZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwOwp9CmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDsKCmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7CiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nOwp9CmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDsKCmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykgewogIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7Cn0KZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0OwoKZnVuY3Rpb24gaXNEYXRlKGQpIHsKICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJzsKfQpleHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTsKCmZ1bmN0aW9uIGlzRXJyb3IoZSkgewogIHJldHVybiBpc09iamVjdChlKSAmJgogICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTsKfQpleHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yOwoKZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHsKICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJzsKfQpleHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uOwoKZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7CiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fAogICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHwKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2wKICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7Cn0KZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlOwoKZXhwb3J0cy5pc0J1ZmZlciA9IF9kZXJlcV8oJy4vc3VwcG9ydC9pc0J1ZmZlcicpOwoKZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykgewogIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7Cn0KCgpmdW5jdGlvbiBwYWQobikgewogIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApOwp9CgoKdmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLAogICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddOwoKLy8gMjYgRmViIDE2OjE5OjM0CmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHsKICB2YXIgZCA9IG5ldyBEYXRlKCk7CiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksCiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSwKICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7CiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTsKfQoKCi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXAKZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHsKICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTsKfTsKCgovKioKICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLgogKgogKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lCiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZAogKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZQogKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXMKICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuCiAqCiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGUKICogICAgIHByb3RvdHlwZS4KICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uCiAqLwpleHBvcnRzLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTsKCmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7CiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdAogIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luOwoKICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7CiAgdmFyIGkgPSBrZXlzLmxlbmd0aDsKICB3aGlsZSAoaS0tKSB7CiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07CiAgfQogIHJldHVybiBvcmlnaW47Cn07CgpmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHsKICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7Cn0KCn0pLmNhbGwodGhpcyxfZGVyZXFfKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09ICJ1bmRlZmluZWQiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICJ1bmRlZmluZWQiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09ICJ1bmRlZmluZWQiID8gd2luZG93IDoge30pCn0seyIuL3N1cHBvcnQvaXNCdWZmZXIiOjEzNywiX3Byb2Nlc3MiOjE5LCJpbmhlcml0cyI6MTM2fV0sMTM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKKGZ1bmN0aW9uIChnbG9iYWwsQnVmZmVyKXsKX2RlcmVxXz1mdW5jdGlvbiB0KGUsbixyKXtmdW5jdGlvbiBvKGEscyl7aWYoIW5bYV0pe2lmKCFlW2FdKXt2YXIgYz0iZnVuY3Rpb24iPT10eXBlb2YgX2RlcmVxXyYmX2RlcmVxXztpZighcyYmYylyZXR1cm4gYyhhLCEwKTtpZihpKXJldHVybiBpKGEsITApO3ZhciB1PW5ldyBFcnJvcigiQ2Fubm90IGZpbmQgbW9kdWxlICciK2ErIiciKTt0aHJvdyB1LmNvZGU9Ik1PRFVMRV9OT1RfRk9VTkQiLHV9dmFyIGY9blthXT17ZXhwb3J0czp7fX07ZVthXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbih0KXt2YXIgbj1lW2FdWzFdW3RdO3JldHVybiBvKG58fHQpfSxmLGYuZXhwb3J0cyx0LGUsbixyKX1yZXR1cm4gblthXS5leHBvcnRzfWZvcih2YXIgaT0iZnVuY3Rpb24iPT10eXBlb2YgX2RlcmVxXyYmX2RlcmVxXyxhPTA7YTxyLmxlbmd0aDthKyspbyhyW2FdKTtyZXR1cm4gb30oezE6W2Z1bmN0aW9uKHQsZSxuKXtlLmV4cG9ydHM9W3tjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfb3duZXIiLHR5cGU6ImFkZHJlc3MifV0sbmFtZToibmFtZSIsb3V0cHV0czpbe25hbWU6Im9fbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJvd25lciIsb3V0cHV0czpbe25hbWU6IiIsdHlwZToiYWRkcmVzcyJ9XSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJjb250ZW50IixvdXRwdXRzOlt7bmFtZToiIix0eXBlOiJieXRlczMyIn1dLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiEwLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6ImFkZHIiLG91dHB1dHM6W3tuYW1lOiIiLHR5cGU6ImFkZHJlc3MifV0sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToicmVzZXJ2ZSIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJzdWJSZWdpc3RyYXIiLG91dHB1dHM6W3tuYW1lOiIiLHR5cGU6ImFkZHJlc3MifV0sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToiX25ld093bmVyIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6InRyYW5zZmVyIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn0se25hbWU6Il9yZWdpc3RyYXIiLHR5cGU6ImFkZHJlc3MifV0sbmFtZToic2V0U3ViUmVnaXN0cmFyIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbXSxuYW1lOiJSZWdpc3RyYXIiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToiX2EiLHR5cGU6ImFkZHJlc3MifSx7bmFtZToiX3ByaW1hcnkiLHR5cGU6ImJvb2wifV0sbmFtZToic2V0QWRkcmVzcyIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJfY29udGVudCIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJzZXRDb250ZW50IixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6ImRpc293biIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtpbmRleGVkOiExLG5hbWU6Il93aW5uZXIiLHR5cGU6ImFkZHJlc3MifV0sbmFtZToiQXVjdGlvbkVuZGVkIix0eXBlOiJldmVudCJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtpbmRleGVkOiExLG5hbWU6Il9iaWRkZXIiLHR5cGU6ImFkZHJlc3MifSx7aW5kZXhlZDohMSxuYW1lOiJfdmFsdWUiLHR5cGU6InVpbnQyNTYifV0sbmFtZToiTmV3QmlkIix0eXBlOiJldmVudCJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJuYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6IkNoYW5nZWQiLHR5cGU6ImV2ZW50In0se2Fub255bW91czohMSxpbnB1dHM6W3tpbmRleGVkOiEwLG5hbWU6Im5hbWUiLHR5cGU6ImJ5dGVzMzIifSx7aW5kZXhlZDohMCxuYW1lOiJhZGRyIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6IlByaW1hcnlDaGFuZ2VkIix0eXBlOiJldmVudCJ9XX0se31dLDI6W2Z1bmN0aW9uKHQsZSxuKXtlLmV4cG9ydHM9W3tjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJvd25lciIsb3V0cHV0czpbe25hbWU6IiIsdHlwZToiYWRkcmVzcyJ9XSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJfcmVmdW5kIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6ImRpc293biIsb3V0cHV0czpbXSx0eXBlOiJmdW5jdGlvbiJ9LHtjb25zdGFudDohMCxpbnB1dHM6W3tuYW1lOiJfbmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJhZGRyIixvdXRwdXRzOlt7bmFtZToiIix0eXBlOiJhZGRyZXNzIn1dLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn1dLG5hbWU6InJlc2VydmUiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToiX25hbWUiLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToiX25ld093bmVyIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6InRyYW5zZmVyIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6Il9uYW1lIix0eXBlOiJieXRlczMyIn0se25hbWU6Il9hIix0eXBlOiJhZGRyZXNzIn1dLG5hbWU6InNldEFkZHIiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7YW5vbnltb3VzOiExLGlucHV0czpbe2luZGV4ZWQ6ITAsbmFtZToibmFtZSIsdHlwZToiYnl0ZXMzMiJ9XSxuYW1lOiJDaGFuZ2VkIix0eXBlOiJldmVudCJ9XX0se31dLDM6W2Z1bmN0aW9uKHQsZSxuKXtlLmV4cG9ydHM9W3tjb25zdGFudDohMSxpbnB1dHM6W3tuYW1lOiJmcm9tIix0eXBlOiJieXRlczMyIn0se25hbWU6InRvIix0eXBlOiJhZGRyZXNzIn0se25hbWU6InZhbHVlIix0eXBlOiJ1aW50MjU2In1dLG5hbWU6InRyYW5zZmVyIixvdXRwdXRzOltdLHR5cGU6ImZ1bmN0aW9uIn0se2NvbnN0YW50OiExLGlucHV0czpbe25hbWU6ImZyb20iLHR5cGU6ImJ5dGVzMzIifSx7bmFtZToidG8iLHR5cGU6ImFkZHJlc3MifSx7bmFtZToiaW5kaXJlY3RJZCIsdHlwZToiYnl0ZXMzMiJ9LHtuYW1lOiJ2YWx1ZSIsdHlwZToidWludDI1NiJ9XSxuYW1lOiJpY2FwVHJhbnNmZXIiLG91dHB1dHM6W10sdHlwZToiZnVuY3Rpb24ifSx7Y29uc3RhbnQ6ITEsaW5wdXRzOlt7bmFtZToidG8iLHR5cGU6ImJ5dGVzMzIifV0sbmFtZToiZGVwb3NpdCIsb3V0cHV0czpbXSxwYXlhYmxlOiEwLHR5cGU6ImZ1bmN0aW9uIn0se2Fub255bW91czohMSxpbnB1dHM6W3tpbmRleGVkOiEwLG5hbWU6ImZyb20iLHR5cGU6ImFkZHJlc3MifSx7aW5kZXhlZDohMSxuYW1lOiJ2YWx1ZSIsdHlwZToidWludDI1NiJ9XSxuYW1lOiJBbm9ueW1vdXNEZXBvc2l0Iix0eXBlOiJldmVudCJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJmcm9tIix0eXBlOiJhZGRyZXNzIn0se2luZGV4ZWQ6ITAsbmFtZToidG8iLHR5cGU6ImJ5dGVzMzIifSx7aW5kZXhlZDohMSxuYW1lOiJ2YWx1ZSIsdHlwZToidWludDI1NiJ9XSxuYW1lOiJEZXBvc2l0Iix0eXBlOiJldmVudCJ9LHthbm9ueW1vdXM6ITEsaW5wdXRzOlt7aW5kZXhlZDohMCxuYW1lOiJmcm9tIix0eXBlOiJieXRlczMyIn0se2luZGV4ZWQ6ITAsbmFtZToidG8iLHR5cGU6ImFkZHJlc3MifSx7aW5kZXhlZDohMSxuYW1lOiJ2YWx1ZSIsdHlwZToidWludDI1NiJ9XSxuYW1lOiJUcmFuc2ZlciIsdHlwZToiZXZlbnQifSx7YW5vbnltb3VzOiExLGlucHV0czpbe2luZGV4ZWQ6ITAsbmFtZToiZnJvbSIsdHlwZToiYnl0ZXMzMiJ9LHtpbmRleGVkOiEwLG5hbWU6InRvIix0eXBlOiJhZGRyZXNzIn0se2luZGV4ZWQ6ITEsbmFtZToiaW5kaXJlY3RJZCIsdHlwZToiYnl0ZXMzMiJ9LHtpbmRleGVkOiExLG5hbWU6InZhbHVlIix0eXBlOiJ1aW50MjU2In1dLG5hbWU6IkljYXBUcmFuc2ZlciIsdHlwZToiZXZlbnQifV19LHt9XSw0OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9ci5mb3JtYXRJbnB1dEludCx0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9ci5mb3JtYXRPdXRwdXRBZGRyZXNzfTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL2FkZHJlc3MoXFsoWzAtOV0qKVxdKT8vKX0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3R5cGUiOjE0fV0sNTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXIuZm9ybWF0SW5wdXRCb29sLHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dEJvb2x9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvXmJvb2woXFsoWzAtOV0qKVxdKSokLyl9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDY6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vdHlwZSIpLGk9ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEZvcm1hdHRlcj1yLmZvcm1hdElucHV0Qnl0ZXMsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPXIuZm9ybWF0T3V0cHV0Qnl0ZXN9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvXmJ5dGVzKFswLTldezEsfSkoXFsoWzAtOV0qKVxdKSokLyl9LGUuZXhwb3J0cz1pfSx7Ii4vZm9ybWF0dGVycyI6OSwiLi90eXBlIjoxNH1dLDc6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vYWRkcmVzcyIpLGk9dCgiLi9ib29sIiksYT10KCIuL2ludCIpLHM9dCgiLi91aW50IiksYz10KCIuL2R5bmFtaWNieXRlcyIpLHU9dCgiLi9zdHJpbmciKSxmPXQoIi4vcmVhbCIpLGw9dCgiLi91cmVhbCIpLHA9dCgiLi9ieXRlcyIpLGg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5pc0R5bmFtaWNUeXBlKGUpfHx0LmlzRHluYW1pY0FycmF5KGUpfSxkPWZ1bmN0aW9uKHQpe3RoaXMuX3R5cGVzPXR9O2QucHJvdG90eXBlLl9yZXF1aXJlVHlwZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl90eXBlcy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIGUuaXNUeXBlKHQpfSlbMF07aWYoIWUpdGhyb3cgRXJyb3IoImludmFsaWQgc29saWRpdHkgdHlwZSE6ICIrdCk7cmV0dXJuIGV9LGQucHJvdG90eXBlLmVuY29kZVBhcmFtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZW5jb2RlUGFyYW1zKFt0XSxbZV0pfSxkLnByb3RvdHlwZS5lbmNvZGVQYXJhbXM9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldFNvbGlkaXR5VHlwZXModCkscj1uLm1hcChmdW5jdGlvbihuLHIpe3JldHVybiBuLmVuY29kZShlW3JdLHRbcl0pfSksbz1uLnJlZHVjZShmdW5jdGlvbihlLHIsbyl7dmFyIGk9ci5zdGF0aWNQYXJ0TGVuZ3RoKHRbb10pLGE9MzIqTWF0aC5mbG9vcigoaSszMSkvMzIpO3JldHVybiBlKyhoKG5bb10sdFtvXSk/MzI6YSl9LDApO3JldHVybiB0aGlzLmVuY29kZU11bHRpV2l0aE9mZnNldCh0LG4scixvKX0sZC5wcm90b3R5cGUuZW5jb2RlTXVsdGlXaXRoT2Zmc2V0PWZ1bmN0aW9uKHQsZSxuLG8pe3ZhciBpPSIiLGE9dGhpcztyZXR1cm4gdC5mb3JFYWNoKGZ1bmN0aW9uKHMsYyl7aWYoaChlW2NdLHRbY10pKXtpKz1yLmZvcm1hdElucHV0SW50KG8pLmVuY29kZSgpO3ZhciB1PWEuZW5jb2RlV2l0aE9mZnNldCh0W2NdLGVbY10sbltjXSxvKTtvKz11Lmxlbmd0aC8yfWVsc2UgaSs9YS5lbmNvZGVXaXRoT2Zmc2V0KHRbY10sZVtjXSxuW2NdLG8pfSksdC5mb3JFYWNoKGZ1bmN0aW9uKHIscyl7aWYoaChlW3NdLHRbc10pKXt2YXIgYz1hLmVuY29kZVdpdGhPZmZzZXQodFtzXSxlW3NdLG5bc10sbyk7bys9Yy5sZW5ndGgvMixpKz1jfX0pLGl9LGQucHJvdG90eXBlLmVuY29kZVdpdGhPZmZzZXQ9ZnVuY3Rpb24odCxlLG4sbyl7dmFyIGk9MSxhPTIscz0zLGM9ZS5pc0R5bmFtaWNBcnJheSh0KT9pOmUuaXNTdGF0aWNBcnJheSh0KT9hOnM7aWYoYyE9PXMpe3ZhciB1PWUubmVzdGVkTmFtZSh0KSxmPWUuc3RhdGljUGFydExlbmd0aCh1KSxsPWM9PT1pP25bMF06IiI7aWYoZS5pc0R5bmFtaWNBcnJheSh1KSlmb3IodmFyIHA9Yz09PWk/MjowLGg9MDtoPG4ubGVuZ3RoO2grKyljPT09aT9wKz0rbltoLTFdWzBdfHwwOmM9PT1hJiYocCs9KyhuW2gtMV18fFtdKVswXXx8MCksbCs9ci5mb3JtYXRJbnB1dEludChvK2gqZiszMipwKS5lbmNvZGUoKTtmb3IodmFyIGQ9Yz09PWk/bi5sZW5ndGgtMTpuLmxlbmd0aCxtPTA7bTxkO20rKyl7dmFyIHk9bC8yO2M9PT1pP2wrPXRoaXMuZW5jb2RlV2l0aE9mZnNldCh1LGUsblttKzFdLG8reSk6Yz09PWEmJihsKz10aGlzLmVuY29kZVdpdGhPZmZzZXQodSxlLG5bbV0sbyt5KSl9cmV0dXJuIGx9cmV0dXJuIG59LGQucHJvdG90eXBlLmRlY29kZVBhcmFtPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZGVjb2RlUGFyYW1zKFt0XSxlKVswXX0sZC5wcm90b3R5cGUuZGVjb2RlUGFyYW1zPWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRTb2xpZGl0eVR5cGVzKHQpLHI9dGhpcy5nZXRPZmZzZXRzKHQsbik7cmV0dXJuIG4ubWFwKGZ1bmN0aW9uKG4sbyl7cmV0dXJuIG4uZGVjb2RlKGUscltvXSx0W29dLG8pfSl9LGQucHJvdG90eXBlLmdldE9mZnNldHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5tYXAoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZS5zdGF0aWNQYXJ0TGVuZ3RoKHRbbl0pfSkscj0xO3I8bi5sZW5ndGg7cisrKW5bcl0rPW5bci0xXTtyZXR1cm4gbi5tYXAoZnVuY3Rpb24obixyKXtyZXR1cm4gbi1lW3JdLnN0YXRpY1BhcnRMZW5ndGgodFtyXSl9KX0sZC5wcm90b3R5cGUuZ2V0U29saWRpdHlUeXBlcz1mdW5jdGlvbih0KXt2YXIgZT10aGlzO3JldHVybiB0Lm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5fcmVxdWlyZVR5cGUodCl9KX07dmFyIG09bmV3IGQoW25ldyBvLG5ldyBpLG5ldyBhLG5ldyBzLG5ldyBjLG5ldyBwLG5ldyB1LG5ldyBmLG5ldyBsXSk7ZS5leHBvcnRzPW19LHsiLi9hZGRyZXNzIjo0LCIuL2Jvb2wiOjUsIi4vYnl0ZXMiOjYsIi4vZHluYW1pY2J5dGVzIjo4LCIuL2Zvcm1hdHRlcnMiOjksIi4vaW50IjoxMCwiLi9yZWFsIjoxMiwiLi9zdHJpbmciOjEzLCIuL3VpbnQiOjE1LCIuL3VyZWFsIjoxNn1dLDg6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vdHlwZSIpLGk9ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEZvcm1hdHRlcj1yLmZvcm1hdElucHV0RHluYW1pY0J5dGVzLHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dER5bmFtaWNCeXRlc307KGkucHJvdG90eXBlPW5ldyBvKHt9KSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuISF0Lm1hdGNoKC9eYnl0ZXMoXFsoWzAtOV0qKVxdKSokLyl9LGkucHJvdG90eXBlLmlzRHluYW1pY1R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3R5cGUiOjE0fV0sOTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoImJpZ251bWJlci5qcyIpLG89dCgiLi4vdXRpbHMvdXRpbHMiKSxpPXQoIi4uL3V0aWxzL2NvbmZpZyIpLGE9dCgiLi9wYXJhbSIpLHM9ZnVuY3Rpb24odCl7ci5jb25maWcoaS5FVEhfQklHTlVNQkVSX1JPVU5ESU5HX01PREUpO3ZhciBlPW8ucGFkTGVmdChvLnRvVHdvc0NvbXBsZW1lbnQodCkudG9TdHJpbmcoMTYpLDY0KTtyZXR1cm4gbmV3IGEoZSl9LGM9ZnVuY3Rpb24odCl7dmFyIGU9dC5zdGF0aWNQYXJ0KCl8fCIwIjtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIjEiPT09bmV3IHIodC5zdWJzdHIoMCwxKSwxNikudG9TdHJpbmcoMikuc3Vic3RyKDAsMSl9KGUpP25ldyByKGUsMTYpLm1pbnVzKG5ldyByKCJmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmIiwxNikpLm1pbnVzKDEpOm5ldyByKGUsMTYpfSx1PWZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGljUGFydCgpfHwiMCI7cmV0dXJuIG5ldyByKGUsMTYpfTtlLmV4cG9ydHM9e2Zvcm1hdElucHV0SW50OnMsZm9ybWF0SW5wdXRCeXRlczpmdW5jdGlvbih0KXt2YXIgZT1vLnRvSGV4KHQpLnN1YnN0cigyKSxuPU1hdGguZmxvb3IoKGUubGVuZ3RoKzYzKS82NCk7cmV0dXJuIGU9by5wYWRSaWdodChlLDY0Km4pLG5ldyBhKGUpfSxmb3JtYXRJbnB1dER5bmFtaWNCeXRlczpmdW5jdGlvbih0KXt2YXIgZT1vLnRvSGV4KHQpLnN1YnN0cigyKSxuPWUubGVuZ3RoLzIscj1NYXRoLmZsb29yKChlLmxlbmd0aCs2MykvNjQpO3JldHVybiBlPW8ucGFkUmlnaHQoZSw2NCpyKSxuZXcgYShzKG4pLnZhbHVlK2UpfSxmb3JtYXRJbnB1dFN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT1vLmZyb21VdGY4KHQpLnN1YnN0cigyKSxuPWUubGVuZ3RoLzIscj1NYXRoLmZsb29yKChlLmxlbmd0aCs2MykvNjQpO3JldHVybiBlPW8ucGFkUmlnaHQoZSw2NCpyKSxuZXcgYShzKG4pLnZhbHVlK2UpfSxmb3JtYXRJbnB1dEJvb2w6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBhKCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiKyh0PyIxIjoiMCIpKX0sZm9ybWF0SW5wdXRSZWFsOmZ1bmN0aW9uKHQpe3JldHVybiBzKG5ldyByKHQpLnRpbWVzKG5ldyByKDIpLnBvdygxMjgpKSl9LGZvcm1hdE91dHB1dEludDpjLGZvcm1hdE91dHB1dFVJbnQ6dSxmb3JtYXRPdXRwdXRSZWFsOmZ1bmN0aW9uKHQpe3JldHVybiBjKHQpLmRpdmlkZWRCeShuZXcgcigyKS5wb3coMTI4KSl9LGZvcm1hdE91dHB1dFVSZWFsOmZ1bmN0aW9uKHQpe3JldHVybiB1KHQpLmRpdmlkZWRCeShuZXcgcigyKS5wb3coMTI4KSl9LGZvcm1hdE91dHB1dEJvb2w6ZnVuY3Rpb24odCl7cmV0dXJuIjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEiPT09dC5zdGF0aWNQYXJ0KCl9LGZvcm1hdE91dHB1dEJ5dGVzOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5tYXRjaCgvXmJ5dGVzKFswLTldKikvKSxyPXBhcnNlSW50KG5bMV0pO3JldHVybiIweCIrdC5zdGF0aWNQYXJ0KCkuc2xpY2UoMCwyKnIpfSxmb3JtYXRPdXRwdXREeW5hbWljQnl0ZXM6ZnVuY3Rpb24odCl7dmFyIGU9MipuZXcgcih0LmR5bmFtaWNQYXJ0KCkuc2xpY2UoMCw2NCksMTYpLnRvTnVtYmVyKCk7cmV0dXJuIjB4Iit0LmR5bmFtaWNQYXJ0KCkuc3Vic3RyKDY0LGUpfSxmb3JtYXRPdXRwdXRTdHJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9MipuZXcgcih0LmR5bmFtaWNQYXJ0KCkuc2xpY2UoMCw2NCksMTYpLnRvTnVtYmVyKCk7cmV0dXJuIG8udG9VdGY4KHQuZHluYW1pY1BhcnQoKS5zdWJzdHIoNjQsZSkpfSxmb3JtYXRPdXRwdXRBZGRyZXNzOmZ1bmN0aW9uKHQpe3ZhciBlPXQuc3RhdGljUGFydCgpO3JldHVybiIweCIrZS5zbGljZShlLmxlbmd0aC00MCxlLmxlbmd0aCl9fX0seyIuLi91dGlscy9jb25maWciOjE4LCIuLi91dGlscy91dGlscyI6MjAsIi4vcGFyYW0iOjExLCJiaWdudW1iZXIuanMiOiJiaWdudW1iZXIuanMifV0sMTA6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vdHlwZSIpLGk9ZnVuY3Rpb24oKXt0aGlzLl9pbnB1dEZvcm1hdHRlcj1yLmZvcm1hdElucHV0SW50LHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dEludH07KGkucHJvdG90eXBlPW5ldyBvKHt9KSkuY29uc3RydWN0b3I9aSxpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7cmV0dXJuISF0Lm1hdGNoKC9eaW50KFswLTldKik/KFxbKFswLTldKilcXSkqJC8pfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSwxMTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3V0aWxzIiksbz1mdW5jdGlvbih0LGUpe3RoaXMudmFsdWU9dHx8IiIsdGhpcy5vZmZzZXQ9ZX07by5wcm90b3R5cGUuZHluYW1pY1BhcnRMZW5ndGg9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5keW5hbWljUGFydCgpLmxlbmd0aC8yfSxvLnByb3RvdHlwZS53aXRoT2Zmc2V0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbyh0aGlzLnZhbHVlLHQpfSxvLnByb3RvdHlwZS5jb21iaW5lPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbyh0aGlzLnZhbHVlK3QudmFsdWUpfSxvLnByb3RvdHlwZS5pc0R5bmFtaWM9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5vZmZzZXR9LG8ucHJvdG90eXBlLm9mZnNldEFzQnl0ZXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0R5bmFtaWMoKT9yLnBhZExlZnQoci50b1R3b3NDb21wbGVtZW50KHRoaXMub2Zmc2V0KS50b1N0cmluZygxNiksNjQpOiIifSxvLnByb3RvdHlwZS5zdGF0aWNQYXJ0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNEeW5hbWljKCk/dGhpcy5vZmZzZXRBc0J5dGVzKCk6dGhpcy52YWx1ZX0sby5wcm90b3R5cGUuZHluYW1pY1BhcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0R5bmFtaWMoKT90aGlzLnZhbHVlOiIifSxvLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGF0aWNQYXJ0KCkrdGhpcy5keW5hbWljUGFydCgpfSxvLmVuY29kZUxpc3Q9ZnVuY3Rpb24odCl7dmFyIGU9MzIqdC5sZW5ndGgsbj10Lm1hcChmdW5jdGlvbih0KXtpZighdC5pc0R5bmFtaWMoKSlyZXR1cm4gdDt2YXIgbj1lO3JldHVybiBlKz10LmR5bmFtaWNQYXJ0TGVuZ3RoKCksdC53aXRoT2Zmc2V0KG4pfSk7cmV0dXJuIG4ucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQrZS5keW5hbWljUGFydCgpfSxuLnJlZHVjZShmdW5jdGlvbih0LGUpe3JldHVybiB0K2Uuc3RhdGljUGFydCgpfSwiIikpfSxlLmV4cG9ydHM9b30seyIuLi91dGlscy91dGlscyI6MjB9XSwxMjpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXIuZm9ybWF0SW5wdXRSZWFsLHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dFJlYWx9OyhpLnByb3RvdHlwZT1uZXcgbyh7fSkpLmNvbnN0cnVjdG9yPWksaS5wcm90b3R5cGUuaXNUeXBlPWZ1bmN0aW9uKHQpe3JldHVybiEhdC5tYXRjaCgvcmVhbChbMC05XSopPyhcWyhbMC05XSopXF0pPy8pfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSwxMzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXIuZm9ybWF0SW5wdXRTdHJpbmcsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPXIuZm9ybWF0T3V0cHV0U3RyaW5nfTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL15zdHJpbmcoXFsoWzAtOV0qKVxdKSokLyl9LGkucHJvdG90eXBlLmlzRHluYW1pY1R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3R5cGUiOjE0fV0sMTQ6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4vcGFyYW0iKSxpPWZ1bmN0aW9uKHQpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXQuaW5wdXRGb3JtYXR0ZXIsdGhpcy5fb3V0cHV0Rm9ybWF0dGVyPXQub3V0cHV0Rm9ybWF0dGVyfTtpLnByb3RvdHlwZS5pc1R5cGU9ZnVuY3Rpb24odCl7dGhyb3cidGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJyd3JpdHRlbiBmb3IgdHlwZSAiK3R9LGkucHJvdG90eXBlLnN0YXRpY1BhcnRMZW5ndGg9ZnVuY3Rpb24odCl7cmV0dXJuKHRoaXMubmVzdGVkVHlwZXModCl8fFsiWzFdIl0pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gcGFyc2VJbnQodC5zbGljZSgxLC0xKSwxMCl8fDF9KS5yZWR1Y2UoZnVuY3Rpb24odCxlKXtyZXR1cm4gdCplfSwzMil9LGkucHJvdG90eXBlLmlzRHluYW1pY0FycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubmVzdGVkVHlwZXModCk7cmV0dXJuISFlJiYhZVtlLmxlbmd0aC0xXS5tYXRjaCgvWzAtOV17MSx9L2cpfSxpLnByb3RvdHlwZS5pc1N0YXRpY0FycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubmVzdGVkVHlwZXModCk7cmV0dXJuISFlJiYhIWVbZS5sZW5ndGgtMV0ubWF0Y2goL1swLTldezEsfS9nKX0saS5wcm90b3R5cGUuc3RhdGljQXJyYXlMZW5ndGg9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5uZXN0ZWRUeXBlcyh0KTtyZXR1cm4gZT9wYXJzZUludChlW2UubGVuZ3RoLTFdLm1hdGNoKC9bMC05XXsxLH0vZyl8fDEpOjF9LGkucHJvdG90eXBlLm5lc3RlZE5hbWU9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5uZXN0ZWRUeXBlcyh0KTtyZXR1cm4gZT90LnN1YnN0cigwLHQubGVuZ3RoLWVbZS5sZW5ndGgtMV0ubGVuZ3RoKTp0fSxpLnByb3RvdHlwZS5pc0R5bmFtaWNUeXBlPWZ1bmN0aW9uKCl7cmV0dXJuITF9LGkucHJvdG90eXBlLm5lc3RlZFR5cGVzPWZ1bmN0aW9uKHQpe3JldHVybiB0Lm1hdGNoKC8oXFtbMC05XSpcXSkvZyl9LGkucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7cmV0dXJuIHRoaXMuaXNEeW5hbWljQXJyYXkoZSk/ZnVuY3Rpb24oKXt2YXIgbz10Lmxlbmd0aCxpPW4ubmVzdGVkTmFtZShlKSxhPVtdO3JldHVybiBhLnB1c2goci5mb3JtYXRJbnB1dEludChvKS5lbmNvZGUoKSksdC5mb3JFYWNoKGZ1bmN0aW9uKHQpe2EucHVzaChuLmVuY29kZSh0LGkpKX0pLGF9KCk6dGhpcy5pc1N0YXRpY0FycmF5KGUpP2Z1bmN0aW9uKCl7Zm9yKHZhciByPW4uc3RhdGljQXJyYXlMZW5ndGgoZSksbz1uLm5lc3RlZE5hbWUoZSksaT1bXSxhPTA7YTxyO2ErKylpLnB1c2gobi5lbmNvZGUodFthXSxvKSk7cmV0dXJuIGl9KCk6dGhpcy5faW5wdXRGb3JtYXR0ZXIodCxlKS5lbmNvZGUoKX0saS5wcm90b3R5cGUuZGVjb2RlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgcj10aGlzO2lmKHRoaXMuaXNEeW5hbWljQXJyYXkobikpcmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBvPXBhcnNlSW50KCIweCIrdC5zdWJzdHIoMiplLDY0KSksaT1wYXJzZUludCgiMHgiK3Quc3Vic3RyKDIqbyw2NCkpLGE9byszMixzPXIubmVzdGVkTmFtZShuKSxjPXIuc3RhdGljUGFydExlbmd0aChzKSx1PTMyKk1hdGguZmxvb3IoKGMrMzEpLzMyKSxmPVtdLGw9MDtsPGkqdTtsKz11KWYucHVzaChyLmRlY29kZSh0LGErbCxzKSk7cmV0dXJuIGZ9KCk7aWYodGhpcy5pc1N0YXRpY0FycmF5KG4pKXJldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgbz1yLnN0YXRpY0FycmF5TGVuZ3RoKG4pLGk9ZSxhPXIubmVzdGVkTmFtZShuKSxzPXIuc3RhdGljUGFydExlbmd0aChhKSxjPTMyKk1hdGguZmxvb3IoKHMrMzEpLzMyKSx1PVtdLGY9MDtmPG8qYztmKz1jKXUucHVzaChyLmRlY29kZSh0LGkrZixhKSk7cmV0dXJuIHV9KCk7aWYodGhpcy5pc0R5bmFtaWNUeXBlKG4pKXJldHVybiBmdW5jdGlvbigpe3ZhciBpPXBhcnNlSW50KCIweCIrdC5zdWJzdHIoMiplLDY0KSksYT1wYXJzZUludCgiMHgiK3Quc3Vic3RyKDIqaSw2NCkpLHM9TWF0aC5mbG9vcigoYSszMSkvMzIpLGM9bmV3IG8odC5zdWJzdHIoMippLDY0KigxK3MpKSwwKTtyZXR1cm4gci5fb3V0cHV0Rm9ybWF0dGVyKGMsbil9KCk7dmFyIGk9dGhpcy5zdGF0aWNQYXJ0TGVuZ3RoKG4pLGE9bmV3IG8odC5zdWJzdHIoMiplLDIqaSkpO3JldHVybiB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIoYSxuKX0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3BhcmFtIjoxMX1dLDE1OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuL3R5cGUiKSxpPWZ1bmN0aW9uKCl7dGhpcy5faW5wdXRGb3JtYXR0ZXI9ci5mb3JtYXRJbnB1dEludCx0aGlzLl9vdXRwdXRGb3JtYXR0ZXI9ci5mb3JtYXRPdXRwdXRVSW50fTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL151aW50KFswLTldKik/KFxbKFswLTldKilcXSkqJC8pfSxlLmV4cG9ydHM9aX0seyIuL2Zvcm1hdHRlcnMiOjksIi4vdHlwZSI6MTR9XSwxNjpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi90eXBlIiksaT1mdW5jdGlvbigpe3RoaXMuX2lucHV0Rm9ybWF0dGVyPXIuZm9ybWF0SW5wdXRSZWFsLHRoaXMuX291dHB1dEZvcm1hdHRlcj1yLmZvcm1hdE91dHB1dFVSZWFsfTsoaS5wcm90b3R5cGU9bmV3IG8oe30pKS5jb25zdHJ1Y3Rvcj1pLGkucHJvdG90eXBlLmlzVHlwZT1mdW5jdGlvbih0KXtyZXR1cm4hIXQubWF0Y2goL151cmVhbChbMC05XSopPyhcWyhbMC05XSopXF0pKiQvKX0sZS5leHBvcnRzPWl9LHsiLi9mb3JtYXR0ZXJzIjo5LCIuL3R5cGUiOjE0fV0sMTc6W2Z1bmN0aW9uKHQsZSxuKXsidXNlIHN0cmljdCI7InVuZGVmaW5lZCI9PXR5cGVvZiBYTUxIdHRwUmVxdWVzdD9uLlhNTEh0dHBSZXF1ZXN0PXt9Om4uWE1MSHR0cFJlcXVlc3Q9WE1MSHR0cFJlcXVlc3R9LHt9XSwxODpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoImJpZ251bWJlci5qcyIpO2UuZXhwb3J0cz17RVRIX1BBRERJTkc6MzIsRVRIX1NJR05BVFVSRV9MRU5HVEg6NCxFVEhfVU5JVFM6WyJ3ZWkiLCJrd2VpIiwiTXdlaSIsIkd3ZWkiLCJzemFibyIsImZpbm5leSIsImZlbXRvZXRoZXIiLCJwaWNvZXRoZXIiLCJuYW5vZXRoZXIiLCJtaWNyb2V0aGVyIiwibWlsbGlldGhlciIsIm5hbm8iLCJtaWNybyIsIm1pbGxpIiwiZXRoZXIiLCJncmFuZCIsIk1ldGhlciIsIkdldGhlciIsIlRldGhlciIsIlBldGhlciIsIkVldGhlciIsIlpldGhlciIsIllldGhlciIsIk5ldGhlciIsIkRldGhlciIsIlZldGhlciIsIlVldGhlciJdLEVUSF9CSUdOVU1CRVJfUk9VTkRJTkdfTU9ERTp7Uk9VTkRJTkdfTU9ERTpyLlJPVU5EX0RPV059LEVUSF9QT0xMSU5HX1RJTUVPVVQ6NTAwLGRlZmF1bHRCbG9jazoibGF0ZXN0IixkZWZhdWx0QWNjb3VudDp2b2lkIDB9fSx7ImJpZ251bWJlci5qcyI6ImJpZ251bWJlci5qcyJ9XSwxOTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoImNyeXB0by1qcyIpLG89dCgiY3J5cHRvLWpzL3NoYTMiKTtlLmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZSYmImhleCI9PT1lLmVuY29kaW5nJiYodC5sZW5ndGg+MiYmIjB4Ij09PXQuc3Vic3RyKDAsMikmJih0PXQuc3Vic3RyKDIpKSx0PXIuZW5jLkhleC5wYXJzZSh0KSksbyh0LHtvdXRwdXRMZW5ndGg6MjU2fSkudG9TdHJpbmcoKX19LHsiY3J5cHRvLWpzIjo1OSwiY3J5cHRvLWpzL3NoYTMiOjgwfV0sMjA6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCJiaWdudW1iZXIuanMiKSxvPXQoIi4vc2hhMy5qcyIpLGk9dCgidXRmOCIpLGE9e25vZXRoZXI6IjAiLHdlaToiMSIsa3dlaToiMTAwMCIsS3dlaToiMTAwMCIsYmFiYmFnZToiMTAwMCIsZmVtdG9ldGhlcjoiMTAwMCIsbXdlaToiMTAwMDAwMCIsTXdlaToiMTAwMDAwMCIsbG92ZWxhY2U6IjEwMDAwMDAiLHBpY29ldGhlcjoiMTAwMDAwMCIsZ3dlaToiMTAwMDAwMDAwMCIsR3dlaToiMTAwMDAwMDAwMCIsc2hhbm5vbjoiMTAwMDAwMDAwMCIsbmFub2V0aGVyOiIxMDAwMDAwMDAwIixuYW5vOiIxMDAwMDAwMDAwIixzemFibzoiMTAwMDAwMDAwMDAwMCIsbWljcm9ldGhlcjoiMTAwMDAwMDAwMDAwMCIsbWljcm86IjEwMDAwMDAwMDAwMDAiLGZpbm5leToiMTAwMDAwMDAwMDAwMDAwMCIsbWlsbGlldGhlcjoiMTAwMDAwMDAwMDAwMDAwMCIsbWlsbGk6IjEwMDAwMDAwMDAwMDAwMDAiLGV0aGVyOiIxMDAwMDAwMDAwMDAwMDAwMDAwIixrZXRoZXI6IjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAiLGdyYW5kOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwIixtZXRoZXI6IjEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAiLGdldGhlcjoiMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCIsdGV0aGVyOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIn0scz1mdW5jdGlvbih0LGUsbil7cmV0dXJuIG5ldyBBcnJheShlLXQubGVuZ3RoKzEpLmpvaW4obnx8IjAiKSt0fSxjPWZ1bmN0aW9uKHQpe3Q9aS5lbmNvZGUodCk7Zm9yKHZhciBlPSIiLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dC5jaGFyQ29kZUF0KG4pO2lmKDA9PT1yKWJyZWFrO3ZhciBvPXIudG9TdHJpbmcoMTYpO2UrPW8ubGVuZ3RoPDI/IjAiK286b31yZXR1cm4iMHgiK2V9LHU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSIiLG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dC5jaGFyQ29kZUF0KG4pLnRvU3RyaW5nKDE2KTtlKz1yLmxlbmd0aDwyPyIwIityOnJ9cmV0dXJuIjB4IitlfSxmPWZ1bmN0aW9uKHQpe3ZhciBlPWgodCksbj1lLnRvU3RyaW5nKDE2KTtyZXR1cm4gZS5sZXNzVGhhbigwKT8iLTB4IituLnN1YnN0cigxKToiMHgiK259LGw9ZnVuY3Rpb24odCl7aWYodih0KSlyZXR1cm4gZigrdCk7aWYoeSh0KSlyZXR1cm4gZih0KTtpZigib2JqZWN0Ij09dHlwZW9mIHQpcmV0dXJuIGMoSlNPTi5zdHJpbmdpZnkodCkpO2lmKGcodCkpe2lmKDA9PT10LmluZGV4T2YoIi0weCIpKXJldHVybiBmKHQpO2lmKDA9PT10LmluZGV4T2YoIjB4IikpcmV0dXJuIHQ7aWYoIWlzRmluaXRlKHQpKXJldHVybiB1KHQpfXJldHVybiBmKHQpfSxwPWZ1bmN0aW9uKHQpe3Q9dD90LnRvTG93ZXJDYXNlKCk6ImV0aGVyIjt2YXIgZT1hW3RdO2lmKHZvaWQgMD09PWUpdGhyb3cgbmV3IEVycm9yKCJUaGlzIHVuaXQgZG9lc24ndCBleGlzdHMsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzIitKU09OLnN0cmluZ2lmeShhLG51bGwsMikpO3JldHVybiBuZXcgcihlLDEwKX0saD1mdW5jdGlvbih0KXtyZXR1cm4gdD10fHwwLHkodCk/dDohZyh0KXx8MCE9PXQuaW5kZXhPZigiMHgiKSYmMCE9PXQuaW5kZXhPZigiLTB4Iik/bmV3IHIodC50b1N0cmluZygxMCksMTApOm5ldyByKHQucmVwbGFjZSgiMHgiLCIiKSwxNil9LGQ9ZnVuY3Rpb24odCl7cmV0dXJuL14weFswLTlhLWZdezQwfSQvaS50ZXN0KHQpfSxtPWZ1bmN0aW9uKHQpe3Q9dC5yZXBsYWNlKCIweCIsIiIpO2Zvcih2YXIgZT1vKHQudG9Mb3dlckNhc2UoKSksbj0wO248NDA7bisrKWlmKHBhcnNlSW50KGVbbl0sMTYpPjcmJnRbbl0udG9VcHBlckNhc2UoKSE9PXRbbl18fHBhcnNlSW50KGVbbl0sMTYpPD03JiZ0W25dLnRvTG93ZXJDYXNlKCkhPT10W25dKXJldHVybiExO3JldHVybiEwfSx5PWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygcnx8dCYmdC5jb25zdHJ1Y3RvciYmIkJpZ051bWJlciI9PT10LmNvbnN0cnVjdG9yLm5hbWV9LGc9ZnVuY3Rpb24odCl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0fHx0JiZ0LmNvbnN0cnVjdG9yJiYiU3RyaW5nIj09PXQuY29uc3RydWN0b3IubmFtZX0sdj1mdW5jdGlvbih0KXtyZXR1cm4iYm9vbGVhbiI9PXR5cGVvZiB0fTtlLmV4cG9ydHM9e3BhZExlZnQ6cyxwYWRSaWdodDpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHQrbmV3IEFycmF5KGUtdC5sZW5ndGgrMSkuam9pbihufHwiMCIpfSx0b0hleDpsLHRvRGVjaW1hbDpmdW5jdGlvbih0KXtyZXR1cm4gaCh0KS50b051bWJlcigpfSxmcm9tRGVjaW1hbDpmLHRvVXRmODpmdW5jdGlvbih0KXt2YXIgZT0iIixuPTAscj10Lmxlbmd0aDtmb3IoIjB4Ij09PXQuc3Vic3RyaW5nKDAsMikmJihuPTIpO248cjtuKz0yKXt2YXIgbz1wYXJzZUludCh0LnN1YnN0cihuLDIpLDE2KTtpZigwPT09bylicmVhaztlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pfXJldHVybiBpLmRlY29kZShlKX0sdG9Bc2NpaTpmdW5jdGlvbih0KXt2YXIgZT0iIixuPTAscj10Lmxlbmd0aDtmb3IoIjB4Ij09PXQuc3Vic3RyaW5nKDAsMikmJihuPTIpO248cjtuKz0yKXt2YXIgbz1wYXJzZUludCh0LnN1YnN0cihuLDIpLDE2KTtlKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pfXJldHVybiBlfSxmcm9tVXRmODpjLGZyb21Bc2NpaTp1LHRyYW5zZm9ybVRvRnVsbE5hbWU6ZnVuY3Rpb24odCl7aWYoLTEhPT10Lm5hbWUuaW5kZXhPZigiKCIpKXJldHVybiB0Lm5hbWU7dmFyIGU9dC5pbnB1dHMubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LnR5cGV9KS5qb2luKCk7cmV0dXJuIHQubmFtZSsiKCIrZSsiKSJ9LGV4dHJhY3REaXNwbGF5TmFtZTpmdW5jdGlvbih0KXt2YXIgZT10LmluZGV4T2YoIigiKTtyZXR1cm4tMSE9PWU/dC5zdWJzdHIoMCxlKTp0fSxleHRyYWN0VHlwZU5hbWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5pbmRleE9mKCIoIik7cmV0dXJuLTEhPT1lP3Quc3Vic3RyKGUrMSx0Lmxlbmd0aC0xLShlKzEpKS5yZXBsYWNlKCIgIiwiIik6IiJ9LHRvV2VpOmZ1bmN0aW9uKHQsZSl7dmFyIG49aCh0KS50aW1lcyhwKGUpKTtyZXR1cm4geSh0KT9uOm4udG9TdHJpbmcoMTApfSxmcm9tV2VpOmZ1bmN0aW9uKHQsZSl7dmFyIG49aCh0KS5kaXZpZGVkQnkocChlKSk7cmV0dXJuIHkodCk/bjpuLnRvU3RyaW5nKDEwKX0sdG9CaWdOdW1iZXI6aCx0b1R3b3NDb21wbGVtZW50OmZ1bmN0aW9uKHQpe3ZhciBlPWgodCkucm91bmQoKTtyZXR1cm4gZS5sZXNzVGhhbigwKT9uZXcgcigiZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZiIsMTYpLnBsdXMoZSkucGx1cygxKTplfSx0b0FkZHJlc3M6ZnVuY3Rpb24odCl7cmV0dXJuIGQodCk/dDovXlswLTlhLWZdezQwfSQvLnRlc3QodCk/IjB4Iit0OiIweCIrcyhsKHQpLnN1YnN0cigyKSw0MCl9LGlzQmlnTnVtYmVyOnksaXNTdHJpY3RBZGRyZXNzOmQsaXNBZGRyZXNzOmZ1bmN0aW9uKHQpe3JldHVybiEhL14oMHgpP1swLTlhLWZdezQwfSQvaS50ZXN0KHQpJiYoISghL14oMHgpP1swLTlhLWZdezQwfSQvLnRlc3QodCkmJiEvXigweCk/WzAtOUEtRl17NDB9JC8udGVzdCh0KSl8fG0odCkpfSxpc0NoZWNrc3VtQWRkcmVzczptLHRvQ2hlY2tzdW1BZGRyZXNzOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIiI7dD10LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgiMHgiLCIiKTtmb3IodmFyIGU9byh0KSxuPSIweCIscj0wO3I8dC5sZW5ndGg7cisrKXBhcnNlSW50KGVbcl0sMTYpPjc/bis9dFtyXS50b1VwcGVyQ2FzZSgpOm4rPXRbcl07cmV0dXJuIG59LGlzRnVuY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuImZ1bmN0aW9uIj09dHlwZW9mIHR9LGlzU3RyaW5nOmcsaXNPYmplY3Q6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10JiYhQXJyYXkuaXNBcnJheSh0KSYmIm9iamVjdCI9PXR5cGVvZiB0fSxpc0Jvb2xlYW46dixpc0FycmF5OmZ1bmN0aW9uKHQpe3JldHVybiBBcnJheS5pc0FycmF5KHQpfSxpc0pzb246ZnVuY3Rpb24odCl7dHJ5e3JldHVybiEhSlNPTi5wYXJzZSh0KX1jYXRjaCh0KXtyZXR1cm4hMX19LGlzQmxvb206ZnVuY3Rpb24odCl7cmV0dXJuISghL14oMHgpP1swLTlhLWZdezUxMn0kL2kudGVzdCh0KXx8IS9eKDB4KT9bMC05YS1mXXs1MTJ9JC8udGVzdCh0KSYmIS9eKDB4KT9bMC05QS1GXXs1MTJ9JC8udGVzdCh0KSl9LGlzVG9waWM6ZnVuY3Rpb24odCl7cmV0dXJuISghL14oMHgpP1swLTlhLWZdezY0fSQvaS50ZXN0KHQpfHwhL14oMHgpP1swLTlhLWZdezY0fSQvLnRlc3QodCkmJiEvXigweCk/WzAtOUEtRl17NjR9JC8udGVzdCh0KSl9fX0seyIuL3NoYTMuanMiOjE5LCJiaWdudW1iZXIuanMiOiJiaWdudW1iZXIuanMiLHV0Zjg6ODV9XSwyMTpbZnVuY3Rpb24odCxlLG4pe2UuZXhwb3J0cz17dmVyc2lvbjoiMC4yMC4zIn19LHt9XSwyMjpbZnVuY3Rpb24odCxlLG4pe2Z1bmN0aW9uIHIodCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9bmV3IG8odCksdGhpcy5jdXJyZW50UHJvdmlkZXI9dCx0aGlzLmV0aD1uZXcgYSh0aGlzKSx0aGlzLmRiPW5ldyBzKHRoaXMpLHRoaXMuc2hoPW5ldyBjKHRoaXMpLHRoaXMubmV0PW5ldyB1KHRoaXMpLHRoaXMucGVyc29uYWw9bmV3IGYodGhpcyksdGhpcy5ieno9bmV3IGwodGhpcyksdGhpcy5zZXR0aW5ncz1uZXcgcCx0aGlzLnZlcnNpb249e2FwaTpoLnZlcnNpb259LHRoaXMucHJvdmlkZXJzPXtIdHRwUHJvdmlkZXI6YixJcGNQcm92aWRlcjpffSx0aGlzLl9leHRlbmQ9eSh0aGlzKSx0aGlzLl9leHRlbmQoe3Byb3BlcnRpZXM6eCgpfSl9dmFyIG89dCgiLi93ZWIzL3JlcXVlc3RtYW5hZ2VyIiksaT10KCIuL3dlYjMvaWJhbiIpLGE9dCgiLi93ZWIzL21ldGhvZHMvZXRoIikscz10KCIuL3dlYjMvbWV0aG9kcy9kYiIpLGM9dCgiLi93ZWIzL21ldGhvZHMvc2hoIiksdT10KCIuL3dlYjMvbWV0aG9kcy9uZXQiKSxmPXQoIi4vd2ViMy9tZXRob2RzL3BlcnNvbmFsIiksbD10KCIuL3dlYjMvbWV0aG9kcy9zd2FybSIpLHA9dCgiLi93ZWIzL3NldHRpbmdzIiksaD10KCIuL3ZlcnNpb24uanNvbiIpLGQ9dCgiLi91dGlscy91dGlscyIpLG09dCgiLi91dGlscy9zaGEzIikseT10KCIuL3dlYjMvZXh0ZW5kIiksZz10KCIuL3dlYjMvYmF0Y2giKSx2PXQoIi4vd2ViMy9wcm9wZXJ0eSIpLGI9dCgiLi93ZWIzL2h0dHBwcm92aWRlciIpLF89dCgiLi93ZWIzL2lwY3Byb3ZpZGVyIiksdz10KCJiaWdudW1iZXIuanMiKTtyLnByb3ZpZGVycz17SHR0cFByb3ZpZGVyOmIsSXBjUHJvdmlkZXI6X30sci5wcm90b3R5cGUuc2V0UHJvdmlkZXI9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXIuc2V0UHJvdmlkZXIodCksdGhpcy5jdXJyZW50UHJvdmlkZXI9dH0sci5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXIucmVzZXQodCksdGhpcy5zZXR0aW5ncz1uZXcgcH0sci5wcm90b3R5cGUuQmlnTnVtYmVyPXcsci5wcm90b3R5cGUudG9IZXg9ZC50b0hleCxyLnByb3RvdHlwZS50b0FzY2lpPWQudG9Bc2NpaSxyLnByb3RvdHlwZS50b1V0Zjg9ZC50b1V0Zjgsci5wcm90b3R5cGUuZnJvbUFzY2lpPWQuZnJvbUFzY2lpLHIucHJvdG90eXBlLmZyb21VdGY4PWQuZnJvbVV0Zjgsci5wcm90b3R5cGUudG9EZWNpbWFsPWQudG9EZWNpbWFsLHIucHJvdG90eXBlLmZyb21EZWNpbWFsPWQuZnJvbURlY2ltYWwsci5wcm90b3R5cGUudG9CaWdOdW1iZXI9ZC50b0JpZ051bWJlcixyLnByb3RvdHlwZS50b1dlaT1kLnRvV2VpLHIucHJvdG90eXBlLmZyb21XZWk9ZC5mcm9tV2VpLHIucHJvdG90eXBlLmlzQWRkcmVzcz1kLmlzQWRkcmVzcyxyLnByb3RvdHlwZS5pc0NoZWNrc3VtQWRkcmVzcz1kLmlzQ2hlY2tzdW1BZGRyZXNzLHIucHJvdG90eXBlLnRvQ2hlY2tzdW1BZGRyZXNzPWQudG9DaGVja3N1bUFkZHJlc3Msci5wcm90b3R5cGUuaXNJQkFOPWQuaXNJQkFOLHIucHJvdG90eXBlLnBhZExlZnQ9ZC5wYWRMZWZ0LHIucHJvdG90eXBlLnBhZFJpZ2h0PWQucGFkUmlnaHQsci5wcm90b3R5cGUuc2hhMz1mdW5jdGlvbih0LGUpe3JldHVybiIweCIrbSh0LGUpfSxyLnByb3RvdHlwZS5mcm9tSUNBUD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkodCkuYWRkcmVzcygpfTt2YXIgeD1mdW5jdGlvbigpe3JldHVybltuZXcgdih7bmFtZToidmVyc2lvbi5ub2RlIixnZXR0ZXI6IndlYjNfY2xpZW50VmVyc2lvbiJ9KSxuZXcgdih7bmFtZToidmVyc2lvbi5uZXR3b3JrIixnZXR0ZXI6Im5ldF92ZXJzaW9uIixpbnB1dEZvcm1hdHRlcjpkLnRvRGVjaW1hbH0pLG5ldyB2KHtuYW1lOiJ2ZXJzaW9uLmV0aGVyZXVtIixnZXR0ZXI6ImV0aF9wcm90b2NvbFZlcnNpb24iLGlucHV0Rm9ybWF0dGVyOmQudG9EZWNpbWFsfSksbmV3IHYoe25hbWU6InZlcnNpb24ud2hpc3BlciIsZ2V0dGVyOiJzaGhfdmVyc2lvbiIsaW5wdXRGb3JtYXR0ZXI6ZC50b0RlY2ltYWx9KV19O3IucHJvdG90eXBlLmlzQ29ubmVjdGVkPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3VycmVudFByb3ZpZGVyJiZ0aGlzLmN1cnJlbnRQcm92aWRlci5pc0Nvbm5lY3RlZCgpfSxyLnByb3RvdHlwZS5jcmVhdGVCYXRjaD1mdW5jdGlvbigpe3JldHVybiBuZXcgZyh0aGlzKX0sZS5leHBvcnRzPXJ9LHsiLi91dGlscy9zaGEzIjoxOSwiLi91dGlscy91dGlscyI6MjAsIi4vdmVyc2lvbi5qc29uIjoyMSwiLi93ZWIzL2JhdGNoIjoyNCwiLi93ZWIzL2V4dGVuZCI6MjgsIi4vd2ViMy9odHRwcHJvdmlkZXIiOjMyLCIuL3dlYjMvaWJhbiI6MzMsIi4vd2ViMy9pcGNwcm92aWRlciI6MzQsIi4vd2ViMy9tZXRob2RzL2RiIjozNywiLi93ZWIzL21ldGhvZHMvZXRoIjozOCwiLi93ZWIzL21ldGhvZHMvbmV0IjozOSwiLi93ZWIzL21ldGhvZHMvcGVyc29uYWwiOjQwLCIuL3dlYjMvbWV0aG9kcy9zaGgiOjQxLCIuL3dlYjMvbWV0aG9kcy9zd2FybSI6NDIsIi4vd2ViMy9wcm9wZXJ0eSI6NDUsIi4vd2ViMy9yZXF1ZXN0bWFuYWdlciI6NDYsIi4vd2ViMy9zZXR0aW5ncyI6NDcsImJpZ251bWJlci5qcyI6ImJpZ251bWJlci5qcyJ9XSwyMzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3NoYTMiKSxvPXQoIi4vZXZlbnQiKSxpPXQoIi4vZm9ybWF0dGVycyIpLGE9dCgiLi4vdXRpbHMvdXRpbHMiKSxzPXQoIi4vZmlsdGVyIiksYz10KCIuL21ldGhvZHMvd2F0Y2hlcyIpLHU9ZnVuY3Rpb24odCxlLG4pe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPXQsdGhpcy5fanNvbj1lLHRoaXMuX2FkZHJlc3M9bn07dS5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKHQpe3Q9dHx8e307dmFyIGU9e307cmV0dXJuWyJmcm9tQmxvY2siLCJ0b0Jsb2NrIl0uZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT10W2VdfSkuZm9yRWFjaChmdW5jdGlvbihuKXtlW25dPWkuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcih0W25dKX0pLGUuYWRkcmVzcz10aGlzLl9hZGRyZXNzLGV9LHUucHJvdG90eXBlLmRlY29kZT1mdW5jdGlvbih0KXt0LmRhdGE9dC5kYXRhfHwiIix0LnRvcGljcz10LnRvcGljc3x8W107dmFyIGU9dC50b3BpY3NbMF0uc2xpY2UoMiksbj10aGlzLl9qc29uLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gZT09PXIoYS50cmFuc2Zvcm1Ub0Z1bGxOYW1lKHQpKX0pWzBdO2lmKCFuKXJldHVybiBjb25zb2xlLndhcm4oImNhbm5vdCBmaW5kIGV2ZW50IGZvciBsb2ciKSx0O3JldHVybiBuZXcgbyh0aGlzLl9yZXF1ZXN0TWFuYWdlcixuLHRoaXMuX2FkZHJlc3MpLmRlY29kZSh0KX0sdS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbih0LGUpe2EuaXNGdW5jdGlvbihhcmd1bWVudHNbYXJndW1lbnRzLmxlbmd0aC0xXSkmJihlPWFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdLDE9PT1hcmd1bWVudHMubGVuZ3RoJiYodD1udWxsKSk7dmFyIG49dGhpcy5lbmNvZGUodCkscj10aGlzLmRlY29kZS5iaW5kKHRoaXMpO3JldHVybiBuZXcgcyhuLCJldGgiLHRoaXMuX3JlcXVlc3RNYW5hZ2VyLGMuZXRoKCkscixlKX0sdS5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTt0LmFsbEV2ZW50cz1lfSxlLmV4cG9ydHM9dX0seyIuLi91dGlscy9zaGEzIjoxOSwiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2V2ZW50IjoyNywiLi9maWx0ZXIiOjI5LCIuL2Zvcm1hdHRlcnMiOjMwLCIuL21ldGhvZHMvd2F0Y2hlcyI6NDN9XSwyNDpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vanNvbnJwYyIpLG89dCgiLi9lcnJvcnMiKSxpPWZ1bmN0aW9uKHQpe3RoaXMucmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXIsdGhpcy5yZXF1ZXN0cz1bXX07aS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3RoaXMucmVxdWVzdHMucHVzaCh0KX0saS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbigpe3ZhciB0PXRoaXMucmVxdWVzdHM7dGhpcy5yZXF1ZXN0TWFuYWdlci5zZW5kQmF0Y2godCxmdW5jdGlvbihlLG4pe249bnx8W10sdC5tYXAoZnVuY3Rpb24odCxlKXtyZXR1cm4gbltlXXx8e319KS5mb3JFYWNoKGZ1bmN0aW9uKGUsbil7aWYodFtuXS5jYWxsYmFjayl7aWYoIXIuaXNWYWxpZFJlc3BvbnNlKGUpKXJldHVybiB0W25dLmNhbGxiYWNrKG8uSW52YWxpZFJlc3BvbnNlKGUpKTt0W25dLmNhbGxiYWNrKG51bGwsdFtuXS5mb3JtYXQ/dFtuXS5mb3JtYXQoZS5yZXN1bHQpOmUucmVzdWx0KX19KX0pfSxlLmV4cG9ydHM9aX0seyIuL2Vycm9ycyI6MjYsIi4vanNvbnJwYyI6MzV9XSwyNTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3V0aWxzIiksbz10KCIuLi9zb2xpZGl0eS9jb2RlciIpLGk9dCgiLi9ldmVudCIpLGE9dCgiLi9mdW5jdGlvbiIpLHM9dCgiLi9hbGxldmVudHMiKSxjPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiJjb25zdHJ1Y3RvciI9PT10LnR5cGUmJnQuaW5wdXRzLmxlbmd0aD09PWUubGVuZ3RofSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0LmlucHV0cy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHQudHlwZX0pfSkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBvLmVuY29kZVBhcmFtcyh0LGUpfSlbMF18fCIifSx1PWZ1bmN0aW9uKHQpe3QuYWJpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4iZnVuY3Rpb24iPT09dC50eXBlfSkubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgYSh0Ll9ldGgsZSx0LmFkZHJlc3MpfSkuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvQ29udHJhY3QodCl9KX0sZj1mdW5jdGlvbih0KXt2YXIgZT10LmFiaS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuImV2ZW50Ij09PXQudHlwZX0pO25ldyBzKHQuX2V0aC5fcmVxdWVzdE1hbmFnZXIsZSx0LmFkZHJlc3MpLmF0dGFjaFRvQ29udHJhY3QodCksZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBpKHQuX2V0aC5fcmVxdWVzdE1hbmFnZXIsZSx0LmFkZHJlc3MpfSkuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvQ29udHJhY3QodCl9KX0sbD1mdW5jdGlvbih0LGUpe3ZhciBuPTAscj0hMSxvPXQuX2V0aC5maWx0ZXIoImxhdGVzdCIsZnVuY3Rpb24oaSl7aWYoIWkmJiFyKWlmKCsrbj41MCl7aWYoby5zdG9wV2F0Y2hpbmcoZnVuY3Rpb24oKXt9KSxyPSEwLCFlKXRocm93IG5ldyBFcnJvcigiQ29udHJhY3QgdHJhbnNhY3Rpb24gY291bGRuJ3QgYmUgZm91bmQgYWZ0ZXIgNTAgYmxvY2tzIik7ZShuZXcgRXJyb3IoIkNvbnRyYWN0IHRyYW5zYWN0aW9uIGNvdWxkbid0IGJlIGZvdW5kIGFmdGVyIDUwIGJsb2NrcyIpKX1lbHNlIHQuX2V0aC5nZXRUcmFuc2FjdGlvblJlY2VpcHQodC50cmFuc2FjdGlvbkhhc2gsZnVuY3Rpb24obixpKXtpJiYhciYmdC5fZXRoLmdldENvZGUoaS5jb250cmFjdEFkZHJlc3MsZnVuY3Rpb24obixhKXtpZighciYmYSlpZihvLnN0b3BXYXRjaGluZyhmdW5jdGlvbigpe30pLHI9ITAsYS5sZW5ndGg+Myl0LmFkZHJlc3M9aS5jb250cmFjdEFkZHJlc3MsdSh0KSxmKHQpLGUmJmUobnVsbCx0KTtlbHNle2lmKCFlKXRocm93IG5ldyBFcnJvcigiVGhlIGNvbnRyYWN0IGNvZGUgY291bGRuJ3QgYmUgc3RvcmVkLCBwbGVhc2UgY2hlY2sgeW91ciBnYXMgYW1vdW50LiIpO2UobmV3IEVycm9yKCJUaGUgY29udHJhY3QgY29kZSBjb3VsZG4ndCBiZSBzdG9yZWQsIHBsZWFzZSBjaGVjayB5b3VyIGdhcyBhbW91bnQuIikpfX0pfSl9KX0scD1mdW5jdGlvbih0LGUpe3RoaXMuZXRoPXQsdGhpcy5hYmk9ZSx0aGlzLm5ldz1mdW5jdGlvbigpe3ZhciB0LG49bmV3IGgodGhpcy5ldGgsdGhpcy5hYmkpLG89e30saT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO3IuaXNGdW5jdGlvbihpW2kubGVuZ3RoLTFdKSYmKHQ9aS5wb3AoKSk7dmFyIGE9aVtpLmxlbmd0aC0xXTtpZihyLmlzT2JqZWN0KGEpJiYhci5pc0FycmF5KGEpJiYobz1pLnBvcCgpKSxvLnZhbHVlPjApe2lmKCEoZS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuImNvbnN0cnVjdG9yIj09PXQudHlwZSYmdC5pbnB1dHMubGVuZ3RoPT09aS5sZW5ndGh9KVswXXx8e30pLnBheWFibGUpdGhyb3cgbmV3IEVycm9yKCJDYW5ub3Qgc2VuZCB2YWx1ZSB0byBub24tcGF5YWJsZSBjb25zdHJ1Y3RvciIpfXZhciBzPWModGhpcy5hYmksaSk7aWYoby5kYXRhKz1zLHQpdGhpcy5ldGguc2VuZFRyYW5zYWN0aW9uKG8sZnVuY3Rpb24oZSxyKXtlP3QoZSk6KG4udHJhbnNhY3Rpb25IYXNoPXIsdChudWxsLG4pLGwobix0KSl9KTtlbHNle3ZhciB1PXRoaXMuZXRoLnNlbmRUcmFuc2FjdGlvbihvKTtuLnRyYW5zYWN0aW9uSGFzaD11LGwobil9cmV0dXJuIG59LHRoaXMubmV3LmdldERhdGE9dGhpcy5nZXREYXRhLmJpbmQodGhpcyl9O3AucHJvdG90eXBlLmF0PWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGgodGhpcy5ldGgsdGhpcy5hYmksdCk7cmV0dXJuIHUobiksZihuKSxlJiZlKG51bGwsbiksbn0scC5wcm90b3R5cGUuZ2V0RGF0YT1mdW5jdGlvbigpe3ZhciB0PXt9LGU9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxuPWVbZS5sZW5ndGgtMV07ci5pc09iamVjdChuKSYmIXIuaXNBcnJheShuKSYmKHQ9ZS5wb3AoKSk7dmFyIG89Yyh0aGlzLmFiaSxlKTtyZXR1cm4gdC5kYXRhKz1vLHQuZGF0YX07dmFyIGg9ZnVuY3Rpb24odCxlLG4pe3RoaXMuX2V0aD10LHRoaXMudHJhbnNhY3Rpb25IYXNoPW51bGwsdGhpcy5hZGRyZXNzPW4sdGhpcy5hYmk9ZX07ZS5leHBvcnRzPXB9LHsiLi4vc29saWRpdHkvY29kZXIiOjcsIi4uL3V0aWxzL3V0aWxzIjoyMCwiLi9hbGxldmVudHMiOjIzLCIuL2V2ZW50IjoyNywiLi9mdW5jdGlvbiI6MzF9XSwyNjpbZnVuY3Rpb24odCxlLG4pe2UuZXhwb3J0cz17SW52YWxpZE51bWJlck9mU29saWRpdHlBcmdzOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBFcnJvcigiSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIFNvbGlkaXR5IGZ1bmN0aW9uIil9LEludmFsaWROdW1iZXJPZlJQQ1BhcmFtczpmdW5jdGlvbigpe3JldHVybiBuZXcgRXJyb3IoIkludmFsaWQgbnVtYmVyIG9mIGlucHV0IHBhcmFtZXRlcnMgdG8gUlBDIG1ldGhvZCIpfSxJbnZhbGlkQ29ubmVjdGlvbjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IEVycm9yKCJDT05ORUNUSU9OIEVSUk9SOiBDb3VsZG4ndCBjb25uZWN0IHRvIG5vZGUgIit0KyIuIil9LEludmFsaWRQcm92aWRlcjpmdW5jdGlvbigpe3JldHVybiBuZXcgRXJyb3IoIlByb3ZpZGVyIG5vdCBzZXQgb3IgaW52YWxpZCIpfSxJbnZhbGlkUmVzcG9uc2U6ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5lcnJvciYmdC5lcnJvci5tZXNzYWdlP3QuZXJyb3IubWVzc2FnZToiSW52YWxpZCBKU09OIFJQQyByZXNwb25zZTogIitKU09OLnN0cmluZ2lmeSh0KTtyZXR1cm4gbmV3IEVycm9yKGUpfSxDb25uZWN0aW9uVGltZW91dDpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IEVycm9yKCJDT05ORUNUSU9OIFRJTUVPVVQ6IHRpbWVvdXQgb2YgIit0KyIgbXMgYWNoaXZlZCIpfX19LHt9XSwyNzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3V0aWxzIiksbz10KCIuLi9zb2xpZGl0eS9jb2RlciIpLGk9dCgiLi9mb3JtYXR0ZXJzIiksYT10KCIuLi91dGlscy9zaGEzIikscz10KCIuL2ZpbHRlciIpLGM9dCgiLi9tZXRob2RzL3dhdGNoZXMiKSx1PWZ1bmN0aW9uKHQsZSxuKXt0aGlzLl9yZXF1ZXN0TWFuYWdlcj10LHRoaXMuX3BhcmFtcz1lLmlucHV0cyx0aGlzLl9uYW1lPXIudHJhbnNmb3JtVG9GdWxsTmFtZShlKSx0aGlzLl9hZGRyZXNzPW4sdGhpcy5fYW5vbnltb3VzPWUuYW5vbnltb3VzfTt1LnByb3RvdHlwZS50eXBlcz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4gZS5pbmRleGVkPT09dH0pLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlfSl9LHUucHJvdG90eXBlLmRpc3BsYXlOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZXh0cmFjdERpc3BsYXlOYW1lKHRoaXMuX25hbWUpfSx1LnByb3RvdHlwZS50eXBlTmFtZT1mdW5jdGlvbigpe3JldHVybiByLmV4dHJhY3RUeXBlTmFtZSh0aGlzLl9uYW1lKX0sdS5wcm90b3R5cGUuc2lnbmF0dXJlPWZ1bmN0aW9uKCl7cmV0dXJuIGEodGhpcy5fbmFtZSl9LHUucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbih0LGUpe3Q9dHx8e30sZT1lfHx7fTt2YXIgbj17fTtbImZyb21CbG9jayIsInRvQmxvY2siXS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PWVbdF19KS5mb3JFYWNoKGZ1bmN0aW9uKHQpe25bdF09aS5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKGVbdF0pfSksbi50b3BpY3M9W10sbi5hZGRyZXNzPXRoaXMuX2FkZHJlc3MsdGhpcy5fYW5vbnltb3VzfHxuLnRvcGljcy5wdXNoKCIweCIrdGhpcy5zaWduYXR1cmUoKSk7dmFyIGE9dGhpcy5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4hMD09PXQuaW5kZXhlZH0pLm1hcChmdW5jdGlvbihlKXt2YXIgbj10W2UubmFtZV07cmV0dXJuIHZvaWQgMD09PW58fG51bGw9PT1uP251bGw6ci5pc0FycmF5KG4pP24ubWFwKGZ1bmN0aW9uKHQpe3JldHVybiIweCIrby5lbmNvZGVQYXJhbShlLnR5cGUsdCl9KToiMHgiK28uZW5jb2RlUGFyYW0oZS50eXBlLG4pfSk7cmV0dXJuIG4udG9waWNzPW4udG9waWNzLmNvbmNhdChhKSxufSx1LnByb3RvdHlwZS5kZWNvZGU9ZnVuY3Rpb24odCl7dC5kYXRhPXQuZGF0YXx8IiIsdC50b3BpY3M9dC50b3BpY3N8fFtdO3ZhciBlPSh0aGlzLl9hbm9ueW1vdXM/dC50b3BpY3M6dC50b3BpY3Muc2xpY2UoMSkpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC5zbGljZSgyKX0pLmpvaW4oIiIpLG49by5kZWNvZGVQYXJhbXModGhpcy50eXBlcyghMCksZSkscj10LmRhdGEuc2xpY2UoMiksYT1vLmRlY29kZVBhcmFtcyh0aGlzLnR5cGVzKCExKSxyKSxzPWkub3V0cHV0TG9nRm9ybWF0dGVyKHQpO3JldHVybiBzLmV2ZW50PXRoaXMuZGlzcGxheU5hbWUoKSxzLmFkZHJlc3M9dC5hZGRyZXNzLHMuYXJncz10aGlzLl9wYXJhbXMucmVkdWNlKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbZS5uYW1lXT1lLmluZGV4ZWQ/bi5zaGlmdCgpOmEuc2hpZnQoKSx0fSx7fSksZGVsZXRlIHMuZGF0YSxkZWxldGUgcy50b3BpY3Msc30sdS5wcm90b3R5cGUuZXhlY3V0ZT1mdW5jdGlvbih0LGUsbil7ci5pc0Z1bmN0aW9uKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTFdKSYmKG49YXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGgtMV0sMj09PWFyZ3VtZW50cy5sZW5ndGgmJihlPW51bGwpLDE9PT1hcmd1bWVudHMubGVuZ3RoJiYoZT1udWxsLHQ9e30pKTt2YXIgbz10aGlzLmVuY29kZSh0LGUpLGk9dGhpcy5kZWNvZGUuYmluZCh0aGlzKTtyZXR1cm4gbmV3IHMobywiZXRoIix0aGlzLl9yZXF1ZXN0TWFuYWdlcixjLmV0aCgpLGksbil9LHUucHJvdG90eXBlLmF0dGFjaFRvQ29udHJhY3Q9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5leGVjdXRlLmJpbmQodGhpcyksbj10aGlzLmRpc3BsYXlOYW1lKCk7dFtuXXx8KHRbbl09ZSksdFtuXVt0aGlzLnR5cGVOYW1lKCldPXRoaXMuZXhlY3V0ZS5iaW5kKHRoaXMsdCl9LGUuZXhwb3J0cz11fSx7Ii4uL3NvbGlkaXR5L2NvZGVyIjo3LCIuLi91dGlscy9zaGEzIjoxOSwiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2ZpbHRlciI6MjksIi4vZm9ybWF0dGVycyI6MzAsIi4vbWV0aG9kcy93YXRjaGVzIjo0M31dLDI4OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9mb3JtYXR0ZXJzIiksbz10KCIuLy4uL3V0aWxzL3V0aWxzIiksaT10KCIuL21ldGhvZCIpLGE9dCgiLi9wcm9wZXJ0eSIpO2UuZXhwb3J0cz1mdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbihlKXt2YXIgbjtlLnByb3BlcnR5Pyh0W2UucHJvcGVydHldfHwodFtlLnByb3BlcnR5XT17fSksbj10W2UucHJvcGVydHldKTpuPXQsZS5tZXRob2RzJiZlLm1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvT2JqZWN0KG4pLGUuc2V0UmVxdWVzdE1hbmFnZXIodC5fcmVxdWVzdE1hbmFnZXIpfSksZS5wcm9wZXJ0aWVzJiZlLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbihlKXtlLmF0dGFjaFRvT2JqZWN0KG4pLGUuc2V0UmVxdWVzdE1hbmFnZXIodC5fcmVxdWVzdE1hbmFnZXIpfSl9O3JldHVybiBlLmZvcm1hdHRlcnM9cixlLnV0aWxzPW8sZS5NZXRob2Q9aSxlLlByb3BlcnR5PWEsZX19LHsiLi8uLi91dGlscy91dGlscyI6MjAsIi4vZm9ybWF0dGVycyI6MzAsIi4vbWV0aG9kIjozNiwiLi9wcm9wZXJ0eSI6NDV9XSwyOTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4vZm9ybWF0dGVycyIpLG89dCgiLi4vdXRpbHMvdXRpbHMiKSxpPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT09dHx8dm9pZCAwPT09dD9udWxsOjA9PT0odD1TdHJpbmcodCkpLmluZGV4T2YoIjB4Iik/dDpvLmZyb21VdGY4KHQpfSxhPWZ1bmN0aW9uKHQsZSl7by5pc1N0cmluZyh0Lm9wdGlvbnMpfHx0LmdldChmdW5jdGlvbih0LG4pe3QmJmUodCksby5pc0FycmF5KG4pJiZuLmZvckVhY2goZnVuY3Rpb24odCl7ZShudWxsLHQpfSl9KX0scz1mdW5jdGlvbih0KXt0LnJlcXVlc3RNYW5hZ2VyLnN0YXJ0UG9sbGluZyh7bWV0aG9kOnQuaW1wbGVtZW50YXRpb24ucG9sbC5jYWxsLHBhcmFtczpbdC5maWx0ZXJJZF19LHQuZmlsdGVySWQsZnVuY3Rpb24oZSxuKXtpZihlKXJldHVybiB0LmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QoZSl9KTtvLmlzQXJyYXkobikmJm4uZm9yRWFjaChmdW5jdGlvbihlKXtlPXQuZm9ybWF0dGVyP3QuZm9ybWF0dGVyKGUpOmUsdC5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbih0KXt0KG51bGwsZSl9KX0pfSx0LnN0b3BXYXRjaGluZy5iaW5kKHQpKX0sYz1mdW5jdGlvbih0LGUsbixjLHUsZixsKXt2YXIgcD10aGlzLGg9e307cmV0dXJuIGMuZm9yRWFjaChmdW5jdGlvbih0KXt0LnNldFJlcXVlc3RNYW5hZ2VyKG4pLHQuYXR0YWNoVG9PYmplY3QoaCl9KSx0aGlzLnJlcXVlc3RNYW5hZ2VyPW4sdGhpcy5vcHRpb25zPWZ1bmN0aW9uKHQsZSl7aWYoby5pc1N0cmluZyh0KSlyZXR1cm4gdDtzd2l0Y2godD10fHx7fSxlKXtjYXNlImV0aCI6cmV0dXJuIHQudG9waWNzPXQudG9waWNzfHxbXSx0LnRvcGljcz10LnRvcGljcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG8uaXNBcnJheSh0KT90Lm1hcChpKTppKHQpfSkse3RvcGljczp0LnRvcGljcyxmcm9tOnQuZnJvbSx0bzp0LnRvLGFkZHJlc3M6dC5hZGRyZXNzLGZyb21CbG9jazpyLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIodC5mcm9tQmxvY2spLHRvQmxvY2s6ci5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKHQudG9CbG9jayl9O2Nhc2Uic2hoIjpyZXR1cm4gdH19KHQsZSksdGhpcy5pbXBsZW1lbnRhdGlvbj1oLHRoaXMuZmlsdGVySWQ9bnVsbCx0aGlzLmNhbGxiYWNrcz1bXSx0aGlzLmdldExvZ3NDYWxsYmFja3M9W10sdGhpcy5wb2xsRmlsdGVycz1bXSx0aGlzLmZvcm1hdHRlcj11LHRoaXMuaW1wbGVtZW50YXRpb24ubmV3RmlsdGVyKHRoaXMub3B0aW9ucyxmdW5jdGlvbih0LGUpe2lmKHQpcC5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihlKXtlKHQpfSksImZ1bmN0aW9uIj09dHlwZW9mIGwmJmwodCk7ZWxzZSBpZihwLmZpbHRlcklkPWUscC5nZXRMb2dzQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24odCl7cC5nZXQodCl9KSxwLmdldExvZ3NDYWxsYmFja3M9W10scC5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbih0KXthKHAsdCl9KSxwLmNhbGxiYWNrcy5sZW5ndGg+MCYmcyhwKSwiZnVuY3Rpb24iPT10eXBlb2YgZilyZXR1cm4gcC53YXRjaChmKX0pLHRoaXN9O2MucHJvdG90eXBlLndhdGNoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNhbGxiYWNrcy5wdXNoKHQpLHRoaXMuZmlsdGVySWQmJihhKHRoaXMsdCkscyh0aGlzKSksdGhpc30sYy5wcm90b3R5cGUuc3RvcFdhdGNoaW5nPWZ1bmN0aW9uKHQpe2lmKHRoaXMucmVxdWVzdE1hbmFnZXIuc3RvcFBvbGxpbmcodGhpcy5maWx0ZXJJZCksdGhpcy5jYWxsYmFja3M9W10sIXQpcmV0dXJuIHRoaXMuaW1wbGVtZW50YXRpb24udW5pbnN0YWxsRmlsdGVyKHRoaXMuZmlsdGVySWQpO3RoaXMuaW1wbGVtZW50YXRpb24udW5pbnN0YWxsRmlsdGVyKHRoaXMuZmlsdGVySWQsdCl9LGMucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXt2YXIgZT10aGlzO2lmKCFvLmlzRnVuY3Rpb24odCkpe2lmKG51bGw9PT10aGlzLmZpbHRlcklkKXRocm93IG5ldyBFcnJvcigiRmlsdGVyIElEIEVycm9yOiBmaWx0ZXIoKS5nZXQoKSBjYW4ndCBiZSBjaGFpbmVkIHN5bmNocm9ub3VzLCBwbGVhc2UgcHJvdmlkZSBhIGNhbGxiYWNrIGZvciB0aGUgZ2V0KCkgbWV0aG9kLiIpO3JldHVybiB0aGlzLmltcGxlbWVudGF0aW9uLmdldExvZ3ModGhpcy5maWx0ZXJJZCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBlLmZvcm1hdHRlcj9lLmZvcm1hdHRlcih0KTp0fSl9cmV0dXJuIG51bGw9PT10aGlzLmZpbHRlcklkP3RoaXMuZ2V0TG9nc0NhbGxiYWNrcy5wdXNoKHQpOnRoaXMuaW1wbGVtZW50YXRpb24uZ2V0TG9ncyh0aGlzLmZpbHRlcklkLGZ1bmN0aW9uKG4scil7bj90KG4pOnQobnVsbCxyLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gZS5mb3JtYXR0ZXI/ZS5mb3JtYXR0ZXIodCk6dH0pKX0pLHRoaXN9LGUuZXhwb3J0cz1jfSx7Ii4uL3V0aWxzL3V0aWxzIjoyMCwiLi9mb3JtYXR0ZXJzIjozMH1dLDMwOltmdW5jdGlvbih0LGUsbil7InVzZSBzdHJpY3QiO3ZhciByPXQoIi4uL3V0aWxzL3V0aWxzIiksbz10KCIuLi91dGlscy9jb25maWciKSxpPXQoIi4vaWJhbiIpLGE9ZnVuY3Rpb24odCl7aWYodm9pZCAwIT09dClyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuImxhdGVzdCI9PT10fHwicGVuZGluZyI9PT10fHwiZWFybGllc3QiPT09dH0odCk/dDpyLnRvSGV4KHQpfSxzPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsIT09dC5ibG9ja051bWJlciYmKHQuYmxvY2tOdW1iZXI9ci50b0RlY2ltYWwodC5ibG9ja051bWJlcikpLG51bGwhPT10LnRyYW5zYWN0aW9uSW5kZXgmJih0LnRyYW5zYWN0aW9uSW5kZXg9ci50b0RlY2ltYWwodC50cmFuc2FjdGlvbkluZGV4KSksdC5ub25jZT1yLnRvRGVjaW1hbCh0Lm5vbmNlKSx0Lmdhcz1yLnRvRGVjaW1hbCh0LmdhcyksdC5nYXNQcmljZT1yLnRvQmlnTnVtYmVyKHQuZ2FzUHJpY2UpLHQudmFsdWU9ci50b0JpZ051bWJlcih0LnZhbHVlKSx0fSxjPWZ1bmN0aW9uKHQpe3JldHVybiB0LmJsb2NrTnVtYmVyJiYodC5ibG9ja051bWJlcj1yLnRvRGVjaW1hbCh0LmJsb2NrTnVtYmVyKSksdC50cmFuc2FjdGlvbkluZGV4JiYodC50cmFuc2FjdGlvbkluZGV4PXIudG9EZWNpbWFsKHQudHJhbnNhY3Rpb25JbmRleCkpLHQubG9nSW5kZXgmJih0LmxvZ0luZGV4PXIudG9EZWNpbWFsKHQubG9nSW5kZXgpKSx0fSx1PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBpKHQpO2lmKGUuaXNWYWxpZCgpJiZlLmlzRGlyZWN0KCkpcmV0dXJuIjB4IitlLmFkZHJlc3MoKTtpZihyLmlzU3RyaWN0QWRkcmVzcyh0KSlyZXR1cm4gdDtpZihyLmlzQWRkcmVzcyh0KSlyZXR1cm4iMHgiK3Q7dGhyb3cgbmV3IEVycm9yKCJpbnZhbGlkIGFkZHJlc3MiKX07ZS5leHBvcnRzPXtpbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dD9vLmRlZmF1bHRCbG9jazphKHQpfSxpbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyOmEsaW5wdXRDYWxsRm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiB0LmZyb209dC5mcm9tfHxvLmRlZmF1bHRBY2NvdW50LHQuZnJvbSYmKHQuZnJvbT11KHQuZnJvbSkpLHQudG8mJih0LnRvPXUodC50bykpLFsiZ2FzUHJpY2UiLCJnYXMiLCJ2YWx1ZSIsIm5vbmNlIl0uZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiB2b2lkIDAhPT10W2VdfSkuZm9yRWFjaChmdW5jdGlvbihlKXt0W2VdPXIuZnJvbURlY2ltYWwodFtlXSl9KSx0fSxpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyOmZ1bmN0aW9uKHQpe3JldHVybiB0LmZyb209dC5mcm9tfHxvLmRlZmF1bHRBY2NvdW50LHQuZnJvbT11KHQuZnJvbSksdC50byYmKHQudG89dSh0LnRvKSksWyJnYXNQcmljZSIsImdhcyIsInZhbHVlIiwibm9uY2UiXS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIHZvaWQgMCE9PXRbZV19KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbZV09ci5mcm9tRGVjaW1hbCh0W2VdKX0pLHR9LGlucHV0QWRkcmVzc0Zvcm1hdHRlcjp1LGlucHV0UG9zdEZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdC50dGw9ci5mcm9tRGVjaW1hbCh0LnR0bCksdC53b3JrVG9Qcm92ZT1yLmZyb21EZWNpbWFsKHQud29ya1RvUHJvdmUpLHQucHJpb3JpdHk9ci5mcm9tRGVjaW1hbCh0LnByaW9yaXR5KSxyLmlzQXJyYXkodC50b3BpY3MpfHwodC50b3BpY3M9dC50b3BpY3M/W3QudG9waWNzXTpbXSksdC50b3BpY3M9dC50b3BpY3MubWFwKGZ1bmN0aW9uKHQpe3JldHVybiAwPT09dC5pbmRleE9mKCIweCIpP3Q6ci5mcm9tVXRmOCh0KX0pLHR9LG91dHB1dEJpZ051bWJlckZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gci50b0JpZ051bWJlcih0KX0sb3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXI6cyxvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGwhPT10LmJsb2NrTnVtYmVyJiYodC5ibG9ja051bWJlcj1yLnRvRGVjaW1hbCh0LmJsb2NrTnVtYmVyKSksbnVsbCE9PXQudHJhbnNhY3Rpb25JbmRleCYmKHQudHJhbnNhY3Rpb25JbmRleD1yLnRvRGVjaW1hbCh0LnRyYW5zYWN0aW9uSW5kZXgpKSx0LmN1bXVsYXRpdmVHYXNVc2VkPXIudG9EZWNpbWFsKHQuY3VtdWxhdGl2ZUdhc1VzZWQpLHQuZ2FzVXNlZD1yLnRvRGVjaW1hbCh0Lmdhc1VzZWQpLHIuaXNBcnJheSh0LmxvZ3MpJiYodC5sb2dzPXQubG9ncy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIGModCl9KSksdH0sb3V0cHV0QmxvY2tGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2FzTGltaXQ9ci50b0RlY2ltYWwodC5nYXNMaW1pdCksdC5nYXNVc2VkPXIudG9EZWNpbWFsKHQuZ2FzVXNlZCksdC5zaXplPXIudG9EZWNpbWFsKHQuc2l6ZSksdC50aW1lc3RhbXA9ci50b0RlY2ltYWwodC50aW1lc3RhbXApLG51bGwhPT10Lm51bWJlciYmKHQubnVtYmVyPXIudG9EZWNpbWFsKHQubnVtYmVyKSksdC5kaWZmaWN1bHR5PXIudG9CaWdOdW1iZXIodC5kaWZmaWN1bHR5KSx0LnRvdGFsRGlmZmljdWx0eT1yLnRvQmlnTnVtYmVyKHQudG90YWxEaWZmaWN1bHR5KSxyLmlzQXJyYXkodC50cmFuc2FjdGlvbnMpJiZ0LnRyYW5zYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHQpe2lmKCFyLmlzU3RyaW5nKHQpKXJldHVybiBzKHQpfSksdH0sb3V0cHV0TG9nRm9ybWF0dGVyOmMsb3V0cHV0UG9zdEZvcm1hdHRlcjpmdW5jdGlvbih0KXtyZXR1cm4gdC5leHBpcnk9ci50b0RlY2ltYWwodC5leHBpcnkpLHQuc2VudD1yLnRvRGVjaW1hbCh0LnNlbnQpLHQudHRsPXIudG9EZWNpbWFsKHQudHRsKSx0LndvcmtQcm92ZWQ9ci50b0RlY2ltYWwodC53b3JrUHJvdmVkKSx0LnRvcGljc3x8KHQudG9waWNzPVtdKSx0LnRvcGljcz10LnRvcGljcy5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHIudG9Bc2NpaSh0KX0pLHR9LG91dHB1dFN5bmNpbmdGb3JtYXR0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQ/KHQuc3RhcnRpbmdCbG9jaz1yLnRvRGVjaW1hbCh0LnN0YXJ0aW5nQmxvY2spLHQuY3VycmVudEJsb2NrPXIudG9EZWNpbWFsKHQuY3VycmVudEJsb2NrKSx0LmhpZ2hlc3RCbG9jaz1yLnRvRGVjaW1hbCh0LmhpZ2hlc3RCbG9jayksdC5rbm93blN0YXRlcyYmKHQua25vd25TdGF0ZXM9ci50b0RlY2ltYWwodC5rbm93blN0YXRlcyksdC5wdWxsZWRTdGF0ZXM9ci50b0RlY2ltYWwodC5wdWxsZWRTdGF0ZXMpKSx0KTp0fX19LHsiLi4vdXRpbHMvY29uZmlnIjoxOCwiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2liYW4iOjMzfV0sMzE6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuLi9zb2xpZGl0eS9jb2RlciIpLG89dCgiLi4vdXRpbHMvdXRpbHMiKSxpPXQoIi4vZXJyb3JzIiksYT10KCIuL2Zvcm1hdHRlcnMiKSxzPXQoIi4uL3V0aWxzL3NoYTMiKSxjPWZ1bmN0aW9uKHQsZSxuKXt0aGlzLl9ldGg9dCx0aGlzLl9pbnB1dFR5cGVzPWUuaW5wdXRzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlfSksdGhpcy5fb3V0cHV0VHlwZXM9ZS5vdXRwdXRzLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdC50eXBlfSksdGhpcy5fY29uc3RhbnQ9ZS5jb25zdGFudCx0aGlzLl9wYXlhYmxlPWUucGF5YWJsZSx0aGlzLl9uYW1lPW8udHJhbnNmb3JtVG9GdWxsTmFtZShlKSx0aGlzLl9hZGRyZXNzPW59O2MucHJvdG90eXBlLmV4dHJhY3RDYWxsYmFjaz1mdW5jdGlvbih0KXtpZihvLmlzRnVuY3Rpb24odFt0Lmxlbmd0aC0xXSkpcmV0dXJuIHQucG9wKCl9LGMucHJvdG90eXBlLmV4dHJhY3REZWZhdWx0QmxvY2s9ZnVuY3Rpb24odCl7aWYodC5sZW5ndGg+dGhpcy5faW5wdXRUeXBlcy5sZW5ndGgmJiFvLmlzT2JqZWN0KHRbdC5sZW5ndGgtMV0pKXJldHVybiBhLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyKHQucG9wKCkpfSxjLnByb3RvdHlwZS52YWxpZGF0ZUFyZ3M9ZnVuY3Rpb24odCl7aWYodC5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuISghMD09PW8uaXNPYmplY3QodCkmJiExPT09by5pc0FycmF5KHQpJiYhMT09PW8uaXNCaWdOdW1iZXIodCkpfSkubGVuZ3RoIT09dGhpcy5faW5wdXRUeXBlcy5sZW5ndGgpdGhyb3cgaS5JbnZhbGlkTnVtYmVyT2ZTb2xpZGl0eUFyZ3MoKX0sYy5wcm90b3R5cGUudG9QYXlsb2FkPWZ1bmN0aW9uKHQpe3ZhciBlPXt9O3JldHVybiB0Lmxlbmd0aD50aGlzLl9pbnB1dFR5cGVzLmxlbmd0aCYmby5pc09iamVjdCh0W3QubGVuZ3RoLTFdKSYmKGU9dFt0Lmxlbmd0aC0xXSksdGhpcy52YWxpZGF0ZUFyZ3ModCksZS50bz10aGlzLl9hZGRyZXNzLGUuZGF0YT0iMHgiK3RoaXMuc2lnbmF0dXJlKCkrci5lbmNvZGVQYXJhbXModGhpcy5faW5wdXRUeXBlcyx0KSxlfSxjLnByb3RvdHlwZS5zaWduYXR1cmU9ZnVuY3Rpb24oKXtyZXR1cm4gcyh0aGlzLl9uYW1lKS5zbGljZSgwLDgpfSxjLnByb3RvdHlwZS51bnBhY2tPdXRwdXQ9ZnVuY3Rpb24odCl7aWYodCl7dD10Lmxlbmd0aD49Mj90LnNsaWNlKDIpOnQ7dmFyIGU9ci5kZWNvZGVQYXJhbXModGhpcy5fb3V0cHV0VHlwZXMsdCk7cmV0dXJuIDE9PT1lLmxlbmd0aD9lWzBdOmV9fSxjLnByb3RvdHlwZS5jYWxsPWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5maWx0ZXIoZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXR9KSxlPXRoaXMuZXh0cmFjdENhbGxiYWNrKHQpLG49dGhpcy5leHRyYWN0RGVmYXVsdEJsb2NrKHQpLHI9dGhpcy50b1BheWxvYWQodCk7aWYoIWUpe3ZhciBvPXRoaXMuX2V0aC5jYWxsKHIsbik7cmV0dXJuIHRoaXMudW5wYWNrT3V0cHV0KG8pfXZhciBpPXRoaXM7dGhpcy5fZXRoLmNhbGwocixuLGZ1bmN0aW9uKHQsbil7aWYodClyZXR1cm4gZSh0LG51bGwpO3ZhciByPW51bGw7dHJ5e3I9aS51bnBhY2tPdXRwdXQobil9Y2F0Y2goZSl7dD1lfWUodCxyKX0pfSxjLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb249ZnVuY3Rpb24oKXt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwIT09dH0pLGU9dGhpcy5leHRyYWN0Q2FsbGJhY2sodCksbj10aGlzLnRvUGF5bG9hZCh0KTtpZihuLnZhbHVlPjAmJiF0aGlzLl9wYXlhYmxlKXRocm93IG5ldyBFcnJvcigiQ2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgZnVuY3Rpb24iKTtpZighZSlyZXR1cm4gdGhpcy5fZXRoLnNlbmRUcmFuc2FjdGlvbihuKTt0aGlzLl9ldGguc2VuZFRyYW5zYWN0aW9uKG4sZSl9LGMucHJvdG90eXBlLmVzdGltYXRlR2FzPWZ1bmN0aW9uKCl7dmFyIHQ9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxlPXRoaXMuZXh0cmFjdENhbGxiYWNrKHQpLG49dGhpcy50b1BheWxvYWQodCk7aWYoIWUpcmV0dXJuIHRoaXMuX2V0aC5lc3RpbWF0ZUdhcyhuKTt0aGlzLl9ldGguZXN0aW1hdGVHYXMobixlKX0sYy5wcm90b3R5cGUuZ2V0RGF0YT1mdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7cmV0dXJuIHRoaXMudG9QYXlsb2FkKHQpLmRhdGF9LGMucHJvdG90eXBlLmRpc3BsYXlOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuIG8uZXh0cmFjdERpc3BsYXlOYW1lKHRoaXMuX25hbWUpfSxjLnByb3RvdHlwZS50eXBlTmFtZT1mdW5jdGlvbigpe3JldHVybiBvLmV4dHJhY3RUeXBlTmFtZSh0aGlzLl9uYW1lKX0sYy5wcm90b3R5cGUucmVxdWVzdD1mdW5jdGlvbigpe3ZhciB0PUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksZT10aGlzLmV4dHJhY3RDYWxsYmFjayh0KSxuPXRoaXMudG9QYXlsb2FkKHQpLHI9dGhpcy51bnBhY2tPdXRwdXQuYmluZCh0aGlzKTtyZXR1cm57bWV0aG9kOnRoaXMuX2NvbnN0YW50PyJldGhfY2FsbCI6ImV0aF9zZW5kVHJhbnNhY3Rpb24iLGNhbGxiYWNrOmUscGFyYW1zOltuXSxmb3JtYXQ6cn19LGMucHJvdG90eXBlLmV4ZWN1dGU9ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5fY29uc3RhbnQ/dGhpcy5zZW5kVHJhbnNhY3Rpb24uYXBwbHkodGhpcyxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTp0aGlzLmNhbGwuYXBwbHkodGhpcyxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKX0sYy5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTtlLnJlcXVlc3Q9dGhpcy5yZXF1ZXN0LmJpbmQodGhpcyksZS5jYWxsPXRoaXMuY2FsbC5iaW5kKHRoaXMpLGUuc2VuZFRyYW5zYWN0aW9uPXRoaXMuc2VuZFRyYW5zYWN0aW9uLmJpbmQodGhpcyksZS5lc3RpbWF0ZUdhcz10aGlzLmVzdGltYXRlR2FzLmJpbmQodGhpcyksZS5nZXREYXRhPXRoaXMuZ2V0RGF0YS5iaW5kKHRoaXMpO3ZhciBuPXRoaXMuZGlzcGxheU5hbWUoKTt0W25dfHwodFtuXT1lKSx0W25dW3RoaXMudHlwZU5hbWUoKV09ZX0sZS5leHBvcnRzPWN9LHsiLi4vc29saWRpdHkvY29kZXIiOjcsIi4uL3V0aWxzL3NoYTMiOjE5LCIuLi91dGlscy91dGlscyI6MjAsIi4vZXJyb3JzIjoyNiwiLi9mb3JtYXR0ZXJzIjozMH1dLDMyOltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9lcnJvcnMiKTsidW5kZWZpbmVkIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93LlhNTEh0dHBSZXF1ZXN0P1hNTEh0dHBSZXF1ZXN0PXdpbmRvdy5YTUxIdHRwUmVxdWVzdDpYTUxIdHRwUmVxdWVzdD10KCJ4bWxodHRwcmVxdWVzdCIpLlhNTEh0dHBSZXF1ZXN0O3ZhciBvPXQoInhocjIiKSxpPWZ1bmN0aW9uKHQsZSxuLHIsbyl7dGhpcy5ob3N0PXR8fCJodHRwOi8vbG9jYWxob3N0Ojg1NDUiLHRoaXMudGltZW91dD1lfHwwLHRoaXMudXNlcj1uLHRoaXMucGFzc3dvcmQ9cix0aGlzLmhlYWRlcnM9b307aS5wcm90b3R5cGUucHJlcGFyZVJlcXVlc3Q9ZnVuY3Rpb24odCl7dmFyIGU7aWYodD8oZT1uZXcgbykudGltZW91dD10aGlzLnRpbWVvdXQ6ZT1uZXcgWE1MSHR0cFJlcXVlc3QsZS5vcGVuKCJQT1NUIix0aGlzLmhvc3QsdCksdGhpcy51c2VyJiZ0aGlzLnBhc3N3b3JkKXt2YXIgbj0iQmFzaWMgIituZXcgQnVmZmVyKHRoaXMudXNlcisiOiIrdGhpcy5wYXNzd29yZCkudG9TdHJpbmcoImJhc2U2NCIpO2Uuc2V0UmVxdWVzdEhlYWRlcigiQXV0aG9yaXphdGlvbiIsbil9cmV0dXJuIGUuc2V0UmVxdWVzdEhlYWRlcigiQ29udGVudC1UeXBlIiwiYXBwbGljYXRpb24vanNvbiIpLHRoaXMuaGVhZGVycyYmdGhpcy5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odCl7ZS5zZXRSZXF1ZXN0SGVhZGVyKHQubmFtZSx0LnZhbHVlKX0pLGV9LGkucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcmVwYXJlUmVxdWVzdCghMSk7dHJ5e2Uuc2VuZChKU09OLnN0cmluZ2lmeSh0KSl9Y2F0Y2godCl7dGhyb3cgci5JbnZhbGlkQ29ubmVjdGlvbih0aGlzLmhvc3QpfXZhciBuPWUucmVzcG9uc2VUZXh0O3RyeXtuPUpTT04ucGFyc2Uobil9Y2F0Y2godCl7dGhyb3cgci5JbnZhbGlkUmVzcG9uc2UoZS5yZXNwb25zZVRleHQpfXJldHVybiBufSxpLnByb3RvdHlwZS5zZW5kQXN5bmM9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnByZXBhcmVSZXF1ZXN0KCEwKTtuLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKDQ9PT1uLnJlYWR5U3RhdGUmJjEhPT1uLnRpbWVvdXQpe3ZhciB0PW4ucmVzcG9uc2VUZXh0LG89bnVsbDt0cnl7dD1KU09OLnBhcnNlKHQpfWNhdGNoKHQpe289ci5JbnZhbGlkUmVzcG9uc2Uobi5yZXNwb25zZVRleHQpfWUobyx0KX19LG4ub250aW1lb3V0PWZ1bmN0aW9uKCl7ZShyLkNvbm5lY3Rpb25UaW1lb3V0KHRoaXMudGltZW91dCkpfTt0cnl7bi5zZW5kKEpTT04uc3RyaW5naWZ5KHQpKX1jYXRjaCh0KXtlKHIuSW52YWxpZENvbm5lY3Rpb24odGhpcy5ob3N0KSl9fSxpLnByb3RvdHlwZS5pc0Nvbm5lY3RlZD1mdW5jdGlvbigpe3RyeXtyZXR1cm4gdGhpcy5zZW5kKHtpZDo5OTk5OTk5OTk5LGpzb25ycGM6IjIuMCIsbWV0aG9kOiJuZXRfbGlzdGVuaW5nIixwYXJhbXM6W119KSwhMH1jYXRjaCh0KXtyZXR1cm4hMX19LGUuZXhwb3J0cz1pfSx7Ii4vZXJyb3JzIjoyNix4aHIyOjg2LHhtbGh0dHByZXF1ZXN0OjE3fV0sMzM6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCJiaWdudW1iZXIuanMiKSxvPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQ7bi5sZW5ndGg8MiplOyluPSIwIituO3JldHVybiBufSxpPWZ1bmN0aW9uKHQpe3ZhciBlPSJBIi5jaGFyQ29kZUF0KDApLG49IloiLmNoYXJDb2RlQXQoMCk7cmV0dXJuIHQ9dC50b1VwcGVyQ2FzZSgpLCh0PXQuc3Vic3RyKDQpK3Quc3Vic3RyKDAsNCkpLnNwbGl0KCIiKS5tYXAoZnVuY3Rpb24odCl7dmFyIHI9dC5jaGFyQ29kZUF0KDApO3JldHVybiByPj1lJiZyPD1uP3ItZSsxMDp0fSkuam9pbigiIil9LGE9ZnVuY3Rpb24odCl7Zm9yKHZhciBlLG49dDtuLmxlbmd0aD4yOyllPW4uc2xpY2UoMCw5KSxuPXBhcnNlSW50KGUsMTApJTk3K24uc2xpY2UoZS5sZW5ndGgpO3JldHVybiBwYXJzZUludChuLDEwKSU5N30scz1mdW5jdGlvbih0KXt0aGlzLl9pYmFuPXR9O3MuZnJvbUFkZHJlc3M9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHIodCwxNikudG9TdHJpbmcoMzYpLG49byhlLDE1KTtyZXR1cm4gcy5mcm9tQmJhbihuLnRvVXBwZXJDYXNlKCkpfSxzLmZyb21CYmFuPWZ1bmN0aW9uKHQpe3ZhciBlPSgiMCIrKDk4LWEoaSgiWEUwMCIrdCkpKSkuc2xpY2UoLTIpO3JldHVybiBuZXcgcygiWEUiK2UrdCl9LHMuY3JlYXRlSW5kaXJlY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIHMuZnJvbUJiYW4oIkVUSCIrdC5pbnN0aXR1dGlvbit0LmlkZW50aWZpZXIpfSxzLmlzVmFsaWQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBzKHQpLmlzVmFsaWQoKX0scy5wcm90b3R5cGUuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybi9eWEVbMC05XXsyfShFVEhbMC05QS1aXXsxM318WzAtOUEtWl17MzAsMzF9KSQvLnRlc3QodGhpcy5faWJhbikmJjE9PT1hKGkodGhpcy5faWJhbikpfSxzLnByb3RvdHlwZS5pc0RpcmVjdD1mdW5jdGlvbigpe3JldHVybiAzND09PXRoaXMuX2liYW4ubGVuZ3RofHwzNT09PXRoaXMuX2liYW4ubGVuZ3RofSxzLnByb3RvdHlwZS5pc0luZGlyZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIDIwPT09dGhpcy5faWJhbi5sZW5ndGh9LHMucHJvdG90eXBlLmNoZWNrc3VtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2liYW4uc3Vic3RyKDIsMil9LHMucHJvdG90eXBlLmluc3RpdHV0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNJbmRpcmVjdCgpP3RoaXMuX2liYW4uc3Vic3RyKDcsNCk6IiJ9LHMucHJvdG90eXBlLmNsaWVudD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzSW5kaXJlY3QoKT90aGlzLl9pYmFuLnN1YnN0cigxMSk6IiJ9LHMucHJvdG90eXBlLmFkZHJlc3M9ZnVuY3Rpb24oKXtpZih0aGlzLmlzRGlyZWN0KCkpe3ZhciB0PXRoaXMuX2liYW4uc3Vic3RyKDQpLGU9bmV3IHIodCwzNik7cmV0dXJuIG8oZS50b1N0cmluZygxNiksMjApfXJldHVybiIifSxzLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9pYmFufSxlLmV4cG9ydHM9c30seyJiaWdudW1iZXIuanMiOiJiaWdudW1iZXIuanMifV0sMzQ6W2Z1bmN0aW9uKHQsZSxuKXsidXNlIHN0cmljdCI7dmFyIHI9dCgiLi4vdXRpbHMvdXRpbHMiKSxvPXQoIi4vZXJyb3JzIiksaT1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXM7dGhpcy5yZXNwb25zZUNhbGxiYWNrcz17fSx0aGlzLnBhdGg9dCx0aGlzLmNvbm5lY3Rpb249ZS5jb25uZWN0KHtwYXRoOnRoaXMucGF0aH0pLHRoaXMuY29ubmVjdGlvbi5vbigiZXJyb3IiLGZ1bmN0aW9uKHQpe2NvbnNvbGUuZXJyb3IoIklQQyBDb25uZWN0aW9uIEVycm9yIix0KSxuLl90aW1lb3V0KCl9KSx0aGlzLmNvbm5lY3Rpb24ub24oImVuZCIsZnVuY3Rpb24oKXtuLl90aW1lb3V0KCl9KSx0aGlzLmNvbm5lY3Rpb24ub24oImRhdGEiLGZ1bmN0aW9uKHQpe24uX3BhcnNlUmVzcG9uc2UodC50b1N0cmluZygpKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3ZhciBlPW51bGw7ci5pc0FycmF5KHQpP3QuZm9yRWFjaChmdW5jdGlvbih0KXtuLnJlc3BvbnNlQ2FsbGJhY2tzW3QuaWRdJiYoZT10LmlkKX0pOmU9dC5pZCxuLnJlc3BvbnNlQ2FsbGJhY2tzW2VdJiYobi5yZXNwb25zZUNhbGxiYWNrc1tlXShudWxsLHQpLGRlbGV0ZSBuLnJlc3BvbnNlQ2FsbGJhY2tzW2VdKX0pfSl9O2kucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj1bXTtyZXR1cm4gdC5yZXBsYWNlKC9cfVtcblxyXT9cey9nLCJ9fC0tfHsiKS5yZXBsYWNlKC9cfVxdW1xuXHJdP1xbXHsvZywifV18LS18W3siKS5yZXBsYWNlKC9cfVtcblxyXT9cW1x7L2csIn18LS18W3siKS5yZXBsYWNlKC9cfVxdW1xuXHJdP1x7L2csIn1dfC0tfHsiKS5zcGxpdCgifC0tfCIpLmZvckVhY2goZnVuY3Rpb24odCl7ZS5sYXN0Q2h1bmsmJih0PWUubGFzdENodW5rK3QpO3ZhciByPW51bGw7dHJ5e3I9SlNPTi5wYXJzZSh0KX1jYXRjaChuKXtyZXR1cm4gZS5sYXN0Q2h1bms9dCxjbGVhclRpbWVvdXQoZS5sYXN0Q2h1bmtUaW1lb3V0KSx2b2lkKGUubGFzdENodW5rVGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dGhyb3cgZS5fdGltZW91dCgpLG8uSW52YWxpZFJlc3BvbnNlKHQpfSwxNWUzKSl9Y2xlYXJUaW1lb3V0KGUubGFzdENodW5rVGltZW91dCksZS5sYXN0Q2h1bms9bnVsbCxyJiZuLnB1c2gocil9KSxufSxpLnByb3RvdHlwZS5fYWRkUmVzcG9uc2VDYWxsYmFjaz1mdW5jdGlvbih0LGUpe3ZhciBuPXQuaWR8fHRbMF0uaWQscj10Lm1ldGhvZHx8dFswXS5tZXRob2Q7dGhpcy5yZXNwb25zZUNhbGxiYWNrc1tuXT1lLHRoaXMucmVzcG9uc2VDYWxsYmFja3Nbbl0ubWV0aG9kPXJ9LGkucHJvdG90eXBlLl90aW1lb3V0PWZ1bmN0aW9uKCl7Zm9yKHZhciB0IGluIHRoaXMucmVzcG9uc2VDYWxsYmFja3MpdGhpcy5yZXNwb25zZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eSh0KSYmKHRoaXMucmVzcG9uc2VDYWxsYmFja3NbdF0oby5JbnZhbGlkQ29ubmVjdGlvbigib24gSVBDIikpLGRlbGV0ZSB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW3RdKX0saS5wcm90b3R5cGUuaXNDb25uZWN0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlfHx0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCh7cGF0aDp0aGlzLnBhdGh9KSwhIXRoaXMuY29ubmVjdGlvbi53cml0YWJsZX0saS5wcm90b3R5cGUuc2VuZD1mdW5jdGlvbih0KXtpZih0aGlzLmNvbm5lY3Rpb24ud3JpdGVTeW5jKXt2YXIgZTt0aGlzLmNvbm5lY3Rpb24ud3JpdGFibGV8fHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KHtwYXRoOnRoaXMucGF0aH0pO3ZhciBuPXRoaXMuY29ubmVjdGlvbi53cml0ZVN5bmMoSlNPTi5zdHJpbmdpZnkodCkpO3RyeXtlPUpTT04ucGFyc2Uobil9Y2F0Y2godCl7dGhyb3cgby5JbnZhbGlkUmVzcG9uc2Uobil9cmV0dXJuIGV9dGhyb3cgbmV3IEVycm9yKCdZb3UgdHJpZWQgdG8gc2VuZCAiJyt0Lm1ldGhvZCsnIiBzeW5jaHJvbm91c2x5LiBTeW5jaHJvbm91cyByZXF1ZXN0cyBhcmUgbm90IHN1cHBvcnRlZCBieSB0aGUgSVBDIHByb3ZpZGVyLicpfSxpLnByb3RvdHlwZS5zZW5kQXN5bmM9ZnVuY3Rpb24odCxlKXt0aGlzLmNvbm5lY3Rpb24ud3JpdGFibGV8fHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KHtwYXRoOnRoaXMucGF0aH0pLHRoaXMuY29ubmVjdGlvbi53cml0ZShKU09OLnN0cmluZ2lmeSh0KSksdGhpcy5fYWRkUmVzcG9uc2VDYWxsYmFjayh0LGUpfSxlLmV4cG9ydHM9aX0seyIuLi91dGlscy91dGlscyI6MjAsIi4vZXJyb3JzIjoyNn1dLDM1OltmdW5jdGlvbih0LGUsbil7dmFyIHI9e21lc3NhZ2VJZDowfTtyLnRvUGF5bG9hZD1mdW5jdGlvbih0LGUpe3JldHVybiB0fHxjb25zb2xlLmVycm9yKCJqc29ucnBjIG1ldGhvZCBzaG91bGQgYmUgc3BlY2lmaWVkISIpLHIubWVzc2FnZUlkKysse2pzb25ycGM6IjIuMCIsaWQ6ci5tZXNzYWdlSWQsbWV0aG9kOnQscGFyYW1zOmV8fFtdfX0sci5pc1ZhbGlkUmVzcG9uc2U9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXtyZXR1cm4hIXQmJiF0LmVycm9yJiYiMi4wIj09PXQuanNvbnJwYyYmIm51bWJlciI9PXR5cGVvZiB0LmlkJiZ2b2lkIDAhPT10LnJlc3VsdH1yZXR1cm4gQXJyYXkuaXNBcnJheSh0KT90LmV2ZXJ5KGUpOmUodCl9LHIudG9CYXRjaFBheWxvYWQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQubWFwKGZ1bmN0aW9uKHQpe3JldHVybiByLnRvUGF5bG9hZCh0Lm1ldGhvZCx0LnBhcmFtcyl9KX0sZS5leHBvcnRzPXJ9LHt9XSwzNjpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL3V0aWxzL3V0aWxzIiksbz10KCIuL2Vycm9ycyIpLGk9ZnVuY3Rpb24odCl7dGhpcy5uYW1lPXQubmFtZSx0aGlzLmNhbGw9dC5jYWxsLHRoaXMucGFyYW1zPXQucGFyYW1zfHwwLHRoaXMuaW5wdXRGb3JtYXR0ZXI9dC5pbnB1dEZvcm1hdHRlcix0aGlzLm91dHB1dEZvcm1hdHRlcj10Lm91dHB1dEZvcm1hdHRlcix0aGlzLnJlcXVlc3RNYW5hZ2VyPW51bGx9O2kucHJvdG90eXBlLnNldFJlcXVlc3RNYW5hZ2VyPWZ1bmN0aW9uKHQpe3RoaXMucmVxdWVzdE1hbmFnZXI9dH0saS5wcm90b3R5cGUuZ2V0Q2FsbD1mdW5jdGlvbih0KXtyZXR1cm4gci5pc0Z1bmN0aW9uKHRoaXMuY2FsbCk/dGhpcy5jYWxsKHQpOnRoaXMuY2FsbH0saS5wcm90b3R5cGUuZXh0cmFjdENhbGxiYWNrPWZ1bmN0aW9uKHQpe2lmKHIuaXNGdW5jdGlvbih0W3QubGVuZ3RoLTFdKSlyZXR1cm4gdC5wb3AoKX0saS5wcm90b3R5cGUudmFsaWRhdGVBcmdzPWZ1bmN0aW9uKHQpe2lmKHQubGVuZ3RoIT09dGhpcy5wYXJhbXMpdGhyb3cgby5JbnZhbGlkTnVtYmVyT2ZSUENQYXJhbXMoKX0saS5wcm90b3R5cGUuZm9ybWF0SW5wdXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaW5wdXRGb3JtYXR0ZXI/dGhpcy5pbnB1dEZvcm1hdHRlci5tYXAoZnVuY3Rpb24oZSxuKXtyZXR1cm4gZT9lKHRbbl0pOnRbbl19KTp0fSxpLnByb3RvdHlwZS5mb3JtYXRPdXRwdXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMub3V0cHV0Rm9ybWF0dGVyJiZ0P3RoaXMub3V0cHV0Rm9ybWF0dGVyKHQpOnR9LGkucHJvdG90eXBlLnRvUGF5bG9hZD1mdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldENhbGwodCksbj10aGlzLmV4dHJhY3RDYWxsYmFjayh0KSxyPXRoaXMuZm9ybWF0SW5wdXQodCk7cmV0dXJuIHRoaXMudmFsaWRhdGVBcmdzKHIpLHttZXRob2Q6ZSxwYXJhbXM6cixjYWxsYmFjazpufX0saS5wcm90b3R5cGUuYXR0YWNoVG9PYmplY3Q9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5idWlsZENhbGwoKTtlLmNhbGw9dGhpcy5jYWxsO3ZhciBuPXRoaXMubmFtZS5zcGxpdCgiLiIpO24ubGVuZ3RoPjE/KHRbblswXV09dFtuWzBdXXx8e30sdFtuWzBdXVtuWzFdXT1lKTp0W25bMF1dPWV9LGkucHJvdG90eXBlLmJ1aWxkQ2FsbD1mdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1mdW5jdGlvbigpe3ZhciBlPXQudG9QYXlsb2FkKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO3JldHVybiBlLmNhbGxiYWNrP3QucmVxdWVzdE1hbmFnZXIuc2VuZEFzeW5jKGUsZnVuY3Rpb24obixyKXtlLmNhbGxiYWNrKG4sdC5mb3JtYXRPdXRwdXQocikpfSk6dC5mb3JtYXRPdXRwdXQodC5yZXF1ZXN0TWFuYWdlci5zZW5kKGUpKX07cmV0dXJuIGUucmVxdWVzdD10aGlzLnJlcXVlc3QuYmluZCh0aGlzKSxlfSxpLnByb3RvdHlwZS5yZXF1ZXN0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy50b1BheWxvYWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7cmV0dXJuIHQuZm9ybWF0PXRoaXMuZm9ybWF0T3V0cHV0LmJpbmQodGhpcyksdH0sZS5leHBvcnRzPWl9LHsiLi4vdXRpbHMvdXRpbHMiOjIwLCIuL2Vycm9ycyI6MjZ9XSwzNzpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uL21ldGhvZCIpLG89ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IHIoe25hbWU6InB1dFN0cmluZyIsY2FsbDoiZGJfcHV0U3RyaW5nIixwYXJhbXM6M30pLG5ldyByKHtuYW1lOiJnZXRTdHJpbmciLGNhbGw6ImRiX2dldFN0cmluZyIscGFyYW1zOjJ9KSxuZXcgcih7bmFtZToicHV0SGV4IixjYWxsOiJkYl9wdXRIZXgiLHBhcmFtczozfSksbmV3IHIoe25hbWU6ImdldEhleCIsY2FsbDoiZGJfZ2V0SGV4IixwYXJhbXM6Mn0pXX07ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPXQuX3JlcXVlc3RNYW5hZ2VyO3ZhciBlPXRoaXM7bygpLmZvckVhY2goZnVuY3Rpb24obil7bi5hdHRhY2hUb09iamVjdChlKSxuLnNldFJlcXVlc3RNYW5hZ2VyKHQuX3JlcXVlc3RNYW5hZ2VyKX0pfX0seyIuLi9tZXRob2QiOjM2fV0sMzg6W2Z1bmN0aW9uKHQsZSxuKXsidXNlIHN0cmljdCI7ZnVuY3Rpb24gcih0KXt0aGlzLl9yZXF1ZXN0TWFuYWdlcj10Ll9yZXF1ZXN0TWFuYWdlcjt2YXIgZT10aGlzO3coKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuYXR0YWNoVG9PYmplY3QoZSksdC5zZXRSZXF1ZXN0TWFuYWdlcihlLl9yZXF1ZXN0TWFuYWdlcil9KSx4KCkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmF0dGFjaFRvT2JqZWN0KGUpLHQuc2V0UmVxdWVzdE1hbmFnZXIoZS5fcmVxdWVzdE1hbmFnZXIpfSksdGhpcy5pYmFuPWQsdGhpcy5zZW5kSUJBTlRyYW5zYWN0aW9uPW0uYmluZChudWxsLHRoaXMpfXZhciBvPXQoIi4uL2Zvcm1hdHRlcnMiKSxpPXQoIi4uLy4uL3V0aWxzL3V0aWxzIiksYT10KCIuLi9tZXRob2QiKSxzPXQoIi4uL3Byb3BlcnR5IiksYz10KCIuLi8uLi91dGlscy9jb25maWciKSx1PXQoIi4uL2NvbnRyYWN0IiksZj10KCIuL3dhdGNoZXMiKSxsPXQoIi4uL2ZpbHRlciIpLHA9dCgiLi4vc3luY2luZyIpLGg9dCgiLi4vbmFtZXJlZyIpLGQ9dCgiLi4vaWJhbiIpLG09dCgiLi4vdHJhbnNmZXIiKSx5PWZ1bmN0aW9uKHQpe3JldHVybiBpLmlzU3RyaW5nKHRbMF0pJiYwPT09dFswXS5pbmRleE9mKCIweCIpPyJldGhfZ2V0QmxvY2tCeUhhc2giOiJldGhfZ2V0QmxvY2tCeU51bWJlciJ9LGc9ZnVuY3Rpb24odCl7cmV0dXJuIGkuaXNTdHJpbmcodFswXSkmJjA9PT10WzBdLmluZGV4T2YoIjB4Iik/ImV0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tIYXNoQW5kSW5kZXgiOiJldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrTnVtYmVyQW5kSW5kZXgifSx2PWZ1bmN0aW9uKHQpe3JldHVybiBpLmlzU3RyaW5nKHRbMF0pJiYwPT09dFswXS5pbmRleE9mKCIweCIpPyJldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4IjoiZXRoX2dldFVuY2xlQnlCbG9ja051bWJlckFuZEluZGV4In0sYj1mdW5jdGlvbih0KXtyZXR1cm4gaS5pc1N0cmluZyh0WzBdKSYmMD09PXRbMF0uaW5kZXhPZigiMHgiKT8iZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5SGFzaCI6ImV0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeU51bWJlciJ9LF89ZnVuY3Rpb24odCl7cmV0dXJuIGkuaXNTdHJpbmcodFswXSkmJjA9PT10WzBdLmluZGV4T2YoIjB4Iik/ImV0aF9nZXRVbmNsZUNvdW50QnlCbG9ja0hhc2giOiJldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXIifTtPYmplY3QuZGVmaW5lUHJvcGVydHkoci5wcm90b3R5cGUsImRlZmF1bHRCbG9jayIse2dldDpmdW5jdGlvbigpe3JldHVybiBjLmRlZmF1bHRCbG9ja30sc2V0OmZ1bmN0aW9uKHQpe3JldHVybiBjLmRlZmF1bHRCbG9jaz10LHR9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHIucHJvdG90eXBlLCJkZWZhdWx0QWNjb3VudCIse2dldDpmdW5jdGlvbigpe3JldHVybiBjLmRlZmF1bHRBY2NvdW50fSxzZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIGMuZGVmYXVsdEFjY291bnQ9dCx0fX0pO3ZhciB3PWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGEoe25hbWU6ImdldEJhbGFuY2UiLGNhbGw6ImV0aF9nZXRCYWxhbmNlIixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbby5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsby5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl0sb3V0cHV0Rm9ybWF0dGVyOm8ub3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyfSksZT1uZXcgYSh7bmFtZToiZ2V0U3RvcmFnZUF0IixjYWxsOiJldGhfZ2V0U3RvcmFnZUF0IixwYXJhbXM6MyxpbnB1dEZvcm1hdHRlcjpbbnVsbCxpLnRvSGV4LG8uaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdfSksbj1uZXcgYSh7bmFtZToiZ2V0Q29kZSIsY2FsbDoiZXRoX2dldENvZGUiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0QWRkcmVzc0Zvcm1hdHRlcixvLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXX0pLHI9bmV3IGEoe25hbWU6ImdldEJsb2NrIixjYWxsOnkscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcixmdW5jdGlvbih0KXtyZXR1cm4hIXR9XSxvdXRwdXRGb3JtYXR0ZXI6by5vdXRwdXRCbG9ja0Zvcm1hdHRlcn0pLHM9bmV3IGEoe25hbWU6ImdldFVuY2xlIixjYWxsOnYscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcixpLnRvSGV4XSxvdXRwdXRGb3JtYXR0ZXI6by5vdXRwdXRCbG9ja0Zvcm1hdHRlcn0pLGM9bmV3IGEoe25hbWU6ImdldENvbXBpbGVycyIsY2FsbDoiZXRoX2dldENvbXBpbGVycyIscGFyYW1zOjB9KSx1PW5ldyBhKHtuYW1lOiJnZXRCbG9ja1RyYW5zYWN0aW9uQ291bnQiLGNhbGw6YixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbby5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxvdXRwdXRGb3JtYXR0ZXI6aS50b0RlY2ltYWx9KSxmPW5ldyBhKHtuYW1lOiJnZXRCbG9ja1VuY2xlQ291bnQiLGNhbGw6XyxwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbby5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyXSxvdXRwdXRGb3JtYXR0ZXI6aS50b0RlY2ltYWx9KSxsPW5ldyBhKHtuYW1lOiJnZXRUcmFuc2FjdGlvbiIsY2FsbDoiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoIixwYXJhbXM6MSxvdXRwdXRGb3JtYXR0ZXI6by5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlcn0pLHA9bmV3IGEoe25hbWU6ImdldFRyYW5zYWN0aW9uRnJvbUJsb2NrIixjYWxsOmcscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcixpLnRvSGV4XSxvdXRwdXRGb3JtYXR0ZXI6by5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlcn0pLGg9bmV3IGEoe25hbWU6ImdldFRyYW5zYWN0aW9uUmVjZWlwdCIsY2FsbDoiZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCIscGFyYW1zOjEsb3V0cHV0Rm9ybWF0dGVyOm8ub3V0cHV0VHJhbnNhY3Rpb25SZWNlaXB0Rm9ybWF0dGVyfSksZD1uZXcgYSh7bmFtZToiZ2V0VHJhbnNhY3Rpb25Db3VudCIsY2FsbDoiZXRoX2dldFRyYW5zYWN0aW9uQ291bnQiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltudWxsLG8uaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLG91dHB1dEZvcm1hdHRlcjppLnRvRGVjaW1hbH0pLG09bmV3IGEoe25hbWU6InNlbmRSYXdUcmFuc2FjdGlvbiIsY2FsbDoiZXRoX3NlbmRSYXdUcmFuc2FjdGlvbiIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSksdz1uZXcgYSh7bmFtZToic2VuZFRyYW5zYWN0aW9uIixjYWxsOiJldGhfc2VuZFRyYW5zYWN0aW9uIixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbby5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXX0pLHg9bmV3IGEoe25hbWU6InNpZ25UcmFuc2FjdGlvbiIsY2FsbDoiZXRoX3NpZ25UcmFuc2FjdGlvbiIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcl19KSxrPW5ldyBhKHtuYW1lOiJzaWduIixjYWxsOiJldGhfc2lnbiIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRBZGRyZXNzRm9ybWF0dGVyLG51bGxdfSk7cmV0dXJuW3QsZSxuLHIscyxjLHUsZixsLHAsaCxkLG5ldyBhKHtuYW1lOiJjYWxsIixjYWxsOiJldGhfY2FsbCIscGFyYW1zOjIsaW5wdXRGb3JtYXR0ZXI6W28uaW5wdXRDYWxsRm9ybWF0dGVyLG8uaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdfSksbmV3IGEoe25hbWU6ImVzdGltYXRlR2FzIixjYWxsOiJldGhfZXN0aW1hdGVHYXMiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltvLmlucHV0Q2FsbEZvcm1hdHRlcl0sb3V0cHV0Rm9ybWF0dGVyOmkudG9EZWNpbWFsfSksbSx4LHcsayxuZXcgYSh7bmFtZToiY29tcGlsZS5zb2xpZGl0eSIsY2FsbDoiZXRoX2NvbXBpbGVTb2xpZGl0eSIscGFyYW1zOjF9KSxuZXcgYSh7bmFtZToiY29tcGlsZS5sbGwiLGNhbGw6ImV0aF9jb21waWxlTExMIixwYXJhbXM6MX0pLG5ldyBhKHtuYW1lOiJjb21waWxlLnNlcnBlbnQiLGNhbGw6ImV0aF9jb21waWxlU2VycGVudCIscGFyYW1zOjF9KSxuZXcgYSh7bmFtZToic3VibWl0V29yayIsY2FsbDoiZXRoX3N1Ym1pdFdvcmsiLHBhcmFtczozfSksbmV3IGEoe25hbWU6ImdldFdvcmsiLGNhbGw6ImV0aF9nZXRXb3JrIixwYXJhbXM6MH0pXX0seD1mdW5jdGlvbigpe3JldHVybltuZXcgcyh7bmFtZToiY29pbmJhc2UiLGdldHRlcjoiZXRoX2NvaW5iYXNlIn0pLG5ldyBzKHtuYW1lOiJtaW5pbmciLGdldHRlcjoiZXRoX21pbmluZyJ9KSxuZXcgcyh7bmFtZToiaGFzaHJhdGUiLGdldHRlcjoiZXRoX2hhc2hyYXRlIixvdXRwdXRGb3JtYXR0ZXI6aS50b0RlY2ltYWx9KSxuZXcgcyh7bmFtZToic3luY2luZyIsZ2V0dGVyOiJldGhfc3luY2luZyIsb3V0cHV0Rm9ybWF0dGVyOm8ub3V0cHV0U3luY2luZ0Zvcm1hdHRlcn0pLG5ldyBzKHtuYW1lOiJnYXNQcmljZSIsZ2V0dGVyOiJldGhfZ2FzUHJpY2UiLG91dHB1dEZvcm1hdHRlcjpvLm91dHB1dEJpZ051bWJlckZvcm1hdHRlcn0pLG5ldyBzKHtuYW1lOiJhY2NvdW50cyIsZ2V0dGVyOiJldGhfYWNjb3VudHMifSksbmV3IHMoe25hbWU6ImJsb2NrTnVtYmVyIixnZXR0ZXI6ImV0aF9ibG9ja051bWJlciIsb3V0cHV0Rm9ybWF0dGVyOmkudG9EZWNpbWFsfSksbmV3IHMoe25hbWU6InByb3RvY29sVmVyc2lvbiIsZ2V0dGVyOiJldGhfcHJvdG9jb2xWZXJzaW9uIn0pXX07ci5wcm90b3R5cGUuY29udHJhY3Q9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB1KHRoaXMsdCl9LHIucHJvdG90eXBlLmZpbHRlcj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIG5ldyBsKHQsImV0aCIsdGhpcy5fcmVxdWVzdE1hbmFnZXIsZi5ldGgoKSxvLm91dHB1dExvZ0Zvcm1hdHRlcixlLG4pfSxyLnByb3RvdHlwZS5uYW1lcmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udHJhY3QoaC5nbG9iYWwuYWJpKS5hdChoLmdsb2JhbC5hZGRyZXNzKX0sci5wcm90b3R5cGUuaWNhcE5hbWVyZWc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250cmFjdChoLmljYXAuYWJpKS5hdChoLmljYXAuYWRkcmVzcyl9LHIucHJvdG90eXBlLmlzU3luY2luZz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IHAodGhpcy5fcmVxdWVzdE1hbmFnZXIsdCl9LGUuZXhwb3J0cz1yfSx7Ii4uLy4uL3V0aWxzL2NvbmZpZyI6MTgsIi4uLy4uL3V0aWxzL3V0aWxzIjoyMCwiLi4vY29udHJhY3QiOjI1LCIuLi9maWx0ZXIiOjI5LCIuLi9mb3JtYXR0ZXJzIjozMCwiLi4vaWJhbiI6MzMsIi4uL21ldGhvZCI6MzYsIi4uL25hbWVyZWciOjQ0LCIuLi9wcm9wZXJ0eSI6NDUsIi4uL3N5bmNpbmciOjQ4LCIuLi90cmFuc2ZlciI6NDksIi4vd2F0Y2hlcyI6NDN9XSwzOTpbZnVuY3Rpb24odCxlLG4pe3ZhciByPXQoIi4uLy4uL3V0aWxzL3V0aWxzIiksbz10KCIuLi9wcm9wZXJ0eSIpLGk9ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IG8oe25hbWU6Imxpc3RlbmluZyIsZ2V0dGVyOiJuZXRfbGlzdGVuaW5nIn0pLG5ldyBvKHtuYW1lOiJwZWVyQ291bnQiLGdldHRlcjoibmV0X3BlZXJDb3VudCIsb3V0cHV0Rm9ybWF0dGVyOnIudG9EZWNpbWFsfSldfTtlLmV4cG9ydHM9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXI7dmFyIGU9dGhpcztpKCkuZm9yRWFjaChmdW5jdGlvbihuKXtuLmF0dGFjaFRvT2JqZWN0KGUpLG4uc2V0UmVxdWVzdE1hbmFnZXIodC5fcmVxdWVzdE1hbmFnZXIpfSl9fSx7Ii4uLy4uL3V0aWxzL3V0aWxzIjoyMCwiLi4vcHJvcGVydHkiOjQ1fV0sNDA6W2Z1bmN0aW9uKHQsZSxuKXsidXNlIHN0cmljdCI7dmFyIHI9dCgiLi4vbWV0aG9kIiksbz10KCIuLi9wcm9wZXJ0eSIpLGk9dCgiLi4vZm9ybWF0dGVycyIpLGE9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgcih7bmFtZToibmV3QWNjb3VudCIsY2FsbDoicGVyc29uYWxfbmV3QWNjb3VudCIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSksZT1uZXcgcih7bmFtZToiaW1wb3J0UmF3S2V5IixjYWxsOiJwZXJzb25hbF9pbXBvcnRSYXdLZXkiLHBhcmFtczoyfSksbj1uZXcgcih7bmFtZToic2lnbiIsY2FsbDoicGVyc29uYWxfc2lnbiIscGFyYW1zOjMsaW5wdXRGb3JtYXR0ZXI6W251bGwsaS5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsbnVsbF19KSxvPW5ldyByKHtuYW1lOiJlY1JlY292ZXIiLGNhbGw6InBlcnNvbmFsX2VjUmVjb3ZlciIscGFyYW1zOjJ9KTtyZXR1cm5bdCxlLG5ldyByKHtuYW1lOiJ1bmxvY2tBY2NvdW50IixjYWxsOiJwZXJzb25hbF91bmxvY2tBY2NvdW50IixwYXJhbXM6MyxpbnB1dEZvcm1hdHRlcjpbaS5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsbnVsbCxudWxsXX0pLG8sbixuZXcgcih7bmFtZToic2VuZFRyYW5zYWN0aW9uIixjYWxsOiJwZXJzb25hbF9zZW5kVHJhbnNhY3Rpb24iLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltpLmlucHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIsbnVsbF19KSxuZXcgcih7bmFtZToibG9ja0FjY291bnQiLGNhbGw6InBlcnNvbmFsX2xvY2tBY2NvdW50IixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbaS5pbnB1dEFkZHJlc3NGb3JtYXR0ZXJdfSldfSxzPWZ1bmN0aW9uKCl7cmV0dXJuW25ldyBvKHtuYW1lOiJsaXN0QWNjb3VudHMiLGdldHRlcjoicGVyc29uYWxfbGlzdEFjY291bnRzIn0pXX07ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPXQuX3JlcXVlc3RNYW5hZ2VyO3ZhciBlPXRoaXM7YSgpLmZvckVhY2goZnVuY3Rpb24odCl7dC5hdHRhY2hUb09iamVjdChlKSx0LnNldFJlcXVlc3RNYW5hZ2VyKGUuX3JlcXVlc3RNYW5hZ2VyKX0pLHMoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuYXR0YWNoVG9PYmplY3QoZSksdC5zZXRSZXF1ZXN0TWFuYWdlcihlLl9yZXF1ZXN0TWFuYWdlcil9KX19LHsiLi4vZm9ybWF0dGVycyI6MzAsIi4uL21ldGhvZCI6MzYsIi4uL3Byb3BlcnR5Ijo0NX1dLDQxOltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi4vbWV0aG9kIiksbz10KCIuLi9maWx0ZXIiKSxpPXQoIi4vd2F0Y2hlcyIpLGE9ZnVuY3Rpb24odCl7dGhpcy5fcmVxdWVzdE1hbmFnZXI9dC5fcmVxdWVzdE1hbmFnZXI7dmFyIGU9dGhpcztzKCkuZm9yRWFjaChmdW5jdGlvbih0KXt0LmF0dGFjaFRvT2JqZWN0KGUpLHQuc2V0UmVxdWVzdE1hbmFnZXIoZS5fcmVxdWVzdE1hbmFnZXIpfSl9O2EucHJvdG90eXBlLm5ld01lc3NhZ2VGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBuZXcgbyh0LCJzaGgiLHRoaXMuX3JlcXVlc3RNYW5hZ2VyLGkuc2hoKCksbnVsbCxlLG4pfTt2YXIgcz1mdW5jdGlvbigpe3JldHVybltuZXcgcih7bmFtZToidmVyc2lvbiIsY2FsbDoic2hoX3ZlcnNpb24iLHBhcmFtczowfSksbmV3IHIoe25hbWU6ImluZm8iLGNhbGw6InNoaF9pbmZvIixwYXJhbXM6MH0pLG5ldyByKHtuYW1lOiJzZXRNYXhNZXNzYWdlU2l6ZSIsY2FsbDoic2hoX3NldE1heE1lc3NhZ2VTaXplIixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJzZXRNaW5Qb1ciLGNhbGw6InNoaF9zZXRNaW5Qb1ciLHBhcmFtczoxfSksbmV3IHIoe25hbWU6Im1hcmtUcnVzdGVkUGVlciIsY2FsbDoic2hoX21hcmtUcnVzdGVkUGVlciIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToibmV3S2V5UGFpciIsY2FsbDoic2hoX25ld0tleVBhaXIiLHBhcmFtczowfSksbmV3IHIoe25hbWU6ImFkZFByaXZhdGVLZXkiLGNhbGw6InNoaF9hZGRQcml2YXRlS2V5IixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJkZWxldGVLZXlQYWlyIixjYWxsOiJzaGhfZGVsZXRlS2V5UGFpciIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToiaGFzS2V5UGFpciIsY2FsbDoic2hoX2hhc0tleVBhaXIiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6ImdldFB1YmxpY0tleSIsY2FsbDoic2hoX2dldFB1YmxpY0tleSIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToiZ2V0UHJpdmF0ZUtleSIsY2FsbDoic2hoX2dldFByaXZhdGVLZXkiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6Im5ld1N5bUtleSIsY2FsbDoic2hoX25ld1N5bUtleSIscGFyYW1zOjB9KSxuZXcgcih7bmFtZToiYWRkU3ltS2V5IixjYWxsOiJzaGhfYWRkU3ltS2V5IixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJnZW5lcmF0ZVN5bUtleUZyb21QYXNzd29yZCIsY2FsbDoic2hoX2dlbmVyYXRlU3ltS2V5RnJvbVBhc3N3b3JkIixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJoYXNTeW1LZXkiLGNhbGw6InNoaF9oYXNTeW1LZXkiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6ImdldFN5bUtleSIsY2FsbDoic2hoX2dldFN5bUtleSIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToiZGVsZXRlU3ltS2V5IixjYWxsOiJzaGhfZGVsZXRlU3ltS2V5IixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJwb3N0IixjYWxsOiJzaGhfcG9zdCIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSldfTtlLmV4cG9ydHM9YX0seyIuLi9maWx0ZXIiOjI5LCIuLi9tZXRob2QiOjM2LCIuL3dhdGNoZXMiOjQzfV0sNDI6W2Z1bmN0aW9uKHQsZSxuKXsidXNlIHN0cmljdCI7dmFyIHI9dCgiLi4vbWV0aG9kIiksbz10KCIuLi9wcm9wZXJ0eSIpLGk9ZnVuY3Rpb24oKXtyZXR1cm5bbmV3IHIoe25hbWU6ImJsb2NrTmV0d29ya1JlYWQiLGNhbGw6ImJ6el9ibG9ja05ldHdvcmtSZWFkIixwYXJhbXM6MSxpbnB1dEZvcm1hdHRlcjpbbnVsbF19KSxuZXcgcih7bmFtZToic3luY0VuYWJsZWQiLGNhbGw6ImJ6el9zeW5jRW5hYmxlZCIscGFyYW1zOjEsaW5wdXRGb3JtYXR0ZXI6W251bGxdfSksbmV3IHIoe25hbWU6InN3YXBFbmFibGVkIixjYWxsOiJienpfc3dhcEVuYWJsZWQiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltudWxsXX0pLG5ldyByKHtuYW1lOiJkb3dubG9hZCIsY2FsbDoiYnp6X2Rvd25sb2FkIixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbbnVsbCxudWxsXX0pLG5ldyByKHtuYW1lOiJ1cGxvYWQiLGNhbGw6ImJ6el91cGxvYWQiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltudWxsLG51bGxdfSksbmV3IHIoe25hbWU6InJldHJpZXZlIixjYWxsOiJienpfcmV0cmlldmUiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltudWxsXX0pLG5ldyByKHtuYW1lOiJzdG9yZSIsY2FsbDoiYnp6X3N0b3JlIixwYXJhbXM6MixpbnB1dEZvcm1hdHRlcjpbbnVsbCxudWxsXX0pLG5ldyByKHtuYW1lOiJnZXQiLGNhbGw6ImJ6el9nZXQiLHBhcmFtczoxLGlucHV0Rm9ybWF0dGVyOltudWxsXX0pLG5ldyByKHtuYW1lOiJwdXQiLGNhbGw6ImJ6el9wdXQiLHBhcmFtczoyLGlucHV0Rm9ybWF0dGVyOltudWxsLG51bGxdfSksbmV3IHIoe25hbWU6Im1vZGlmeSIsY2FsbDoiYnp6X21vZGlmeSIscGFyYW1zOjQsaW5wdXRGb3JtYXR0ZXI6W251bGwsbnVsbCxudWxsLG51bGxdfSldfSxhPWZ1bmN0aW9uKCl7cmV0dXJuW25ldyBvKHtuYW1lOiJoaXZlIixnZXR0ZXI6ImJ6el9oaXZlIn0pLG5ldyBvKHtuYW1lOiJpbmZvIixnZXR0ZXI6ImJ6el9pbmZvIn0pXX07ZS5leHBvcnRzPWZ1bmN0aW9uKHQpe3RoaXMuX3JlcXVlc3RNYW5hZ2VyPXQuX3JlcXVlc3RNYW5hZ2VyO3ZhciBlPXRoaXM7aSgpLmZvckVhY2goZnVuY3Rpb24odCl7dC5hdHRhY2hUb09iamVjdChlKSx0LnNldFJlcXVlc3RNYW5hZ2VyKGUuX3JlcXVlc3RNYW5hZ2VyKX0pLGEoKS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuYXR0YWNoVG9PYmplY3QoZSksdC5zZXRSZXF1ZXN0TWFuYWdlcihlLl9yZXF1ZXN0TWFuYWdlcil9KX19LHsiLi4vbWV0aG9kIjozNiwiLi4vcHJvcGVydHkiOjQ1fV0sNDM6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuLi9tZXRob2QiKTtlLmV4cG9ydHM9e2V0aDpmdW5jdGlvbigpe3JldHVybltuZXcgcih7bmFtZToibmV3RmlsdGVyIixjYWxsOmZ1bmN0aW9uKHQpe3N3aXRjaCh0WzBdKXtjYXNlImxhdGVzdCI6cmV0dXJuIHQuc2hpZnQoKSx0aGlzLnBhcmFtcz0wLCJldGhfbmV3QmxvY2tGaWx0ZXIiO2Nhc2UicGVuZGluZyI6cmV0dXJuIHQuc2hpZnQoKSx0aGlzLnBhcmFtcz0wLCJldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyIjtkZWZhdWx0OnJldHVybiJldGhfbmV3RmlsdGVyIn19LHBhcmFtczoxfSksbmV3IHIoe25hbWU6InVuaW5zdGFsbEZpbHRlciIsY2FsbDoiZXRoX3VuaW5zdGFsbEZpbHRlciIscGFyYW1zOjF9KSxuZXcgcih7bmFtZToiZ2V0TG9ncyIsY2FsbDoiZXRoX2dldEZpbHRlckxvZ3MiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6InBvbGwiLGNhbGw6ImV0aF9nZXRGaWx0ZXJDaGFuZ2VzIixwYXJhbXM6MX0pXX0sc2hoOmZ1bmN0aW9uKCl7cmV0dXJuW25ldyByKHtuYW1lOiJuZXdGaWx0ZXIiLGNhbGw6InNoaF9uZXdNZXNzYWdlRmlsdGVyIixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJ1bmluc3RhbGxGaWx0ZXIiLGNhbGw6InNoaF9kZWxldGVNZXNzYWdlRmlsdGVyIixwYXJhbXM6MX0pLG5ldyByKHtuYW1lOiJnZXRMb2dzIixjYWxsOiJzaGhfZ2V0RmlsdGVyTWVzc2FnZXMiLHBhcmFtczoxfSksbmV3IHIoe25hbWU6InBvbGwiLGNhbGw6InNoaF9nZXRGaWx0ZXJNZXNzYWdlcyIscGFyYW1zOjF9KV19fX0seyIuLi9tZXRob2QiOjM2fV0sNDQ6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuLi9jb250cmFjdHMvR2xvYmFsUmVnaXN0cmFyLmpzb24iKSxvPXQoIi4uL2NvbnRyYWN0cy9JQ0FQUmVnaXN0cmFyLmpzb24iKTtlLmV4cG9ydHM9e2dsb2JhbDp7YWJpOnIsYWRkcmVzczoiMHhjNmQ5ZDJjZDQ0OWE3NTRjNDk0MjY0ZTE4MDljNTBlMzRkNjQ1NjJiIn0saWNhcDp7YWJpOm8sYWRkcmVzczoiMHhhMWExMTFiYzA3NGM5Y2ZhNzgxZjBjMzhlNjNiZDUxYzkxYjhhZjAwIn19fSx7Ii4uL2NvbnRyYWN0cy9HbG9iYWxSZWdpc3RyYXIuanNvbiI6MSwiLi4vY29udHJhY3RzL0lDQVBSZWdpc3RyYXIuanNvbiI6Mn1dLDQ1OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi4vdXRpbHMvdXRpbHMiKSxvPWZ1bmN0aW9uKHQpe3RoaXMubmFtZT10Lm5hbWUsdGhpcy5nZXR0ZXI9dC5nZXR0ZXIsdGhpcy5zZXR0ZXI9dC5zZXR0ZXIsdGhpcy5vdXRwdXRGb3JtYXR0ZXI9dC5vdXRwdXRGb3JtYXR0ZXIsdGhpcy5pbnB1dEZvcm1hdHRlcj10LmlucHV0Rm9ybWF0dGVyLHRoaXMucmVxdWVzdE1hbmFnZXI9bnVsbH07by5wcm90b3R5cGUuc2V0UmVxdWVzdE1hbmFnZXI9ZnVuY3Rpb24odCl7dGhpcy5yZXF1ZXN0TWFuYWdlcj10fSxvLnByb3RvdHlwZS5mb3JtYXRJbnB1dD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pbnB1dEZvcm1hdHRlcj90aGlzLmlucHV0Rm9ybWF0dGVyKHQpOnR9LG8ucHJvdG90eXBlLmZvcm1hdE91dHB1dD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5vdXRwdXRGb3JtYXR0ZXImJm51bGwhPT10JiZ2b2lkIDAhPT10P3RoaXMub3V0cHV0Rm9ybWF0dGVyKHQpOnR9LG8ucHJvdG90eXBlLmV4dHJhY3RDYWxsYmFjaz1mdW5jdGlvbih0KXtpZihyLmlzRnVuY3Rpb24odFt0Lmxlbmd0aC0xXSkpcmV0dXJuIHQucG9wKCl9LG8ucHJvdG90eXBlLmF0dGFjaFRvT2JqZWN0PWZ1bmN0aW9uKHQpe3ZhciBlPXtnZXQ6dGhpcy5idWlsZEdldCgpLGVudW1lcmFibGU6ITB9LG49dGhpcy5uYW1lLnNwbGl0KCIuIikscj1uWzBdO24ubGVuZ3RoPjEmJih0W25bMF1dPXRbblswXV18fHt9LHQ9dFtuWzBdXSxyPW5bMV0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIsZSksdFtpKHIpXT10aGlzLmJ1aWxkQXN5bmNHZXQoKX07dmFyIGk9ZnVuY3Rpb24odCl7cmV0dXJuImdldCIrdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSt0LnNsaWNlKDEpfTtvLnByb3RvdHlwZS5idWlsZEdldD1mdW5jdGlvbigpe3ZhciB0PXRoaXM7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHQuZm9ybWF0T3V0cHV0KHQucmVxdWVzdE1hbmFnZXIuc2VuZCh7bWV0aG9kOnQuZ2V0dGVyfSkpfX0sby5wcm90b3R5cGUuYnVpbGRBc3luY0dldD1mdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1mdW5jdGlvbihlKXt0LnJlcXVlc3RNYW5hZ2VyLnNlbmRBc3luYyh7bWV0aG9kOnQuZ2V0dGVyfSxmdW5jdGlvbihuLHIpe2Uobix0LmZvcm1hdE91dHB1dChyKSl9KX07cmV0dXJuIGUucmVxdWVzdD10aGlzLnJlcXVlc3QuYmluZCh0aGlzKSxlfSxvLnByb3RvdHlwZS5yZXF1ZXN0PWZ1bmN0aW9uKCl7dmFyIHQ9e21ldGhvZDp0aGlzLmdldHRlcixwYXJhbXM6W10sY2FsbGJhY2s6dGhpcy5leHRyYWN0Q2FsbGJhY2soQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSl9O3JldHVybiB0LmZvcm1hdD10aGlzLmZvcm1hdE91dHB1dC5iaW5kKHRoaXMpLHR9LGUuZXhwb3J0cz1vfSx7Ii4uL3V0aWxzL3V0aWxzIjoyMH1dLDQ2OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9qc29ucnBjIiksbz10KCIuLi91dGlscy91dGlscyIpLGk9dCgiLi4vdXRpbHMvY29uZmlnIiksYT10KCIuL2Vycm9ycyIpLHM9ZnVuY3Rpb24odCl7dGhpcy5wcm92aWRlcj10LHRoaXMucG9sbHM9e30sdGhpcy50aW1lb3V0PW51bGx9O3MucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24odCl7aWYoIXRoaXMucHJvdmlkZXIpcmV0dXJuIGNvbnNvbGUuZXJyb3IoYS5JbnZhbGlkUHJvdmlkZXIoKSksbnVsbDt2YXIgZT1yLnRvUGF5bG9hZCh0Lm1ldGhvZCx0LnBhcmFtcyksbj10aGlzLnByb3ZpZGVyLnNlbmQoZSk7aWYoIXIuaXNWYWxpZFJlc3BvbnNlKG4pKXRocm93IGEuSW52YWxpZFJlc3BvbnNlKG4pO3JldHVybiBuLnJlc3VsdH0scy5wcm90b3R5cGUuc2VuZEFzeW5jPWZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMucHJvdmlkZXIpcmV0dXJuIGUoYS5JbnZhbGlkUHJvdmlkZXIoKSk7dmFyIG49ci50b1BheWxvYWQodC5tZXRob2QsdC5wYXJhbXMpO3RoaXMucHJvdmlkZXIuc2VuZEFzeW5jKG4sZnVuY3Rpb24odCxuKXtyZXR1cm4gdD9lKHQpOnIuaXNWYWxpZFJlc3BvbnNlKG4pP3ZvaWQgZShudWxsLG4ucmVzdWx0KTplKGEuSW52YWxpZFJlc3BvbnNlKG4pKX0pfSxzLnByb3RvdHlwZS5zZW5kQmF0Y2g9ZnVuY3Rpb24odCxlKXtpZighdGhpcy5wcm92aWRlcilyZXR1cm4gZShhLkludmFsaWRQcm92aWRlcigpKTt2YXIgbj1yLnRvQmF0Y2hQYXlsb2FkKHQpO3RoaXMucHJvdmlkZXIuc2VuZEFzeW5jKG4sZnVuY3Rpb24odCxuKXtyZXR1cm4gdD9lKHQpOm8uaXNBcnJheShuKT92b2lkIGUodCxuKTplKGEuSW52YWxpZFJlc3BvbnNlKG4pKX0pfSxzLnByb3RvdHlwZS5zZXRQcm92aWRlcj1mdW5jdGlvbih0KXt0aGlzLnByb3ZpZGVyPXR9LHMucHJvdG90eXBlLnN0YXJ0UG9sbGluZz1mdW5jdGlvbih0LGUsbixyKXt0aGlzLnBvbGxzW2VdPXtkYXRhOnQsaWQ6ZSxjYWxsYmFjazpuLHVuaW5zdGFsbDpyfSx0aGlzLnRpbWVvdXR8fHRoaXMucG9sbCgpfSxzLnByb3RvdHlwZS5zdG9wUG9sbGluZz1mdW5jdGlvbih0KXtkZWxldGUgdGhpcy5wb2xsc1t0XSwwPT09T2JqZWN0LmtleXModGhpcy5wb2xscykubGVuZ3RoJiZ0aGlzLnRpbWVvdXQmJihjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KSx0aGlzLnRpbWVvdXQ9bnVsbCl9LHMucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZSBpbiB0aGlzLnBvbGxzKXQmJi0xIT09ZS5pbmRleE9mKCJzeW5jUG9sbF8iKXx8KHRoaXMucG9sbHNbZV0udW5pbnN0YWxsKCksZGVsZXRlIHRoaXMucG9sbHNbZV0pOzA9PT1PYmplY3Qua2V5cyh0aGlzLnBvbGxzKS5sZW5ndGgmJnRoaXMudGltZW91dCYmKGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpLHRoaXMudGltZW91dD1udWxsKX0scy5wcm90b3R5cGUucG9sbD1mdW5jdGlvbigpe2lmKHRoaXMudGltZW91dD1zZXRUaW1lb3V0KHRoaXMucG9sbC5iaW5kKHRoaXMpLGkuRVRIX1BPTExJTkdfVElNRU9VVCksMCE9PU9iamVjdC5rZXlzKHRoaXMucG9sbHMpLmxlbmd0aClpZih0aGlzLnByb3ZpZGVyKXt2YXIgdD1bXSxlPVtdO2Zvcih2YXIgbiBpbiB0aGlzLnBvbGxzKXQucHVzaCh0aGlzLnBvbGxzW25dLmRhdGEpLGUucHVzaChuKTtpZigwIT09dC5sZW5ndGgpe3ZhciBzPXIudG9CYXRjaFBheWxvYWQodCksYz17fTtzLmZvckVhY2goZnVuY3Rpb24odCxuKXtjW3QuaWRdPWVbbl19KTt2YXIgdT10aGlzO3RoaXMucHJvdmlkZXIuc2VuZEFzeW5jKHMsZnVuY3Rpb24odCxlKXtpZighdCl7aWYoIW8uaXNBcnJheShlKSl0aHJvdyBhLkludmFsaWRSZXNwb25zZShlKTtlLm1hcChmdW5jdGlvbih0KXt2YXIgZT1jW3QuaWRdO3JldHVybiEhdS5wb2xsc1tlXSYmKHQuY2FsbGJhY2s9dS5wb2xsc1tlXS5jYWxsYmFjayx0KX0pLmZpbHRlcihmdW5jdGlvbih0KXtyZXR1cm4hIXR9KS5maWx0ZXIoZnVuY3Rpb24odCl7dmFyIGU9ci5pc1ZhbGlkUmVzcG9uc2UodCk7cmV0dXJuIGV8fHQuY2FsbGJhY2soYS5JbnZhbGlkUmVzcG9uc2UodCkpLGV9KS5mb3JFYWNoKGZ1bmN0aW9uKHQpe3QuY2FsbGJhY2sobnVsbCx0LnJlc3VsdCl9KX19KX19ZWxzZSBjb25zb2xlLmVycm9yKGEuSW52YWxpZFByb3ZpZGVyKCkpfSxlLmV4cG9ydHM9c30seyIuLi91dGlscy9jb25maWciOjE4LCIuLi91dGlscy91dGlscyI6MjAsIi4vZXJyb3JzIjoyNiwiLi9qc29ucnBjIjozNX1dLDQ3OltmdW5jdGlvbih0LGUsbil7ZS5leHBvcnRzPWZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0QmxvY2s9ImxhdGVzdCIsdGhpcy5kZWZhdWx0QWNjb3VudD12b2lkIDB9fSx7fV0sNDg6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2Zvcm1hdHRlcnMiKSxvPXQoIi4uL3V0aWxzL3V0aWxzIiksaT0xLGE9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5yZXF1ZXN0TWFuYWdlcj10LHRoaXMucG9sbElkPSJzeW5jUG9sbF8iK2krKyx0aGlzLmNhbGxiYWNrcz1bXSx0aGlzLmFkZENhbGxiYWNrKGUpLHRoaXMubGFzdFN5bmNTdGF0ZT0hMSxmdW5jdGlvbih0KXt0LnJlcXVlc3RNYW5hZ2VyLnN0YXJ0UG9sbGluZyh7bWV0aG9kOiJldGhfc3luY2luZyIscGFyYW1zOltdfSx0LnBvbGxJZCxmdW5jdGlvbihlLG4pe2lmKGUpcmV0dXJuIHQuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24odCl7dChlKX0pO28uaXNPYmplY3QobikmJm4uc3RhcnRpbmdCbG9jayYmKG49ci5vdXRwdXRTeW5jaW5nRm9ybWF0dGVyKG4pKSx0LmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QubGFzdFN5bmNTdGF0ZSE9PW4mJighdC5sYXN0U3luY1N0YXRlJiZvLmlzT2JqZWN0KG4pJiZlKG51bGwsITApLHNldFRpbWVvdXQoZnVuY3Rpb24oKXtlKG51bGwsbil9LDApLHQubGFzdFN5bmNTdGF0ZT1uKX0pfSx0LnN0b3BXYXRjaGluZy5iaW5kKHQpKX0odGhpcyksdGhpc307YS5wcm90b3R5cGUuYWRkQ2FsbGJhY2s9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnRoaXMuY2FsbGJhY2tzLnB1c2godCksdGhpc30sYS5wcm90b3R5cGUuc3RvcFdhdGNoaW5nPWZ1bmN0aW9uKCl7dGhpcy5yZXF1ZXN0TWFuYWdlci5zdG9wUG9sbGluZyh0aGlzLnBvbGxJZCksdGhpcy5jYWxsYmFja3M9W119LGUuZXhwb3J0cz1hfSx7Ii4uL3V0aWxzL3V0aWxzIjoyMCwiLi9mb3JtYXR0ZXJzIjozMH1dLDQ5OltmdW5jdGlvbih0LGUsbil7dmFyIHI9dCgiLi9pYmFuIiksbz10KCIuLi9jb250cmFjdHMvU21hcnRFeGNoYW5nZS5qc29uIiksaT1mdW5jdGlvbih0LGUsbixyLG8pe3JldHVybiB0LnNlbmRUcmFuc2FjdGlvbih7YWRkcmVzczpuLGZyb206ZSx2YWx1ZTpyfSxvKX0sYT1mdW5jdGlvbih0LGUsbixyLGksYSl7dmFyIHM9bztyZXR1cm4gdC5jb250cmFjdChzKS5hdChuKS5kZXBvc2l0KGkse2Zyb206ZSx2YWx1ZTpyfSxhKX07ZS5leHBvcnRzPWZ1bmN0aW9uKHQsZSxuLG8scyl7dmFyIGM9bmV3IHIobik7aWYoIWMuaXNWYWxpZCgpKXRocm93IG5ldyBFcnJvcigiaW52YWxpZCBpYmFuIGFkZHJlc3MiKTtpZihjLmlzRGlyZWN0KCkpcmV0dXJuIGkodCxlLGMuYWRkcmVzcygpLG8scyk7aWYoIXMpe3ZhciB1PXQuaWNhcE5hbWVyZWcoKS5hZGRyKGMuaW5zdGl0dXRpb24oKSk7cmV0dXJuIGEodCxlLHUsbyxjLmNsaWVudCgpKX10LmljYXBOYW1lcmVnKCkuYWRkcihjLmluc3RpdHV0aW9uKCksZnVuY3Rpb24obixyKXtyZXR1cm4gYSh0LGUscixvLGMuY2xpZW50KCkscyl9KX19LHsiLi4vY29udHJhY3RzL1NtYXJ0RXhjaGFuZ2UuanNvbiI6MywiLi9pYmFuIjozM31dLDUwOltmdW5jdGlvbih0LGUsbil7fSx7fV0sNTE6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vZW5jLWJhc2U2NCIpLHQoIi4vbWQ1IiksdCgiLi9ldnBrZGYiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9lbmMtYmFzZTY0IiwiLi9tZDUiLCIuL2V2cGtkZiIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQsbj1lLmxpYi5CbG9ja0NpcGhlcixyPWUuYWxnbyxvPVtdLGk9W10sYT1bXSxzPVtdLGM9W10sdT1bXSxmPVtdLGw9W10scD1bXSxoPVtdOyFmdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTA7ZTwyNTY7ZSsrKXRbZV09ZTwxMjg/ZTw8MTplPDwxXjI4Mzt2YXIgbj0wLHI9MDtmb3IoZT0wO2U8MjU2O2UrKyl7dmFyIGQ9cl5yPDwxXnI8PDJecjw8M15yPDw0O2Q9ZD4+PjheMjU1JmReOTksb1tuXT1kLGlbZF09bjt2YXIgbT10W25dLHk9dFttXSxnPXRbeV0sdj0yNTcqdFtkXV4xNjg0MzAwOCpkO2Fbbl09djw8MjR8dj4+Pjgsc1tuXT12PDwxNnx2Pj4+MTYsY1tuXT12PDw4fHY+Pj4yNCx1W25dPXY7dj0xNjg0MzAwOSpnXjY1NTM3KnleMjU3Km1eMTY4NDMwMDgqbjtmW2RdPXY8PDI0fHY+Pj44LGxbZF09djw8MTZ8dj4+PjE2LHBbZF09djw8OHx2Pj4+MjQsaFtkXT12LG4/KG49bV50W3RbdFtnXm1dXV0scl49dFt0W3JdXSk6bj1yPTF9fSgpO3ZhciBkPVswLDEsMiw0LDgsMTYsMzIsNjQsMTI4LDI3LDU0XSxtPXIuQUVTPW4uZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe2lmKCF0aGlzLl9uUm91bmRzfHx0aGlzLl9rZXlQcmlvclJlc2V0IT09dGhpcy5fa2V5KXtmb3IodmFyIHQ9dGhpcy5fa2V5UHJpb3JSZXNldD10aGlzLl9rZXksZT10LndvcmRzLG49dC5zaWdCeXRlcy80LHI9NCooKHRoaXMuX25Sb3VuZHM9bis2KSsxKSxpPXRoaXMuX2tleVNjaGVkdWxlPVtdLGE9MDthPHI7YSsrKWlmKGE8bilpW2FdPWVbYV07ZWxzZXt2YXIgcz1pW2EtMV07YSVuP24+NiYmYSVuPT00JiYocz1vW3M+Pj4yNF08PDI0fG9bcz4+PjE2JjI1NV08PDE2fG9bcz4+PjgmMjU1XTw8OHxvWzI1NSZzXSk6KHM9b1socz1zPDw4fHM+Pj4yNCk+Pj4yNF08PDI0fG9bcz4+PjE2JjI1NV08PDE2fG9bcz4+PjgmMjU1XTw8OHxvWzI1NSZzXSxzXj1kW2EvbnwwXTw8MjQpLGlbYV09aVthLW5dXnN9Zm9yKHZhciBjPXRoaXMuX2ludktleVNjaGVkdWxlPVtdLHU9MDt1PHI7dSsrKXthPXItdTtpZih1JTQpcz1pW2FdO2Vsc2Ugcz1pW2EtNF07Y1t1XT11PDR8fGE8PTQ/czpmW29bcz4+PjI0XV1ebFtvW3M+Pj4xNiYyNTVdXV5wW29bcz4+PjgmMjU1XV1eaFtvWzI1NSZzXV19fX0sZW5jcnlwdEJsb2NrOmZ1bmN0aW9uKHQsZSl7dGhpcy5fZG9DcnlwdEJsb2NrKHQsZSx0aGlzLl9rZXlTY2hlZHVsZSxhLHMsYyx1LG8pfSxkZWNyeXB0QmxvY2s6ZnVuY3Rpb24odCxlKXt2YXIgbj10W2UrMV07dFtlKzFdPXRbZSszXSx0W2UrM109bix0aGlzLl9kb0NyeXB0QmxvY2sodCxlLHRoaXMuX2ludktleVNjaGVkdWxlLGYsbCxwLGgsaSk7bj10W2UrMV07dFtlKzFdPXRbZSszXSx0W2UrM109bn0sX2RvQ3J5cHRCbG9jazpmdW5jdGlvbih0LGUsbixyLG8saSxhLHMpe2Zvcih2YXIgYz10aGlzLl9uUm91bmRzLHU9dFtlXV5uWzBdLGY9dFtlKzFdXm5bMV0sbD10W2UrMl1eblsyXSxwPXRbZSszXV5uWzNdLGg9NCxkPTE7ZDxjO2QrKyl7dmFyIG09clt1Pj4+MjRdXm9bZj4+PjE2JjI1NV1eaVtsPj4+OCYyNTVdXmFbMjU1JnBdXm5baCsrXSx5PXJbZj4+PjI0XV5vW2w+Pj4xNiYyNTVdXmlbcD4+PjgmMjU1XV5hWzI1NSZ1XV5uW2grK10sZz1yW2w+Pj4yNF1eb1twPj4+MTYmMjU1XV5pW3U+Pj44JjI1NV1eYVsyNTUmZl1ebltoKytdLHY9cltwPj4+MjRdXm9bdT4+PjE2JjI1NV1eaVtmPj4+OCYyNTVdXmFbMjU1JmxdXm5baCsrXTt1PW0sZj15LGw9ZyxwPXZ9bT0oc1t1Pj4+MjRdPDwyNHxzW2Y+Pj4xNiYyNTVdPDwxNnxzW2w+Pj44JjI1NV08PDh8c1syNTUmcF0pXm5baCsrXSx5PShzW2Y+Pj4yNF08PDI0fHNbbD4+PjE2JjI1NV08PDE2fHNbcD4+PjgmMjU1XTw8OHxzWzI1NSZ1XSlebltoKytdLGc9KHNbbD4+PjI0XTw8MjR8c1twPj4+MTYmMjU1XTw8MTZ8c1t1Pj4+OCYyNTVdPDw4fHNbMjU1JmZdKV5uW2grK10sdj0oc1twPj4+MjRdPDwyNHxzW3U+Pj4xNiYyNTVdPDwxNnxzW2Y+Pj44JjI1NV08PDh8c1syNTUmbF0pXm5baCsrXTt0W2VdPW0sdFtlKzFdPXksdFtlKzJdPWcsdFtlKzNdPXZ9LGtleVNpemU6OH0pO2UuQUVTPW4uX2NyZWF0ZUhlbHBlcihtKX0oKSx0LkFFU30pfSx7Ii4vY2lwaGVyLWNvcmUiOjUyLCIuL2NvcmUiOjUzLCIuL2VuYy1iYXNlNjQiOjU0LCIuL2V2cGtkZiI6NTYsIi4vbWQ1Ijo2MX1dLDUyOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXt0LmxpYi5DaXBoZXJ8fGZ1bmN0aW9uKGUpe3ZhciBuPXQscj1uLmxpYixvPXIuQmFzZSxpPXIuV29yZEFycmF5LGE9ci5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtLHM9bi5lbmMsYz0ocy5VdGY4LHMuQmFzZTY0KSx1PW4uYWxnby5FdnBLREYsZj1yLkNpcGhlcj1hLmV4dGVuZCh7Y2ZnOm8uZXh0ZW5kKCksY3JlYXRlRW5jcnlwdG9yOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLHQsZSl9LGNyZWF0ZURlY3J5cHRvcjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSx0LGUpfSxpbml0OmZ1bmN0aW9uKHQsZSxuKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQobiksdGhpcy5feGZvcm1Nb2RlPXQsdGhpcy5fa2V5PWUsdGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe2EucmVzZXQuY2FsbCh0aGlzKSx0aGlzLl9kb1Jlc2V0KCl9LHByb2Nlc3M6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2FwcGVuZCh0KSx0aGlzLl9wcm9jZXNzKCl9LGZpbmFsaXplOmZ1bmN0aW9uKHQpe3QmJnRoaXMuX2FwcGVuZCh0KTtyZXR1cm4gdGhpcy5fZG9GaW5hbGl6ZSgpfSxrZXlTaXplOjQsaXZTaXplOjQsX0VOQ19YRk9STV9NT0RFOjEsX0RFQ19YRk9STV9NT0RFOjIsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbigpe2Z1bmN0aW9uIHQodCl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0P2I6Z31yZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJue2VuY3J5cHQ6ZnVuY3Rpb24obixyLG8pe3JldHVybiB0KHIpLmVuY3J5cHQoZSxuLHIsbyl9LGRlY3J5cHQ6ZnVuY3Rpb24obixyLG8pe3JldHVybiB0KHIpLmRlY3J5cHQoZSxuLHIsbyl9fX19KCl9KSxsPShyLlN0cmVhbUNpcGhlcj1mLmV4dGVuZCh7X2RvRmluYWxpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvY2VzcyghMCl9LGJsb2NrU2l6ZToxfSksbi5tb2RlPXt9KSxwPXIuQmxvY2tDaXBoZXJNb2RlPW8uZXh0ZW5kKHtjcmVhdGVFbmNyeXB0b3I6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKHQsZSl9LGNyZWF0ZURlY3J5cHRvcjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUodCxlKX0saW5pdDpmdW5jdGlvbih0LGUpe3RoaXMuX2NpcGhlcj10LHRoaXMuX2l2PWV9fSksaD1sLkNCQz1mdW5jdGlvbigpe2Z1bmN0aW9uIHQodCxuLHIpe3ZhciBvPXRoaXMuX2l2O2lmKG8pe3ZhciBpPW87dGhpcy5faXY9ZX1lbHNlIGk9dGhpcy5fcHJldkJsb2NrO2Zvcih2YXIgYT0wO2E8cjthKyspdFtuK2FdXj1pW2FdfXZhciBuPXAuZXh0ZW5kKCk7cmV0dXJuIG4uRW5jcnlwdG9yPW4uZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24oZSxuKXt2YXIgcj10aGlzLl9jaXBoZXIsbz1yLmJsb2NrU2l6ZTt0LmNhbGwodGhpcyxlLG4sbyksci5lbmNyeXB0QmxvY2soZSxuKSx0aGlzLl9wcmV2QmxvY2s9ZS5zbGljZShuLG4rbyl9fSksbi5EZWNyeXB0b3I9bi5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLG4pe3ZhciByPXRoaXMuX2NpcGhlcixvPXIuYmxvY2tTaXplLGk9ZS5zbGljZShuLG4rbyk7ci5kZWNyeXB0QmxvY2soZSxuKSx0LmNhbGwodGhpcyxlLG4sbyksdGhpcy5fcHJldkJsb2NrPWl9fSksbn0oKSxkPShuLnBhZD17fSkuUGtjczc9e3BhZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj00KmUscj1uLXQuc2lnQnl0ZXMlbixvPXI8PDI0fHI8PDE2fHI8PDh8cixhPVtdLHM9MDtzPHI7cys9NClhLnB1c2gobyk7dmFyIGM9aS5jcmVhdGUoYSxyKTt0LmNvbmNhdChjKX0sdW5wYWQ6ZnVuY3Rpb24odCl7dmFyIGU9MjU1JnQud29yZHNbdC5zaWdCeXRlcy0xPj4+Ml07dC5zaWdCeXRlcy09ZX19LG09KHIuQmxvY2tDaXBoZXI9Zi5leHRlbmQoe2NmZzpmLmNmZy5leHRlbmQoe21vZGU6aCxwYWRkaW5nOmR9KSxyZXNldDpmdW5jdGlvbigpe2YucmVzZXQuY2FsbCh0aGlzKTt2YXIgdD10aGlzLmNmZyxlPXQuaXYsbj10Lm1vZGU7aWYodGhpcy5feGZvcm1Nb2RlPT10aGlzLl9FTkNfWEZPUk1fTU9ERSl2YXIgcj1uLmNyZWF0ZUVuY3J5cHRvcjtlbHNle3I9bi5jcmVhdGVEZWNyeXB0b3I7dGhpcy5fbWluQnVmZmVyU2l6ZT0xfXRoaXMuX21vZGU9ci5jYWxsKG4sdGhpcyxlJiZlLndvcmRzKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dGhpcy5fbW9kZS5wcm9jZXNzQmxvY2sodCxlKX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNmZy5wYWRkaW5nO2lmKHRoaXMuX3hmb3JtTW9kZT09dGhpcy5fRU5DX1hGT1JNX01PREUpe3QucGFkKHRoaXMuX2RhdGEsdGhpcy5ibG9ja1NpemUpO3ZhciBlPXRoaXMuX3Byb2Nlc3MoITApfWVsc2V7ZT10aGlzLl9wcm9jZXNzKCEwKTt0LnVucGFkKGUpfXJldHVybiBlfSxibG9ja1NpemU6NH0pLHIuQ2lwaGVyUGFyYW1zPW8uZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKHQpe3RoaXMubWl4SW4odCl9LHRvU3RyaW5nOmZ1bmN0aW9uKHQpe3JldHVybih0fHx0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpfX0pKSx5PShuLmZvcm1hdD17fSkuT3BlblNTTD17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe3ZhciBlPXQuY2lwaGVydGV4dCxuPXQuc2FsdDtpZihuKXZhciByPWkuY3JlYXRlKFsxMzk4ODkzNjg0LDE3MDEwNzY4MzFdKS5jb25jYXQobikuY29uY2F0KGUpO2Vsc2Ugcj1lO3JldHVybiByLnRvU3RyaW5nKGMpfSxwYXJzZTpmdW5jdGlvbih0KXt2YXIgZT1jLnBhcnNlKHQpLG49ZS53b3JkcztpZigxMzk4ODkzNjg0PT1uWzBdJiYxNzAxMDc2ODMxPT1uWzFdKXt2YXIgcj1pLmNyZWF0ZShuLnNsaWNlKDIsNCkpO24uc3BsaWNlKDAsNCksZS5zaWdCeXRlcy09MTZ9cmV0dXJuIG0uY3JlYXRlKHtjaXBoZXJ0ZXh0OmUsc2FsdDpyfSl9fSxnPXIuU2VyaWFsaXphYmxlQ2lwaGVyPW8uZXh0ZW5kKHtjZmc6by5leHRlbmQoe2Zvcm1hdDp5fSksZW5jcnlwdDpmdW5jdGlvbih0LGUsbixyKXtyPXRoaXMuY2ZnLmV4dGVuZChyKTt2YXIgbz10LmNyZWF0ZUVuY3J5cHRvcihuLHIpLGk9by5maW5hbGl6ZShlKSxhPW8uY2ZnO3JldHVybiBtLmNyZWF0ZSh7Y2lwaGVydGV4dDppLGtleTpuLGl2OmEuaXYsYWxnb3JpdGhtOnQsbW9kZTphLm1vZGUscGFkZGluZzphLnBhZGRpbmcsYmxvY2tTaXplOnQuYmxvY2tTaXplLGZvcm1hdHRlcjpyLmZvcm1hdH0pfSxkZWNyeXB0OmZ1bmN0aW9uKHQsZSxuLHIpe3I9dGhpcy5jZmcuZXh0ZW5kKHIpLGU9dGhpcy5fcGFyc2UoZSxyLmZvcm1hdCk7cmV0dXJuIHQuY3JlYXRlRGVjcnlwdG9yKG4scikuZmluYWxpemUoZS5jaXBoZXJ0ZXh0KX0sX3BhcnNlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuInN0cmluZyI9PXR5cGVvZiB0P2UucGFyc2UodCx0aGlzKTp0fX0pLHY9KG4ua2RmPXt9KS5PcGVuU1NMPXtleGVjdXRlOmZ1bmN0aW9uKHQsZSxuLHIpe3J8fChyPWkucmFuZG9tKDgpKTt2YXIgbz11LmNyZWF0ZSh7a2V5U2l6ZTplK259KS5jb21wdXRlKHQsciksYT1pLmNyZWF0ZShvLndvcmRzLnNsaWNlKGUpLDQqbik7cmV0dXJuIG8uc2lnQnl0ZXM9NCplLG0uY3JlYXRlKHtrZXk6byxpdjphLHNhbHQ6cn0pfX0sYj1yLlBhc3N3b3JkQmFzZWRDaXBoZXI9Zy5leHRlbmQoe2NmZzpnLmNmZy5leHRlbmQoe2tkZjp2fSksZW5jcnlwdDpmdW5jdGlvbih0LGUsbixyKXt2YXIgbz0ocj10aGlzLmNmZy5leHRlbmQocikpLmtkZi5leGVjdXRlKG4sdC5rZXlTaXplLHQuaXZTaXplKTtyLml2PW8uaXY7dmFyIGk9Zy5lbmNyeXB0LmNhbGwodGhpcyx0LGUsby5rZXkscik7cmV0dXJuIGkubWl4SW4obyksaX0sZGVjcnlwdDpmdW5jdGlvbih0LGUsbixyKXtyPXRoaXMuY2ZnLmV4dGVuZChyKSxlPXRoaXMuX3BhcnNlKGUsci5mb3JtYXQpO3ZhciBvPXIua2RmLmV4ZWN1dGUobix0LmtleVNpemUsdC5pdlNpemUsZS5zYWx0KTtyLml2PW8uaXY7cmV0dXJuIGcuZGVjcnlwdC5jYWxsKHRoaXMsdCxlLG8ua2V5LHIpfX0pfSgpfSl9LHsiLi9jb3JlIjo1M31dLDUzOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHQscil7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPXIoKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxyKTp0LkNyeXB0b0pTPXIoKX0odGhpcyxmdW5jdGlvbigpe3ZhciB0PXR8fGZ1bmN0aW9uKHQsZSl7dmFyIG49T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiBmdW5jdGlvbihlKXt2YXIgbjtyZXR1cm4gdC5wcm90b3R5cGU9ZSxuPW5ldyB0LHQucHJvdG90eXBlPW51bGwsbn19KCkscj17fSxvPXIubGliPXt9LGk9by5CYXNlPXtleHRlbmQ6ZnVuY3Rpb24odCl7dmFyIGU9bih0aGlzKTtyZXR1cm4gdCYmZS5taXhJbih0KSxlLmhhc093blByb3BlcnR5KCJpbml0IikmJnRoaXMuaW5pdCE9PWUuaW5pdHx8KGUuaW5pdD1mdW5jdGlvbigpe2UuJHN1cGVyLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpfSksZS5pbml0LnByb3RvdHlwZT1lLGUuJHN1cGVyPXRoaXMsZX0sY3JlYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5leHRlbmQoKTtyZXR1cm4gdC5pbml0LmFwcGx5KHQsYXJndW1lbnRzKSx0fSxpbml0OmZ1bmN0aW9uKCl7fSxtaXhJbjpmdW5jdGlvbih0KXtmb3IodmFyIGUgaW4gdCl0Lmhhc093blByb3BlcnR5KGUpJiYodGhpc1tlXT10W2VdKTt0Lmhhc093blByb3BlcnR5KCJ0b1N0cmluZyIpJiYodGhpcy50b1N0cmluZz10LnRvU3RyaW5nKX0sY2xvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbml0LnByb3RvdHlwZS5leHRlbmQodGhpcyl9fSxhPW8uV29yZEFycmF5PWkuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKHQsZSl7dD10aGlzLndvcmRzPXR8fFtdLHRoaXMuc2lnQnl0ZXM9dm9pZCAwIT1lP2U6NCp0Lmxlbmd0aH0sdG9TdHJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuKHR8fGMpLnN0cmluZ2lmeSh0aGlzKX0sY29uY2F0OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMud29yZHMsbj10LndvcmRzLHI9dGhpcy5zaWdCeXRlcyxvPXQuc2lnQnl0ZXM7aWYodGhpcy5jbGFtcCgpLHIlNClmb3IodmFyIGk9MDtpPG87aSsrKXt2YXIgYT1uW2k+Pj4yXT4+PjI0LWklNCo4JjI1NTtlW3IraT4+PjJdfD1hPDwyNC0ocitpKSU0Kjh9ZWxzZSBmb3IoaT0wO2k8bztpKz00KWVbcitpPj4+Ml09bltpPj4+Ml07cmV0dXJuIHRoaXMuc2lnQnl0ZXMrPW8sdGhpc30sY2xhbXA6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLndvcmRzLG49dGhpcy5zaWdCeXRlcztlW24+Pj4yXSY9NDI5NDk2NzI5NTw8MzItbiU0KjgsZS5sZW5ndGg9dC5jZWlsKG4vNCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9aS5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0LndvcmRzPXRoaXMud29yZHMuc2xpY2UoMCksdH0scmFuZG9tOmZ1bmN0aW9uKGUpe2Zvcih2YXIgbixyPVtdLG89ZnVuY3Rpb24oZSl7ZT1lO3ZhciBuPTk4NzY1NDMyMTtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgcj0oKG49MzY5NjkqKDY1NTM1Jm4pKyhuPj4xNikmNDI5NDk2NzI5NSk8PDE2KSsoZT0xOGUzKig2NTUzNSZlKSsoZT4+MTYpJjQyOTQ5NjcyOTUpJjQyOTQ5NjcyOTU7cmV0dXJuIHIvPTQyOTQ5NjcyOTYsKHIrPS41KSoodC5yYW5kb20oKT4uNT8xOi0xKX19LGk9MDtpPGU7aSs9NCl7dmFyIHM9byg0Mjk0OTY3Mjk2KihufHx0LnJhbmRvbSgpKSk7bj05ODc2NTQwNzEqcygpLHIucHVzaCg0Mjk0OTY3Mjk2KnMoKXwwKX1yZXR1cm4gbmV3IGEuaW5pdChyLGUpfX0pLHM9ci5lbmM9e30sYz1zLkhleD17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LndvcmRzLG49dC5zaWdCeXRlcyxyPVtdLG89MDtvPG47bysrKXt2YXIgaT1lW28+Pj4yXT4+PjI0LW8lNCo4JjI1NTtyLnB1c2goKGk+Pj40KS50b1N0cmluZygxNikpLHIucHVzaCgoMTUmaSkudG9TdHJpbmcoMTYpKX1yZXR1cm4gci5qb2luKCIiKX0scGFyc2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLG49W10scj0wO3I8ZTtyKz0yKW5bcj4+PjNdfD1wYXJzZUludCh0LnN1YnN0cihyLDIpLDE2KTw8MjQtciU4KjQ7cmV0dXJuIG5ldyBhLmluaXQobixlLzIpfX0sdT1zLkxhdGluMT17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LndvcmRzLG49dC5zaWdCeXRlcyxyPVtdLG89MDtvPG47bysrKXt2YXIgaT1lW28+Pj4yXT4+PjI0LW8lNCo4JjI1NTtyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpKSl9cmV0dXJuIHIuam9pbigiIil9LHBhcnNlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxuPVtdLHI9MDtyPGU7cisrKW5bcj4+PjJdfD0oMjU1JnQuY2hhckNvZGVBdChyKSk8PDI0LXIlNCo4O3JldHVybiBuZXcgYS5pbml0KG4sZSl9fSxmPXMuVXRmOD17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh1LnN0cmluZ2lmeSh0KSkpfWNhdGNoKHQpe3Rocm93IG5ldyBFcnJvcigiTWFsZm9ybWVkIFVURi04IGRhdGEiKX19LHBhcnNlOmZ1bmN0aW9uKHQpe3JldHVybiB1LnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh0KSkpfX0sbD1vLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG09aS5leHRlbmQoe3Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5fZGF0YT1uZXcgYS5pbml0LHRoaXMuX25EYXRhQnl0ZXM9MH0sX2FwcGVuZDpmdW5jdGlvbih0KXsic3RyaW5nIj09dHlwZW9mIHQmJih0PWYucGFyc2UodCkpLHRoaXMuX2RhdGEuY29uY2F0KHQpLHRoaXMuX25EYXRhQnl0ZXMrPXQuc2lnQnl0ZXN9LF9wcm9jZXNzOmZ1bmN0aW9uKGUpe3ZhciBuPXRoaXMuX2RhdGEscj1uLndvcmRzLG89bi5zaWdCeXRlcyxpPXRoaXMuYmxvY2tTaXplLHM9by8oNCppKSxjPShzPWU/dC5jZWlsKHMpOnQubWF4KCgwfHMpLXRoaXMuX21pbkJ1ZmZlclNpemUsMCkpKmksdT10Lm1pbig0KmMsbyk7aWYoYyl7Zm9yKHZhciBmPTA7ZjxjO2YrPWkpdGhpcy5fZG9Qcm9jZXNzQmxvY2socixmKTt2YXIgbD1yLnNwbGljZSgwLGMpO24uc2lnQnl0ZXMtPXV9cmV0dXJuIG5ldyBhLmluaXQobCx1KX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1pLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuX2RhdGE9dGhpcy5fZGF0YS5jbG9uZSgpLHR9LF9taW5CdWZmZXJTaXplOjB9KSxwPShvLkhhc2hlcj1sLmV4dGVuZCh7Y2ZnOmkuZXh0ZW5kKCksaW5pdDpmdW5jdGlvbih0KXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQodCksdGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe2wucmVzZXQuY2FsbCh0aGlzKSx0aGlzLl9kb1Jlc2V0KCl9LHVwZGF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5fYXBwZW5kKHQpLHRoaXMuX3Byb2Nlc3MoKSx0aGlzfSxmaW5hbGl6ZTpmdW5jdGlvbih0KXt0JiZ0aGlzLl9hcHBlbmQodCk7cmV0dXJuIHRoaXMuX2RvRmluYWxpemUoKX0sYmxvY2tTaXplOjE2LF9jcmVhdGVIZWxwZXI6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUsbil7cmV0dXJuIG5ldyB0LmluaXQobikuZmluYWxpemUoZSl9fSxfY3JlYXRlSG1hY0hlbHBlcjpmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxuKXtyZXR1cm4gbmV3IHAuSE1BQy5pbml0KHQsbikuZmluYWxpemUoZSl9fX0pLHIuYWxnbz17fSk7cmV0dXJuIHJ9KE1hdGgpO3JldHVybiB0fSl9LHt9XSw1NDpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8peyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9dCxuPWUubGliLldvcmRBcnJheTtlLmVuYy5CYXNlNjQ9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXt2YXIgZT10LndvcmRzLG49dC5zaWdCeXRlcyxyPXRoaXMuX21hcDt0LmNsYW1wKCk7Zm9yKHZhciBvPVtdLGk9MDtpPG47aSs9Mylmb3IodmFyIGE9KGVbaT4+PjJdPj4+MjQtaSU0KjgmMjU1KTw8MTZ8KGVbaSsxPj4+Ml0+Pj4yNC0oaSsxKSU0KjgmMjU1KTw8OHxlW2krMj4+PjJdPj4+MjQtKGkrMiklNCo4JjI1NSxzPTA7czw0JiZpKy43NSpzPG47cysrKW8ucHVzaChyLmNoYXJBdChhPj4+NiooMy1zKSY2MykpO3ZhciBjPXIuY2hhckF0KDY0KTtpZihjKWZvcig7by5sZW5ndGglNDspby5wdXNoKGMpO3JldHVybiBvLmpvaW4oIiIpfSxwYXJzZTpmdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aCxyPXRoaXMuX21hcCxvPXRoaXMuX3JldmVyc2VNYXA7aWYoIW8pe289dGhpcy5fcmV2ZXJzZU1hcD1bXTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKylvW3IuY2hhckNvZGVBdChpKV09aX12YXIgYT1yLmNoYXJBdCg2NCk7aWYoYSl7dmFyIHM9dC5pbmRleE9mKGEpOy0xIT09cyYmKGU9cyl9cmV0dXJuIGZ1bmN0aW9uKHQsZSxyKXtmb3IodmFyIG89W10saT0wLGE9MDthPGU7YSsrKWlmKGElNCl7dmFyIHM9clt0LmNoYXJDb2RlQXQoYS0xKV08PGElNCoyLGM9clt0LmNoYXJDb2RlQXQoYSldPj4+Ni1hJTQqMjtvW2k+Pj4yXXw9KHN8Yyk8PDI0LWklNCo4LGkrK31yZXR1cm4gbi5jcmVhdGUobyxpKX0odCxlLG8pfSxfbWFwOiJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSJ9fSgpLHQuZW5jLkJhc2U2NH0pfSx7Ii4vY29yZSI6NTN9XSw1NTpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8peyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0KXtyZXR1cm4gdDw8OCY0Mjc4MjU1MzYwfHQ+Pj44JjE2NzExOTM1fXZhciBuPXQscj1uLmxpYi5Xb3JkQXJyYXksbz1uLmVuYztvLlV0ZjE2PW8uVXRmMTZCRT17c3RyaW5naWZ5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LndvcmRzLG49dC5zaWdCeXRlcyxyPVtdLG89MDtvPG47bys9Mil7dmFyIGk9ZVtvPj4+Ml0+Pj4xNi1vJTQqOCY2NTUzNTtyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShpKSl9cmV0dXJuIHIuam9pbigiIil9LHBhcnNlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lmxlbmd0aCxuPVtdLG89MDtvPGU7bysrKW5bbz4+PjFdfD10LmNoYXJDb2RlQXQobyk8PDE2LW8lMioxNjtyZXR1cm4gci5jcmVhdGUobiwyKmUpfX07by5VdGYxNkxFPXtzdHJpbmdpZnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBuPXQud29yZHMscj10LnNpZ0J5dGVzLG89W10saT0wO2k8cjtpKz0yKXt2YXIgYT1lKG5baT4+PjJdPj4+MTYtaSU0KjgmNjU1MzUpO28ucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKX1yZXR1cm4gby5qb2luKCIiKX0scGFyc2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBuPXQubGVuZ3RoLG89W10saT0wO2k8bjtpKyspb1tpPj4+MV18PWUodC5jaGFyQ29kZUF0KGkpPDwxNi1pJTIqMTYpO3JldHVybiByLmNyZWF0ZShvLDIqbil9fX0oKSx0LmVuYy5VdGYxNn0pfSx7Ii4vY29yZSI6NTN9XSw1NjpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9zaGExIiksdCgiLi9obWFjIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9zaGExIiwiLi9obWFjIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LG49ZS5saWIscj1uLkJhc2Usbz1uLldvcmRBcnJheSxpPWUuYWxnbyxhPWkuTUQ1LHM9aS5FdnBLREY9ci5leHRlbmQoe2NmZzpyLmV4dGVuZCh7a2V5U2l6ZTo0LGhhc2hlcjphLGl0ZXJhdGlvbnM6MX0pLGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5jZmc9dGhpcy5jZmcuZXh0ZW5kKHQpfSxjb21wdXRlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuY2ZnLHI9bi5oYXNoZXIuY3JlYXRlKCksaT1vLmNyZWF0ZSgpLGE9aS53b3JkcyxzPW4ua2V5U2l6ZSxjPW4uaXRlcmF0aW9uczthLmxlbmd0aDxzOyl7dSYmci51cGRhdGUodSk7dmFyIHU9ci51cGRhdGUodCkuZmluYWxpemUoZSk7ci5yZXNldCgpO2Zvcih2YXIgZj0xO2Y8YztmKyspdT1yLmZpbmFsaXplKHUpLHIucmVzZXQoKTtpLmNvbmNhdCh1KX1yZXR1cm4gaS5zaWdCeXRlcz00KnMsaX19KTtlLkV2cEtERj1mdW5jdGlvbih0LGUsbil7cmV0dXJuIHMuY3JlYXRlKG4pLmNvbXB1dGUodCxlKX19KCksdC5FdnBLREZ9KX0seyIuL2NvcmUiOjUzLCIuL2htYWMiOjU4LCIuL3NoYTEiOjc3fV0sNTc6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIG49dCxyPW4ubGliLkNpcGhlclBhcmFtcyxvPW4uZW5jLkhleDtuLmZvcm1hdC5IZXg9e3N0cmluZ2lmeTpmdW5jdGlvbih0KXtyZXR1cm4gdC5jaXBoZXJ0ZXh0LnRvU3RyaW5nKG8pfSxwYXJzZTpmdW5jdGlvbih0KXt2YXIgZT1vLnBhcnNlKHQpO3JldHVybiByLmNyZWF0ZSh7Y2lwaGVydGV4dDplfSl9fX0oKSx0LmZvcm1hdC5IZXh9KX0seyIuL2NpcGhlci1jb3JlIjo1MiwiLi9jb3JlIjo1M31dLDU4OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXshZnVuY3Rpb24oKXt2YXIgZT10LG49ZS5saWIuQmFzZSxyPWUuZW5jLlV0Zjg7ZS5hbGdvLkhNQUM9bi5leHRlbmQoe2luaXQ6ZnVuY3Rpb24odCxlKXt0PXRoaXMuX2hhc2hlcj1uZXcgdC5pbml0LCJzdHJpbmciPT10eXBlb2YgZSYmKGU9ci5wYXJzZShlKSk7dmFyIG49dC5ibG9ja1NpemUsbz00Km47ZS5zaWdCeXRlcz5vJiYoZT10LmZpbmFsaXplKGUpKSxlLmNsYW1wKCk7Zm9yKHZhciBpPXRoaXMuX29LZXk9ZS5jbG9uZSgpLGE9dGhpcy5faUtleT1lLmNsb25lKCkscz1pLndvcmRzLGM9YS53b3Jkcyx1PTA7dTxuO3UrKylzW3VdXj0xNTQ5NTU2ODI4LGNbdV1ePTkwOTUyMjQ4NjtpLnNpZ0J5dGVzPWEuc2lnQnl0ZXM9byx0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5faGFzaGVyO3QucmVzZXQoKSx0LnVwZGF0ZSh0aGlzLl9pS2V5KX0sdXBkYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLl9oYXNoZXIudXBkYXRlKHQpLHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX2hhc2hlcixuPWUuZmluYWxpemUodCk7ZS5yZXNldCgpO3JldHVybiBlLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQobikpfX0pfSgpfSl9LHsiLi9jb3JlIjo1M31dLDU5OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL3g2NC1jb3JlIiksdCgiLi9saWItdHlwZWRhcnJheXMiKSx0KCIuL2VuYy11dGYxNiIpLHQoIi4vZW5jLWJhc2U2NCIpLHQoIi4vbWQ1IiksdCgiLi9zaGExIiksdCgiLi9zaGEyNTYiKSx0KCIuL3NoYTIyNCIpLHQoIi4vc2hhNTEyIiksdCgiLi9zaGEzODQiKSx0KCIuL3NoYTMiKSx0KCIuL3JpcGVtZDE2MCIpLHQoIi4vaG1hYyIpLHQoIi4vcGJrZGYyIiksdCgiLi9ldnBrZGYiKSx0KCIuL2NpcGhlci1jb3JlIiksdCgiLi9tb2RlLWNmYiIpLHQoIi4vbW9kZS1jdHIiKSx0KCIuL21vZGUtY3RyLWdsYWRtYW4iKSx0KCIuL21vZGUtb2ZiIiksdCgiLi9tb2RlLWVjYiIpLHQoIi4vcGFkLWFuc2l4OTIzIiksdCgiLi9wYWQtaXNvMTAxMjYiKSx0KCIuL3BhZC1pc285Nzk3MSIpLHQoIi4vcGFkLXplcm9wYWRkaW5nIiksdCgiLi9wYWQtbm9wYWRkaW5nIiksdCgiLi9mb3JtYXQtaGV4IiksdCgiLi9hZXMiKSx0KCIuL3RyaXBsZWRlcyIpLHQoIi4vcmM0IiksdCgiLi9yYWJiaXQiKSx0KCIuL3JhYmJpdC1sZWdhY3kiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL3g2NC1jb3JlIiwiLi9saWItdHlwZWRhcnJheXMiLCIuL2VuYy11dGYxNiIsIi4vZW5jLWJhc2U2NCIsIi4vbWQ1IiwiLi9zaGExIiwiLi9zaGEyNTYiLCIuL3NoYTIyNCIsIi4vc2hhNTEyIiwiLi9zaGEzODQiLCIuL3NoYTMiLCIuL3JpcGVtZDE2MCIsIi4vaG1hYyIsIi4vcGJrZGYyIiwiLi9ldnBrZGYiLCIuL2NpcGhlci1jb3JlIiwiLi9tb2RlLWNmYiIsIi4vbW9kZS1jdHIiLCIuL21vZGUtY3RyLWdsYWRtYW4iLCIuL21vZGUtb2ZiIiwiLi9tb2RlLWVjYiIsIi4vcGFkLWFuc2l4OTIzIiwiLi9wYWQtaXNvMTAxMjYiLCIuL3BhZC1pc285Nzk3MSIsIi4vcGFkLXplcm9wYWRkaW5nIiwiLi9wYWQtbm9wYWRkaW5nIiwiLi9mb3JtYXQtaGV4IiwiLi9hZXMiLCIuL3RyaXBsZWRlcyIsIi4vcmM0IiwiLi9yYWJiaXQiLCIuL3JhYmJpdC1sZWdhY3kiXSxvKTpyLkNyeXB0b0pTPW8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIHR9KX0seyIuL2FlcyI6NTEsIi4vY2lwaGVyLWNvcmUiOjUyLCIuL2NvcmUiOjUzLCIuL2VuYy1iYXNlNjQiOjU0LCIuL2VuYy11dGYxNiI6NTUsIi4vZXZwa2RmIjo1NiwiLi9mb3JtYXQtaGV4Ijo1NywiLi9obWFjIjo1OCwiLi9saWItdHlwZWRhcnJheXMiOjYwLCIuL21kNSI6NjEsIi4vbW9kZS1jZmIiOjYyLCIuL21vZGUtY3RyIjo2NCwiLi9tb2RlLWN0ci1nbGFkbWFuIjo2MywiLi9tb2RlLWVjYiI6NjUsIi4vbW9kZS1vZmIiOjY2LCIuL3BhZC1hbnNpeDkyMyI6NjcsIi4vcGFkLWlzbzEwMTI2Ijo2OCwiLi9wYWQtaXNvOTc5NzEiOjY5LCIuL3BhZC1ub3BhZGRpbmciOjcwLCIuL3BhZC16ZXJvcGFkZGluZyI6NzEsIi4vcGJrZGYyIjo3MiwiLi9yYWJiaXQiOjc0LCIuL3JhYmJpdC1sZWdhY3kiOjczLCIuL3JjNCI6NzUsIi4vcmlwZW1kMTYwIjo3NiwiLi9zaGExIjo3NywiLi9zaGEyMjQiOjc4LCIuL3NoYTI1NiI6NzksIi4vc2hhMyI6ODAsIi4vc2hhMzg0Ijo4MSwiLi9zaGE1MTIiOjgyLCIuL3RyaXBsZWRlcyI6ODMsIi4veDY0LWNvcmUiOjg0fV0sNjA6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiBBcnJheUJ1ZmZlcil7dmFyIGU9dC5saWIuV29yZEFycmF5LG49ZS5pbml0OyhlLmluaXQ9ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyJiYodD1uZXcgVWludDhBcnJheSh0KSksKHQgaW5zdGFuY2VvZiBJbnQ4QXJyYXl8fCJ1bmRlZmluZWQiIT10eXBlb2YgVWludDhDbGFtcGVkQXJyYXkmJnQgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8dCBpbnN0YW5jZW9mIEludDE2QXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50MTZBcnJheXx8dCBpbnN0YW5jZW9mIEludDMyQXJyYXl8fHQgaW5zdGFuY2VvZiBVaW50MzJBcnJheXx8dCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheXx8dCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkmJih0PW5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpKSx0IGluc3RhbmNlb2YgVWludDhBcnJheSl7Zm9yKHZhciBlPXQuYnl0ZUxlbmd0aCxyPVtdLG89MDtvPGU7bysrKXJbbz4+PjJdfD10W29dPDwyNC1vJTQqODtuLmNhbGwodGhpcyxyLGUpfWVsc2Ugbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KS5wcm90b3R5cGU9ZX19KCksdC5saWIuV29yZEFycmF5fSl9LHsiLi9jb3JlIjo1M31dLDYxOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbih0LGUsbixyLG8saSxhKXt2YXIgcz10KyhlJm58fmUmcikrbythO3JldHVybihzPDxpfHM+Pj4zMi1pKStlfWZ1bmN0aW9uIHIodCxlLG4scixvLGksYSl7dmFyIHM9dCsoZSZyfG4mfnIpK28rYTtyZXR1cm4oczw8aXxzPj4+MzItaSkrZX1mdW5jdGlvbiBvKHQsZSxuLHIsbyxpLGEpe3ZhciBzPXQrKGVebl5yKStvK2E7cmV0dXJuKHM8PGl8cz4+PjMyLWkpK2V9ZnVuY3Rpb24gaSh0LGUsbixyLG8saSxhKXt2YXIgcz10KyhuXihlfH5yKSkrbythO3JldHVybihzPDxpfHM+Pj4zMi1pKStlfXZhciBhPXQscz1hLmxpYixjPXMuV29yZEFycmF5LHU9cy5IYXNoZXIsZj1hLmFsZ28sbD1bXTshZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PDY0O3QrKylsW3RdPTQyOTQ5NjcyOTYqZS5hYnMoZS5zaW4odCsxKSl8MH0oKTt2YXIgcD1mLk1ENT11LmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBjLmluaXQoWzE3MzI1ODQxOTMsNDAyMzIzMzQxNywyNTYyMzgzMTAyLDI3MTczMzg3OF0pfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXtmb3IodmFyIGE9MDthPDE2O2ErKyl7dmFyIHM9ZSthLGM9dFtzXTt0W3NdPTE2NzExOTM1JihjPDw4fGM+Pj4yNCl8NDI3ODI1NTM2MCYoYzw8MjR8Yz4+PjgpfXZhciB1PXRoaXMuX2hhc2gud29yZHMsZj10W2UrMF0scD10W2UrMV0saD10W2UrMl0sZD10W2UrM10sbT10W2UrNF0seT10W2UrNV0sZz10W2UrNl0sdj10W2UrN10sYj10W2UrOF0sXz10W2UrOV0sdz10W2UrMTBdLHg9dFtlKzExXSxrPXRbZSsxMl0sQj10W2UrMTNdLFM9dFtlKzE0XSxBPXRbZSsxNV0sQz11WzBdLEY9dVsxXSxPPXVbMl0sTj11WzNdO0Y9aShGPWkoRj1pKEY9aShGPW8oRj1vKEY9byhGPW8oRj1yKEY9cihGPXIoRj1yKEY9bihGPW4oRj1uKEY9bihGLE89bihPLE49bihOLEM9bihDLEYsTyxOLGYsNyxsWzBdKSxGLE8scCwxMixsWzFdKSxDLEYsaCwxNyxsWzJdKSxOLEMsZCwyMixsWzNdKSxPPW4oTyxOPW4oTixDPW4oQyxGLE8sTixtLDcsbFs0XSksRixPLHksMTIsbFs1XSksQyxGLGcsMTcsbFs2XSksTixDLHYsMjIsbFs3XSksTz1uKE8sTj1uKE4sQz1uKEMsRixPLE4sYiw3LGxbOF0pLEYsTyxfLDEyLGxbOV0pLEMsRix3LDE3LGxbMTBdKSxOLEMseCwyMixsWzExXSksTz1uKE8sTj1uKE4sQz1uKEMsRixPLE4sayw3LGxbMTJdKSxGLE8sQiwxMixsWzEzXSksQyxGLFMsMTcsbFsxNF0pLE4sQyxBLDIyLGxbMTVdKSxPPXIoTyxOPXIoTixDPXIoQyxGLE8sTixwLDUsbFsxNl0pLEYsTyxnLDksbFsxN10pLEMsRix4LDE0LGxbMThdKSxOLEMsZiwyMCxsWzE5XSksTz1yKE8sTj1yKE4sQz1yKEMsRixPLE4seSw1LGxbMjBdKSxGLE8sdyw5LGxbMjFdKSxDLEYsQSwxNCxsWzIyXSksTixDLG0sMjAsbFsyM10pLE89cihPLE49cihOLEM9cihDLEYsTyxOLF8sNSxsWzI0XSksRixPLFMsOSxsWzI1XSksQyxGLGQsMTQsbFsyNl0pLE4sQyxiLDIwLGxbMjddKSxPPXIoTyxOPXIoTixDPXIoQyxGLE8sTixCLDUsbFsyOF0pLEYsTyxoLDksbFsyOV0pLEMsRix2LDE0LGxbMzBdKSxOLEMsaywyMCxsWzMxXSksTz1vKE8sTj1vKE4sQz1vKEMsRixPLE4seSw0LGxbMzJdKSxGLE8sYiwxMSxsWzMzXSksQyxGLHgsMTYsbFszNF0pLE4sQyxTLDIzLGxbMzVdKSxPPW8oTyxOPW8oTixDPW8oQyxGLE8sTixwLDQsbFszNl0pLEYsTyxtLDExLGxbMzddKSxDLEYsdiwxNixsWzM4XSksTixDLHcsMjMsbFszOV0pLE89byhPLE49byhOLEM9byhDLEYsTyxOLEIsNCxsWzQwXSksRixPLGYsMTEsbFs0MV0pLEMsRixkLDE2LGxbNDJdKSxOLEMsZywyMyxsWzQzXSksTz1vKE8sTj1vKE4sQz1vKEMsRixPLE4sXyw0LGxbNDRdKSxGLE8saywxMSxsWzQ1XSksQyxGLEEsMTYsbFs0Nl0pLE4sQyxoLDIzLGxbNDddKSxPPWkoTyxOPWkoTixDPWkoQyxGLE8sTixmLDYsbFs0OF0pLEYsTyx2LDEwLGxbNDldKSxDLEYsUywxNSxsWzUwXSksTixDLHksMjEsbFs1MV0pLE89aShPLE49aShOLEM9aShDLEYsTyxOLGssNixsWzUyXSksRixPLGQsMTAsbFs1M10pLEMsRix3LDE1LGxbNTRdKSxOLEMscCwyMSxsWzU1XSksTz1pKE8sTj1pKE4sQz1pKEMsRixPLE4sYiw2LGxbNTZdKSxGLE8sQSwxMCxsWzU3XSksQyxGLGcsMTUsbFs1OF0pLE4sQyxCLDIxLGxbNTldKSxPPWkoTyxOPWkoTixDPWkoQyxGLE8sTixtLDYsbFs2MF0pLEYsTyx4LDEwLGxbNjFdKSxDLEYsaCwxNSxsWzYyXSksTixDLF8sMjEsbFs2M10pLHVbMF09dVswXStDfDAsdVsxXT11WzFdK0Z8MCx1WzJdPXVbMl0rT3wwLHVbM109dVszXStOfDB9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZGF0YSxuPXQud29yZHMscj04KnRoaXMuX25EYXRhQnl0ZXMsbz04KnQuc2lnQnl0ZXM7bltvPj4+NV18PTEyODw8MjQtbyUzMjt2YXIgaT1lLmZsb29yKHIvNDI5NDk2NzI5NiksYT1yO25bMTUrKG8rNjQ+Pj45PDw0KV09MTY3MTE5MzUmKGk8PDh8aT4+PjI0KXw0Mjc4MjU1MzYwJihpPDwyNHxpPj4+OCksblsxNCsobys2ND4+Pjk8PDQpXT0xNjcxMTkzNSYoYTw8OHxhPj4+MjQpfDQyNzgyNTUzNjAmKGE8PDI0fGE+Pj44KSx0LnNpZ0J5dGVzPTQqKG4ubGVuZ3RoKzEpLHRoaXMuX3Byb2Nlc3MoKTtmb3IodmFyIHM9dGhpcy5faGFzaCxjPXMud29yZHMsdT0wO3U8NDt1Kyspe3ZhciBmPWNbdV07Y1t1XT0xNjcxMTkzNSYoZjw8OHxmPj4+MjQpfDQyNzgyNTUzNjAmKGY8PDI0fGY+Pj44KX1yZXR1cm4gc30sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD11LmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpLHR9fSk7YS5NRDU9dS5fY3JlYXRlSGVscGVyKHApLGEuSG1hY01ENT11Ll9jcmVhdGVIbWFjSGVscGVyKHApfShNYXRoKSx0Lk1ENX0pfSx7Ii4vY29yZSI6NTN9XSw2MjpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9jaXBoZXItY29yZSIpKToiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbIi4vY29yZSIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1vZGUuQ0ZCPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSh0LGUsbixyKXt2YXIgbz10aGlzLl9pdjtpZihvKXt2YXIgaT1vLnNsaWNlKDApO3RoaXMuX2l2PXZvaWQgMH1lbHNlIGk9dGhpcy5fcHJldkJsb2NrO3IuZW5jcnlwdEJsb2NrKGksMCk7Zm9yKHZhciBhPTA7YTxuO2ErKyl0W2UrYV1ePWlbYV19dmFyIG49dC5saWIuQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO3JldHVybiBuLkVuY3J5cHRvcj1uLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcy5fY2lwaGVyLG89ci5ibG9ja1NpemU7ZS5jYWxsKHRoaXMsdCxuLG8sciksdGhpcy5fcHJldkJsb2NrPXQuc2xpY2UobixuK28pfX0pLG4uRGVjcnlwdG9yPW4uZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxuKXt2YXIgcj10aGlzLl9jaXBoZXIsbz1yLmJsb2NrU2l6ZSxpPXQuc2xpY2UobixuK28pO2UuY2FsbCh0aGlzLHQsbixvLHIpLHRoaXMuX3ByZXZCbG9jaz1pfX0pLG59KCksdC5tb2RlLkNGQn0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUyLCIuL2NvcmUiOjUzfV0sNjM6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5tb2RlLkNUUkdsYWRtYW49ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQpe2lmKDI1NT09KHQ+PjI0JjI1NSkpe3ZhciBlPXQ+PjE2JjI1NSxuPXQ+PjgmMjU1LHI9MjU1JnQ7MjU1PT09ZT8oZT0wLDI1NT09PW4/KG49MCwyNTU9PT1yP3I9MDorK3IpOisrbik6KytlLHQ9MCx0Kz1lPDwxNix0Kz1uPDw4LHQrPXJ9ZWxzZSB0Kz0xPDwyNDtyZXR1cm4gdH12YXIgbj10LmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCkscj1uLkVuY3J5cHRvcj1uLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsbil7dmFyIHI9dGhpcy5fY2lwaGVyLG89ci5ibG9ja1NpemUsaT10aGlzLl9pdixhPXRoaXMuX2NvdW50ZXI7aSYmKGE9dGhpcy5fY291bnRlcj1pLnNsaWNlKDApLHRoaXMuX2l2PXZvaWQgMCksZnVuY3Rpb24odCl7MD09PSh0WzBdPWUodFswXSkpJiYodFsxXT1lKHRbMV0pKX0oYSk7dmFyIHM9YS5zbGljZSgwKTtyLmVuY3J5cHRCbG9jayhzLDApO2Zvcih2YXIgYz0wO2M8bztjKyspdFtuK2NdXj1zW2NdfX0pO3JldHVybiBuLkRlY3J5cHRvcj1yLG59KCksdC5tb2RlLkNUUkdsYWRtYW59KX0seyIuL2NpcGhlci1jb3JlIjo1MiwiLi9jb3JlIjo1M31dLDY0OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9jaXBoZXItY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIHQubW9kZS5DVFI9ZnVuY3Rpb24oKXt2YXIgZT10LmxpYi5CbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCksbj1lLkVuY3J5cHRvcj1lLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5fY2lwaGVyLHI9bi5ibG9ja1NpemUsbz10aGlzLl9pdixpPXRoaXMuX2NvdW50ZXI7byYmKGk9dGhpcy5fY291bnRlcj1vLnNsaWNlKDApLHRoaXMuX2l2PXZvaWQgMCk7dmFyIGE9aS5zbGljZSgwKTtuLmVuY3J5cHRCbG9jayhhLDApLGlbci0xXT1pW3ItMV0rMXwwO2Zvcih2YXIgcz0wO3M8cjtzKyspdFtlK3NdXj1hW3NdfX0pO3JldHVybiBlLkRlY3J5cHRvcj1uLGV9KCksdC5tb2RlLkNUUn0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUyLCIuL2NvcmUiOjUzfV0sNjU6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5tb2RlLkVDQj1mdW5jdGlvbigpe3ZhciBlPXQubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtyZXR1cm4gZS5FbmNyeXB0b3I9ZS5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2NpcGhlci5lbmNyeXB0QmxvY2sodCxlKX19KSxlLkRlY3J5cHRvcj1lLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7dGhpcy5fY2lwaGVyLmRlY3J5cHRCbG9jayh0LGUpfX0pLGV9KCksdC5tb2RlLkVDQn0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUyLCIuL2NvcmUiOjUzfV0sNjY6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5tb2RlLk9GQj1mdW5jdGlvbigpe3ZhciBlPXQubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKSxuPWUuRW5jcnlwdG9yPWUuZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLl9jaXBoZXIscj1uLmJsb2NrU2l6ZSxvPXRoaXMuX2l2LGk9dGhpcy5fa2V5c3RyZWFtO28mJihpPXRoaXMuX2tleXN0cmVhbT1vLnNsaWNlKDApLHRoaXMuX2l2PXZvaWQgMCksbi5lbmNyeXB0QmxvY2soaSwwKTtmb3IodmFyIGE9MDthPHI7YSsrKXRbZSthXV49aVthXX19KTtyZXR1cm4gZS5EZWNyeXB0b3I9bixlfSgpLHQubW9kZS5PRkJ9KX0seyIuL2NpcGhlci1jb3JlIjo1MiwiLi9jb3JlIjo1M31dLDY3OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9jaXBoZXItY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIHQucGFkLkFuc2lYOTIzPXtwYWQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnNpZ0J5dGVzLHI9NCplLG89ci1uJXIsaT1uK28tMTt0LmNsYW1wKCksdC53b3Jkc1tpPj4+Ml18PW88PDI0LWklNCo4LHQuc2lnQnl0ZXMrPW99LHVucGFkOmZ1bmN0aW9uKHQpe3ZhciBlPTI1NSZ0LndvcmRzW3Quc2lnQnl0ZXMtMT4+PjJdO3Quc2lnQnl0ZXMtPWV9fSx0LnBhZC5BbnNpeDkyM30pfSx7Ii4vY2lwaGVyLWNvcmUiOjUyLCIuL2NvcmUiOjUzfV0sNjg6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQuSXNvMTAxMjY9e3BhZDpmdW5jdGlvbihlLG4pe3ZhciByPTQqbixvPXItZS5zaWdCeXRlcyVyO2UuY29uY2F0KHQubGliLldvcmRBcnJheS5yYW5kb20oby0xKSkuY29uY2F0KHQubGliLldvcmRBcnJheS5jcmVhdGUoW288PDI0XSwxKSl9LHVucGFkOmZ1bmN0aW9uKHQpe3ZhciBlPTI1NSZ0LndvcmRzW3Quc2lnQnl0ZXMtMT4+PjJdO3Quc2lnQnl0ZXMtPWV9fSx0LnBhZC5Jc28xMDEyNn0pfSx7Ii4vY2lwaGVyLWNvcmUiOjUyLCIuL2NvcmUiOjUzfV0sNjk6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQuSXNvOTc5NzE9e3BhZDpmdW5jdGlvbihlLG4pe2UuY29uY2F0KHQubGliLldvcmRBcnJheS5jcmVhdGUoWzIxNDc0ODM2NDhdLDEpKSx0LnBhZC5aZXJvUGFkZGluZy5wYWQoZSxuKX0sdW5wYWQ6ZnVuY3Rpb24oZSl7dC5wYWQuWmVyb1BhZGRpbmcudW5wYWQoZSksZS5zaWdCeXRlcy0tfX0sdC5wYWQuSXNvOTc5NzF9KX0seyIuL2NpcGhlci1jb3JlIjo1MiwiLi9jb3JlIjo1M31dLDcwOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9jaXBoZXItY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIHQucGFkLk5vUGFkZGluZz17cGFkOmZ1bmN0aW9uKCl7fSx1bnBhZDpmdW5jdGlvbigpe319LHQucGFkLk5vUGFkZGluZ30pfSx7Ii4vY2lwaGVyLWNvcmUiOjUyLCIuL2NvcmUiOjUzfV0sNzE6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2NpcGhlci1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gdC5wYWQuWmVyb1BhZGRpbmc9e3BhZDpmdW5jdGlvbih0LGUpe3ZhciBuPTQqZTt0LmNsYW1wKCksdC5zaWdCeXRlcys9bi0odC5zaWdCeXRlcyVufHxuKX0sdW5wYWQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQud29yZHMsbj10LnNpZ0J5dGVzLTE7IShlW24+Pj4yXT4+PjI0LW4lNCo4JjI1NSk7KW4tLTt0LnNpZ0J5dGVzPW4rMX19LHQucGFkLlplcm9QYWRkaW5nfSl9LHsiLi9jaXBoZXItY29yZSI6NTIsIi4vY29yZSI6NTN9XSw3MjpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9zaGExIiksdCgiLi9obWFjIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9zaGExIiwiLi9obWFjIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10LG49ZS5saWIscj1uLkJhc2Usbz1uLldvcmRBcnJheSxpPWUuYWxnbyxhPWkuU0hBMSxzPWkuSE1BQyxjPWkuUEJLREYyPXIuZXh0ZW5kKHtjZmc6ci5leHRlbmQoe2tleVNpemU6NCxoYXNoZXI6YSxpdGVyYXRpb25zOjF9KSxpbml0OmZ1bmN0aW9uKHQpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZCh0KX0sY29tcHV0ZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLmNmZyxyPXMuY3JlYXRlKG4uaGFzaGVyLHQpLGk9by5jcmVhdGUoKSxhPW8uY3JlYXRlKFsxXSksYz1pLndvcmRzLHU9YS53b3JkcyxmPW4ua2V5U2l6ZSxsPW4uaXRlcmF0aW9ucztjLmxlbmd0aDxmOyl7dmFyIHA9ci51cGRhdGUoZSkuZmluYWxpemUoYSk7ci5yZXNldCgpO2Zvcih2YXIgaD1wLndvcmRzLGQ9aC5sZW5ndGgsbT1wLHk9MTt5PGw7eSsrKXttPXIuZmluYWxpemUobSksci5yZXNldCgpO2Zvcih2YXIgZz1tLndvcmRzLHY9MDt2PGQ7disrKWhbdl1ePWdbdl19aS5jb25jYXQocCksdVswXSsrfXJldHVybiBpLnNpZ0J5dGVzPTQqZixpfX0pO2UuUEJLREYyPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gYy5jcmVhdGUobikuY29tcHV0ZSh0LGUpfX0oKSx0LlBCS0RGMn0pfSx7Ii4vY29yZSI6NTMsIi4vaG1hYyI6NTgsIi4vc2hhMSI6Nzd9XSw3MzpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9lbmMtYmFzZTY0IiksdCgiLi9tZDUiKSx0KCIuL2V2cGtkZiIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2VuYy1iYXNlNjQiLCIuL21kNSIsIi4vZXZwa2RmIiwiLi9jaXBoZXItY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe2Zvcih2YXIgdD10aGlzLl9YLGU9dGhpcy5fQyxuPTA7bjw4O24rKylpW25dPWVbbl07ZVswXT1lWzBdKzEyOTUzMDc1OTcrdGhpcy5fYnwwLGVbMV09ZVsxXSszNTQ1MDUyMzcxKyhlWzBdPj4+MDxpWzBdPj4+MD8xOjApfDAsZVsyXT1lWzJdKzg4NjI2MzA5MisoZVsxXT4+PjA8aVsxXT4+PjA/MTowKXwwLGVbM109ZVszXSsxMjk1MzA3NTk3KyhlWzJdPj4+MDxpWzJdPj4+MD8xOjApfDAsZVs0XT1lWzRdKzM1NDUwNTIzNzErKGVbM10+Pj4wPGlbM10+Pj4wPzE6MCl8MCxlWzVdPWVbNV0rODg2MjYzMDkyKyhlWzRdPj4+MDxpWzRdPj4+MD8xOjApfDAsZVs2XT1lWzZdKzEyOTUzMDc1OTcrKGVbNV0+Pj4wPGlbNV0+Pj4wPzE6MCl8MCxlWzddPWVbN10rMzU0NTA1MjM3MSsoZVs2XT4+PjA8aVs2XT4+PjA/MTowKXwwLHRoaXMuX2I9ZVs3XT4+PjA8aVs3XT4+PjA/MTowO2ZvcihuPTA7bjw4O24rKyl7dmFyIHI9dFtuXStlW25dLG89NjU1MzUmcixzPXI+Pj4xNixjPSgobypvPj4+MTcpK28qcz4+PjE1KStzKnMsdT0oKDQyOTQ5MDE3NjAmcikqcnwwKSsoKDY1NTM1JnIpKnJ8MCk7YVtuXT1jXnV9dFswXT1hWzBdKyhhWzddPDwxNnxhWzddPj4+MTYpKyhhWzZdPDwxNnxhWzZdPj4+MTYpfDAsdFsxXT1hWzFdKyhhWzBdPDw4fGFbMF0+Pj4yNCkrYVs3XXwwLHRbMl09YVsyXSsoYVsxXTw8MTZ8YVsxXT4+PjE2KSsoYVswXTw8MTZ8YVswXT4+PjE2KXwwLHRbM109YVszXSsoYVsyXTw8OHxhWzJdPj4+MjQpK2FbMV18MCx0WzRdPWFbNF0rKGFbM108PDE2fGFbM10+Pj4xNikrKGFbMl08PDE2fGFbMl0+Pj4xNil8MCx0WzVdPWFbNV0rKGFbNF08PDh8YVs0XT4+PjI0KSthWzNdfDAsdFs2XT1hWzZdKyhhWzVdPDwxNnxhWzVdPj4+MTYpKyhhWzRdPDwxNnxhWzRdPj4+MTYpfDAsdFs3XT1hWzddKyhhWzZdPDw4fGFbNl0+Pj4yNCkrYVs1XXwwfXZhciBuPXQscj1uLmxpYi5TdHJlYW1DaXBoZXIsbz1bXSxpPVtdLGE9W10scz1uLmFsZ28uUmFiYml0TGVnYWN5PXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2tleS53b3JkcyxuPXRoaXMuY2ZnLml2LHI9dGhpcy5fWD1bdFswXSx0WzNdPDwxNnx0WzJdPj4+MTYsdFsxXSx0WzBdPDwxNnx0WzNdPj4+MTYsdFsyXSx0WzFdPDwxNnx0WzBdPj4+MTYsdFszXSx0WzJdPDwxNnx0WzFdPj4+MTZdLG89dGhpcy5fQz1bdFsyXTw8MTZ8dFsyXT4+PjE2LDQyOTQ5MDE3NjAmdFswXXw2NTUzNSZ0WzFdLHRbM108PDE2fHRbM10+Pj4xNiw0Mjk0OTAxNzYwJnRbMV18NjU1MzUmdFsyXSx0WzBdPDwxNnx0WzBdPj4+MTYsNDI5NDkwMTc2MCZ0WzJdfDY1NTM1JnRbM10sdFsxXTw8MTZ8dFsxXT4+PjE2LDQyOTQ5MDE3NjAmdFszXXw2NTUzNSZ0WzBdXTt0aGlzLl9iPTA7Zm9yKHZhciBpPTA7aTw0O2krKyllLmNhbGwodGhpcyk7Zm9yKGk9MDtpPDg7aSsrKW9baV1ePXJbaSs0JjddO2lmKG4pe3ZhciBhPW4ud29yZHMscz1hWzBdLGM9YVsxXSx1PTE2NzExOTM1JihzPDw4fHM+Pj4yNCl8NDI3ODI1NTM2MCYoczw8MjR8cz4+PjgpLGY9MTY3MTE5MzUmKGM8PDh8Yz4+PjI0KXw0Mjc4MjU1MzYwJihjPDwyNHxjPj4+OCksbD11Pj4+MTZ8NDI5NDkwMTc2MCZmLHA9Zjw8MTZ8NjU1MzUmdTtvWzBdXj11LG9bMV1ePWwsb1syXV49ZixvWzNdXj1wLG9bNF1ePXUsb1s1XV49bCxvWzZdXj1mLG9bN11ePXA7Zm9yKGk9MDtpPDQ7aSsrKWUuY2FsbCh0aGlzKX19LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LG4pe3ZhciByPXRoaXMuX1g7ZS5jYWxsKHRoaXMpLG9bMF09clswXV5yWzVdPj4+MTZeclszXTw8MTYsb1sxXT1yWzJdXnJbN10+Pj4xNl5yWzVdPDwxNixvWzJdPXJbNF1eclsxXT4+PjE2XnJbN108PDE2LG9bM109cls2XV5yWzNdPj4+MTZeclsxXTw8MTY7Zm9yKHZhciBpPTA7aTw0O2krKylvW2ldPTE2NzExOTM1JihvW2ldPDw4fG9baV0+Pj4yNCl8NDI3ODI1NTM2MCYob1tpXTw8MjR8b1tpXT4+PjgpLHRbbitpXV49b1tpXX0sYmxvY2tTaXplOjQsaXZTaXplOjJ9KTtuLlJhYmJpdExlZ2FjeT1yLl9jcmVhdGVIZWxwZXIocyl9KCksdC5SYWJiaXRMZWdhY3l9KX0seyIuL2NpcGhlci1jb3JlIjo1MiwiLi9jb3JlIjo1MywiLi9lbmMtYmFzZTY0Ijo1NCwiLi9ldnBrZGYiOjU2LCIuL21kNSI6NjF9XSw3NDpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9lbmMtYmFzZTY0IiksdCgiLi9tZDUiKSx0KCIuL2V2cGtkZiIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2VuYy1iYXNlNjQiLCIuL21kNSIsIi4vZXZwa2RmIiwiLi9jaXBoZXItY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe2Zvcih2YXIgdD10aGlzLl9YLGU9dGhpcy5fQyxuPTA7bjw4O24rKylpW25dPWVbbl07ZVswXT1lWzBdKzEyOTUzMDc1OTcrdGhpcy5fYnwwLGVbMV09ZVsxXSszNTQ1MDUyMzcxKyhlWzBdPj4+MDxpWzBdPj4+MD8xOjApfDAsZVsyXT1lWzJdKzg4NjI2MzA5MisoZVsxXT4+PjA8aVsxXT4+PjA/MTowKXwwLGVbM109ZVszXSsxMjk1MzA3NTk3KyhlWzJdPj4+MDxpWzJdPj4+MD8xOjApfDAsZVs0XT1lWzRdKzM1NDUwNTIzNzErKGVbM10+Pj4wPGlbM10+Pj4wPzE6MCl8MCxlWzVdPWVbNV0rODg2MjYzMDkyKyhlWzRdPj4+MDxpWzRdPj4+MD8xOjApfDAsZVs2XT1lWzZdKzEyOTUzMDc1OTcrKGVbNV0+Pj4wPGlbNV0+Pj4wPzE6MCl8MCxlWzddPWVbN10rMzU0NTA1MjM3MSsoZVs2XT4+PjA8aVs2XT4+PjA/MTowKXwwLHRoaXMuX2I9ZVs3XT4+PjA8aVs3XT4+PjA/MTowO2ZvcihuPTA7bjw4O24rKyl7dmFyIHI9dFtuXStlW25dLG89NjU1MzUmcixzPXI+Pj4xNixjPSgobypvPj4+MTcpK28qcz4+PjE1KStzKnMsdT0oKDQyOTQ5MDE3NjAmcikqcnwwKSsoKDY1NTM1JnIpKnJ8MCk7YVtuXT1jXnV9dFswXT1hWzBdKyhhWzddPDwxNnxhWzddPj4+MTYpKyhhWzZdPDwxNnxhWzZdPj4+MTYpfDAsdFsxXT1hWzFdKyhhWzBdPDw4fGFbMF0+Pj4yNCkrYVs3XXwwLHRbMl09YVsyXSsoYVsxXTw8MTZ8YVsxXT4+PjE2KSsoYVswXTw8MTZ8YVswXT4+PjE2KXwwLHRbM109YVszXSsoYVsyXTw8OHxhWzJdPj4+MjQpK2FbMV18MCx0WzRdPWFbNF0rKGFbM108PDE2fGFbM10+Pj4xNikrKGFbMl08PDE2fGFbMl0+Pj4xNil8MCx0WzVdPWFbNV0rKGFbNF08PDh8YVs0XT4+PjI0KSthWzNdfDAsdFs2XT1hWzZdKyhhWzVdPDwxNnxhWzVdPj4+MTYpKyhhWzRdPDwxNnxhWzRdPj4+MTYpfDAsdFs3XT1hWzddKyhhWzZdPDw4fGFbNl0+Pj4yNCkrYVs1XXwwfXZhciBuPXQscj1uLmxpYi5TdHJlYW1DaXBoZXIsbz1bXSxpPVtdLGE9W10scz1uLmFsZ28uUmFiYml0PXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9rZXkud29yZHMsbj10aGlzLmNmZy5pdixyPTA7cjw0O3IrKyl0W3JdPTE2NzExOTM1Jih0W3JdPDw4fHRbcl0+Pj4yNCl8NDI3ODI1NTM2MCYodFtyXTw8MjR8dFtyXT4+PjgpO3ZhciBvPXRoaXMuX1g9W3RbMF0sdFszXTw8MTZ8dFsyXT4+PjE2LHRbMV0sdFswXTw8MTZ8dFszXT4+PjE2LHRbMl0sdFsxXTw8MTZ8dFswXT4+PjE2LHRbM10sdFsyXTw8MTZ8dFsxXT4+PjE2XSxpPXRoaXMuX0M9W3RbMl08PDE2fHRbMl0+Pj4xNiw0Mjk0OTAxNzYwJnRbMF18NjU1MzUmdFsxXSx0WzNdPDwxNnx0WzNdPj4+MTYsNDI5NDkwMTc2MCZ0WzFdfDY1NTM1JnRbMl0sdFswXTw8MTZ8dFswXT4+PjE2LDQyOTQ5MDE3NjAmdFsyXXw2NTUzNSZ0WzNdLHRbMV08PDE2fHRbMV0+Pj4xNiw0Mjk0OTAxNzYwJnRbM118NjU1MzUmdFswXV07dGhpcy5fYj0wO2ZvcihyPTA7cjw0O3IrKyllLmNhbGwodGhpcyk7Zm9yKHI9MDtyPDg7cisrKWlbcl1ePW9bcis0JjddO2lmKG4pe3ZhciBhPW4ud29yZHMscz1hWzBdLGM9YVsxXSx1PTE2NzExOTM1JihzPDw4fHM+Pj4yNCl8NDI3ODI1NTM2MCYoczw8MjR8cz4+PjgpLGY9MTY3MTE5MzUmKGM8PDh8Yz4+PjI0KXw0Mjc4MjU1MzYwJihjPDwyNHxjPj4+OCksbD11Pj4+MTZ8NDI5NDkwMTc2MCZmLHA9Zjw8MTZ8NjU1MzUmdTtpWzBdXj11LGlbMV1ePWwsaVsyXV49ZixpWzNdXj1wLGlbNF1ePXUsaVs1XV49bCxpWzZdXj1mLGlbN11ePXA7Zm9yKHI9MDtyPDQ7cisrKWUuY2FsbCh0aGlzKX19LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LG4pe3ZhciByPXRoaXMuX1g7ZS5jYWxsKHRoaXMpLG9bMF09clswXV5yWzVdPj4+MTZeclszXTw8MTYsb1sxXT1yWzJdXnJbN10+Pj4xNl5yWzVdPDwxNixvWzJdPXJbNF1eclsxXT4+PjE2XnJbN108PDE2LG9bM109cls2XV5yWzNdPj4+MTZeclsxXTw8MTY7Zm9yKHZhciBpPTA7aTw0O2krKylvW2ldPTE2NzExOTM1JihvW2ldPDw4fG9baV0+Pj4yNCl8NDI3ODI1NTM2MCYob1tpXTw8MjR8b1tpXT4+PjgpLHRbbitpXV49b1tpXX0sYmxvY2tTaXplOjQsaXZTaXplOjJ9KTtuLlJhYmJpdD1yLl9jcmVhdGVIZWxwZXIocyl9KCksdC5SYWJiaXR9KX0seyIuL2NpcGhlci1jb3JlIjo1MiwiLi9jb3JlIjo1MywiLi9lbmMtYmFzZTY0Ijo1NCwiLi9ldnBrZGYiOjU2LCIuL21kNSI6NjF9XSw3NTpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9lbmMtYmFzZTY0IiksdCgiLi9tZDUiKSx0KCIuL2V2cGtkZiIpLHQoIi4vY2lwaGVyLWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL2VuYy1iYXNlNjQiLCIuL21kNSIsIi4vZXZwa2RmIiwiLi9jaXBoZXItY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe2Zvcih2YXIgdD10aGlzLl9TLGU9dGhpcy5faSxuPXRoaXMuX2oscj0wLG89MDtvPDQ7bysrKXtuPShuK3RbZT0oZSsxKSUyNTZdKSUyNTY7dmFyIGk9dFtlXTt0W2VdPXRbbl0sdFtuXT1pLHJ8PXRbKHRbZV0rdFtuXSklMjU2XTw8MjQtOCpvfXJldHVybiB0aGlzLl9pPWUsdGhpcy5faj1uLHJ9dmFyIG49dCxyPW4ubGliLlN0cmVhbUNpcGhlcixvPW4uYWxnbyxpPW8uUkM0PXIuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9rZXksZT10LndvcmRzLG49dC5zaWdCeXRlcyxyPXRoaXMuX1M9W10sbz0wO288MjU2O28rKylyW29dPW87bz0wO2Zvcih2YXIgaT0wO288MjU2O28rKyl7dmFyIGE9byVuLHM9ZVthPj4+Ml0+Pj4yNC1hJTQqOCYyNTU7aT0oaStyW29dK3MpJTI1Njt2YXIgYz1yW29dO3Jbb109cltpXSxyW2ldPWN9dGhpcy5faT10aGlzLl9qPTB9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LG4pe3Rbbl1ePWUuY2FsbCh0aGlzKX0sa2V5U2l6ZTo4LGl2U2l6ZTowfSk7bi5SQzQ9ci5fY3JlYXRlSGVscGVyKGkpO3ZhciBhPW8uUkM0RHJvcD1pLmV4dGVuZCh7Y2ZnOmkuY2ZnLmV4dGVuZCh7ZHJvcDoxOTJ9KSxfZG9SZXNldDpmdW5jdGlvbigpe2kuX2RvUmVzZXQuY2FsbCh0aGlzKTtmb3IodmFyIHQ9dGhpcy5jZmcuZHJvcDt0PjA7dC0tKWUuY2FsbCh0aGlzKX19KTtuLlJDNERyb3A9ci5fY3JlYXRlSGVscGVyKGEpfSgpLHQuUkM0fSl9LHsiLi9jaXBoZXItY29yZSI6NTIsIi4vY29yZSI6NTMsIi4vZW5jLWJhc2U2NCI6NTQsIi4vZXZwa2RmIjo1NiwiLi9tZDUiOjYxfV0sNzY6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiBuKHQsZSxuKXtyZXR1cm4gdF5lXm59ZnVuY3Rpb24gcih0LGUsbil7cmV0dXJuIHQmZXx+dCZufWZ1bmN0aW9uIG8odCxlLG4pe3JldHVybih0fH5lKV5ufWZ1bmN0aW9uIGkodCxlLG4pe3JldHVybiB0Jm58ZSZ+bn1mdW5jdGlvbiBhKHQsZSxuKXtyZXR1cm4gdF4oZXx+bil9ZnVuY3Rpb24gcyh0LGUpe3JldHVybiB0PDxlfHQ+Pj4zMi1lfXZhciBjPXQsdT1jLmxpYixmPXUuV29yZEFycmF5LGw9dS5IYXNoZXIscD1jLmFsZ28saD1mLmNyZWF0ZShbMCwxLDIsMyw0LDUsNiw3LDgsOSwxMCwxMSwxMiwxMywxNCwxNSw3LDQsMTMsMSwxMCw2LDE1LDMsMTIsMCw5LDUsMiwxNCwxMSw4LDMsMTAsMTQsNCw5LDE1LDgsMSwyLDcsMCw2LDEzLDExLDUsMTIsMSw5LDExLDEwLDAsOCwxMiw0LDEzLDMsNywxNSwxNCw1LDYsMiw0LDAsNSw5LDcsMTIsMiwxMCwxNCwxLDMsOCwxMSw2LDE1LDEzXSksZD1mLmNyZWF0ZShbNSwxNCw3LDAsOSwyLDExLDQsMTMsNiwxNSw4LDEsMTAsMywxMiw2LDExLDMsNywwLDEzLDUsMTAsMTQsMTUsOCwxMiw0LDksMSwyLDE1LDUsMSwzLDcsMTQsNiw5LDExLDgsMTIsMiwxMCwwLDQsMTMsOCw2LDQsMSwzLDExLDE1LDAsNSwxMiwyLDEzLDksNywxMCwxNCwxMiwxNSwxMCw0LDEsNSw4LDcsNiwyLDEzLDE0LDAsMyw5LDExXSksbT1mLmNyZWF0ZShbMTEsMTQsMTUsMTIsNSw4LDcsOSwxMSwxMywxNCwxNSw2LDcsOSw4LDcsNiw4LDEzLDExLDksNywxNSw3LDEyLDE1LDksMTEsNywxMywxMiwxMSwxMyw2LDcsMTQsOSwxMywxNSwxNCw4LDEzLDYsNSwxMiw3LDUsMTEsMTIsMTQsMTUsMTQsMTUsOSw4LDksMTQsNSw2LDgsNiw1LDEyLDksMTUsNSwxMSw2LDgsMTMsMTIsNSwxMiwxMywxNCwxMSw4LDUsNl0pLHk9Zi5jcmVhdGUoWzgsOSw5LDExLDEzLDE1LDE1LDUsNyw3LDgsMTEsMTQsMTQsMTIsNiw5LDEzLDE1LDcsMTIsOCw5LDExLDcsNywxMiw3LDYsMTUsMTMsMTEsOSw3LDE1LDExLDgsNiw2LDE0LDEyLDEzLDUsMTQsMTMsMTMsNyw1LDE1LDUsOCwxMSwxNCwxNCw2LDE0LDYsOSwxMiw5LDEyLDUsMTUsOCw4LDUsMTIsOSwxMiw1LDE0LDYsOCwxMyw2LDUsMTUsMTMsMTEsMTFdKSxnPWYuY3JlYXRlKFswLDE1MTg1MDAyNDksMTg1OTc3NTM5MywyNDAwOTU5NzA4LDI4NDA4NTM4MzhdKSx2PWYuY3JlYXRlKFsxMzUyODI5OTI2LDE1NDg2MDM2ODQsMTgzNjA3MjY5MSwyMDUzOTk0MjE3LDBdKSxiPXAuUklQRU1EMTYwPWwuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9Zi5jcmVhdGUoWzE3MzI1ODQxOTMsNDAyMzIzMzQxNywyNTYyMzgzMTAyLDI3MTczMzg3OCwzMjg1Mzc3NTIwXSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe2Zvcih2YXIgYz0wO2M8MTY7YysrKXt2YXIgdT1lK2MsZj10W3VdO3RbdV09MTY3MTE5MzUmKGY8PDh8Zj4+PjI0KXw0Mjc4MjU1MzYwJihmPDwyNHxmPj4+OCl9dmFyIGwscCxiLF8sdyx4LGssQixTLEEsQz10aGlzLl9oYXNoLndvcmRzLEY9Zy53b3JkcyxPPXYud29yZHMsTj1oLndvcmRzLFQ9ZC53b3JkcyxJPW0ud29yZHMsUD15LndvcmRzO3g9bD1DWzBdLGs9cD1DWzFdLEI9Yj1DWzJdLFM9Xz1DWzNdLEE9dz1DWzRdO3ZhciBEO2ZvcihjPTA7Yzw4MDtjKz0xKUQ9bCt0W2UrTltjXV18MCxEKz1jPDE2P24ocCxiLF8pK0ZbMF06YzwzMj9yKHAsYixfKStGWzFdOmM8NDg/byhwLGIsXykrRlsyXTpjPDY0P2kocCxiLF8pK0ZbM106YShwLGIsXykrRls0XSxEPShEPXMoRHw9MCxJW2NdKSkrd3wwLGw9dyx3PV8sXz1zKGIsMTApLGI9cCxwPUQsRD14K3RbZStUW2NdXXwwLEQrPWM8MTY/YShrLEIsUykrT1swXTpjPDMyP2koayxCLFMpK09bMV06Yzw0OD9vKGssQixTKStPWzJdOmM8NjQ/cihrLEIsUykrT1szXTpuKGssQixTKStPWzRdLEQ9KEQ9cyhEfD0wLFBbY10pKStBfDAseD1BLEE9UyxTPXMoQiwxMCksQj1rLGs9RDtEPUNbMV0rYitTfDAsQ1sxXT1DWzJdK18rQXwwLENbMl09Q1szXSt3K3h8MCxDWzNdPUNbNF0rbCtrfDAsQ1s0XT1DWzBdK3ArQnwwLENbMF09RH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9kYXRhLGU9dC53b3JkcyxuPTgqdGhpcy5fbkRhdGFCeXRlcyxyPTgqdC5zaWdCeXRlcztlW3I+Pj41XXw9MTI4PDwyNC1yJTMyLGVbMTQrKHIrNjQ+Pj45PDw0KV09MTY3MTE5MzUmKG48PDh8bj4+PjI0KXw0Mjc4MjU1MzYwJihuPDwyNHxuPj4+OCksdC5zaWdCeXRlcz00KihlLmxlbmd0aCsxKSx0aGlzLl9wcm9jZXNzKCk7Zm9yKHZhciBvPXRoaXMuX2hhc2gsaT1vLndvcmRzLGE9MDthPDU7YSsrKXt2YXIgcz1pW2FdO2lbYV09MTY3MTE5MzUmKHM8PDh8cz4+PjI0KXw0Mjc4MjU1MzYwJihzPDwyNHxzPj4+OCl9cmV0dXJuIG99LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9bC5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0Ll9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKSx0fX0pO2MuUklQRU1EMTYwPWwuX2NyZWF0ZUhlbHBlcihiKSxjLkhtYWNSSVBFTUQxNjA9bC5fY3JlYXRlSG1hY0hlbHBlcihiKX0oTWF0aCksdC5SSVBFTUQxNjB9KX0seyIuL2NvcmUiOjUzfV0sNzc6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQsbj1lLmxpYixyPW4uV29yZEFycmF5LG89bi5IYXNoZXIsaT1bXSxhPWUuYWxnby5TSEExPW8uZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IHIuaW5pdChbMTczMjU4NDE5Myw0MDIzMjMzNDE3LDI1NjIzODMxMDIsMjcxNzMzODc4LDMyODUzNzc1MjBdKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuX2hhc2gud29yZHMscj1uWzBdLG89blsxXSxhPW5bMl0scz1uWzNdLGM9bls0XSx1PTA7dTw4MDt1Kyspe2lmKHU8MTYpaVt1XT0wfHRbZSt1XTtlbHNle3ZhciBmPWlbdS0zXV5pW3UtOF1eaVt1LTE0XV5pW3UtMTZdO2lbdV09Zjw8MXxmPj4+MzF9dmFyIGw9KHI8PDV8cj4+PjI3KStjK2lbdV07bCs9dTwyMD8xNTE4NTAwMjQ5KyhvJmF8fm8mcyk6dTw0MD8xODU5Nzc1MzkzKyhvXmFecyk6dTw2MD8obyZhfG8mc3xhJnMpLTE4OTQwMDc1ODg6KG9eYV5zKS04OTk0OTc1MTQsYz1zLHM9YSxhPW88PDMwfG8+Pj4yLG89cixyPWx9blswXT1uWzBdK3J8MCxuWzFdPW5bMV0rb3wwLG5bMl09blsyXSthfDAsblszXT1uWzNdK3N8MCxuWzRdPW5bNF0rY3wwfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2RhdGEsZT10LndvcmRzLG49OCp0aGlzLl9uRGF0YUJ5dGVzLHI9OCp0LnNpZ0J5dGVzO3JldHVybiBlW3I+Pj41XXw9MTI4PDwyNC1yJTMyLGVbMTQrKHIrNjQ+Pj45PDw0KV09TWF0aC5mbG9vcihuLzQyOTQ5NjcyOTYpLGVbMTUrKHIrNjQ+Pj45PDw0KV09bix0LnNpZ0J5dGVzPTQqZS5sZW5ndGgsdGhpcy5fcHJvY2VzcygpLHRoaXMuX2hhc2h9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9by5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0Ll9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKSx0fX0pO2UuU0hBMT1vLl9jcmVhdGVIZWxwZXIoYSksZS5IbWFjU0hBMT1vLl9jcmVhdGVIbWFjSGVscGVyKGEpfSgpLHQuU0hBMX0pfSx7Ii4vY29yZSI6NTN9XSw3ODpbZnVuY3Rpb24odCxlLG4peyFmdW5jdGlvbihyLG8saSl7Im9iamVjdCI9PXR5cGVvZiBuP2UuZXhwb3J0cz1uPW8odCgiLi9jb3JlIiksdCgiLi9zaGEyNTYiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL3NoYTI1NiJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIGU9dCxuPWUubGliLldvcmRBcnJheSxyPWUuYWxnbyxvPXIuU0hBMjU2LGk9ci5TSEEyMjQ9by5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgbi5pbml0KFszMjM4MzcxMDMyLDkxNDE1MDY2Myw4MTI3MDI5OTksNDE0NDkxMjY5Nyw0MjkwNzc1ODU3LDE3NTA2MDMwMjUsMTY5NDA3NjgzOSwzMjA0MDc1NDI4XSl9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9by5fZG9GaW5hbGl6ZS5jYWxsKHRoaXMpO3JldHVybiB0LnNpZ0J5dGVzLT00LHR9fSk7ZS5TSEEyMjQ9by5fY3JlYXRlSGVscGVyKGkpLGUuSG1hY1NIQTIyND1vLl9jcmVhdGVIbWFjSGVscGVyKGkpfSgpLHQuU0hBMjI0fSl9LHsiLi9jb3JlIjo1MywiLi9zaGEyNTYiOjc5fV0sNzk6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgbj10LHI9bi5saWIsbz1yLldvcmRBcnJheSxpPXIuSGFzaGVyLGE9bi5hbGdvLHM9W10sYz1bXTshZnVuY3Rpb24oKXtmdW5jdGlvbiB0KHQpe2Zvcih2YXIgbj1lLnNxcnQodCkscj0yO3I8PW47cisrKWlmKCEodCVyKSlyZXR1cm4hMTtyZXR1cm4hMH1mdW5jdGlvbiBuKHQpe3JldHVybiA0Mjk0OTY3Mjk2Kih0LSgwfHQpKXwwfWZvcih2YXIgcj0yLG89MDtvPDY0Oyl0KHIpJiYobzw4JiYoc1tvXT1uKGUucG93KHIsLjUpKSksY1tvXT1uKGUucG93KHIsMS8zKSksbysrKSxyKyt9KCk7dmFyIHU9W10sZj1hLlNIQTI1Nj1pLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBvLmluaXQocy5zbGljZSgwKSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLl9oYXNoLndvcmRzLHI9blswXSxvPW5bMV0saT1uWzJdLGE9blszXSxzPW5bNF0sZj1uWzVdLGw9bls2XSxwPW5bN10saD0wO2g8NjQ7aCsrKXtpZihoPDE2KXVbaF09MHx0W2UraF07ZWxzZXt2YXIgZD11W2gtMTVdLG09KGQ8PDI1fGQ+Pj43KV4oZDw8MTR8ZD4+PjE4KV5kPj4+Myx5PXVbaC0yXSxnPSh5PDwxNXx5Pj4+MTcpXih5PDwxM3x5Pj4+MTkpXnk+Pj4xMDt1W2hdPW0rdVtoLTddK2crdVtoLTE2XX12YXIgdj1yJm9eciZpXm8maSxiPShyPDwzMHxyPj4+MileKHI8PDE5fHI+Pj4xMyleKHI8PDEwfHI+Pj4yMiksXz1wKygoczw8MjZ8cz4+PjYpXihzPDwyMXxzPj4+MTEpXihzPDw3fHM+Pj4yNSkpKyhzJmZefnMmbCkrY1toXSt1W2hdO3A9bCxsPWYsZj1zLHM9YStffDAsYT1pLGk9byxvPXIscj1fKyhiK3YpfDB9blswXT1uWzBdK3J8MCxuWzFdPW5bMV0rb3wwLG5bMl09blsyXStpfDAsblszXT1uWzNdK2F8MCxuWzRdPW5bNF0rc3wwLG5bNV09bls1XStmfDAsbls2XT1uWzZdK2x8MCxuWzddPW5bN10rcHwwfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuX2RhdGEsbj10LndvcmRzLHI9OCp0aGlzLl9uRGF0YUJ5dGVzLG89OCp0LnNpZ0J5dGVzO3JldHVybiBuW28+Pj41XXw9MTI4PDwyNC1vJTMyLG5bMTQrKG8rNjQ+Pj45PDw0KV09ZS5mbG9vcihyLzQyOTQ5NjcyOTYpLG5bMTUrKG8rNjQ+Pj45PDw0KV09cix0LnNpZ0J5dGVzPTQqbi5sZW5ndGgsdGhpcy5fcHJvY2VzcygpLHRoaXMuX2hhc2h9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9aS5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0Ll9oYXNoPXRoaXMuX2hhc2guY2xvbmUoKSx0fX0pO24uU0hBMjU2PWkuX2NyZWF0ZUhlbHBlcihmKSxuLkhtYWNTSEEyNTY9aS5fY3JlYXRlSG1hY0hlbHBlcihmKX0oTWF0aCksdC5TSEEyNTZ9KX0seyIuL2NvcmUiOjUzfV0sODA6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4veDY0LWNvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL3g2NC1jb3JlIl0sbyk6byhyLkNyeXB0b0pTKX0odGhpcyxmdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIG49dCxyPW4ubGliLG89ci5Xb3JkQXJyYXksaT1yLkhhc2hlcixhPW4ueDY0LldvcmQscz1uLmFsZ28sYz1bXSx1PVtdLGY9W107IWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTEsZT0wLG49MDtuPDI0O24rKyl7Y1t0KzUqZV09KG4rMSkqKG4rMikvMiU2NDt2YXIgcj0oMip0KzMqZSklNTt0PWUlNSxlPXJ9Zm9yKHQ9MDt0PDU7dCsrKWZvcihlPTA7ZTw1O2UrKyl1W3QrNSplXT1lKygyKnQrMyplKSU1KjU7Zm9yKHZhciBvPTEsaT0wO2k8MjQ7aSsrKXtmb3IodmFyIHM9MCxsPTAscD0wO3A8NztwKyspe2lmKDEmbyl7dmFyIGg9KDE8PHApLTE7aDwzMj9sXj0xPDxoOnNePTE8PGgtMzJ9MTI4Jm8/bz1vPDwxXjExMzpvPDw9MX1mW2ldPWEuY3JlYXRlKHMsbCl9fSgpO3ZhciBsPVtdOyFmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8MjU7dCsrKWxbdF09YS5jcmVhdGUoKX0oKTt2YXIgcD1zLlNIQTM9aS5leHRlbmQoe2NmZzppLmNmZy5leHRlbmQoe291dHB1dExlbmd0aDo1MTJ9KSxfZG9SZXNldDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9zdGF0ZT1bXSxlPTA7ZTwyNTtlKyspdFtlXT1uZXcgYS5pbml0O3RoaXMuYmxvY2tTaXplPSgxNjAwLTIqdGhpcy5jZmcub3V0cHV0TGVuZ3RoKS8zMn0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuX3N0YXRlLHI9dGhpcy5ibG9ja1NpemUvMixvPTA7bzxyO28rKyl7dmFyIGk9dFtlKzIqb10sYT10W2UrMipvKzFdO2k9MTY3MTE5MzUmKGk8PDh8aT4+PjI0KXw0Mjc4MjU1MzYwJihpPDwyNHxpPj4+OCksYT0xNjcxMTkzNSYoYTw8OHxhPj4+MjQpfDQyNzgyNTUzNjAmKGE8PDI0fGE+Pj44KTsoRj1uW29dKS5oaWdoXj1hLEYubG93Xj1pfWZvcih2YXIgcz0wO3M8MjQ7cysrKXtmb3IodmFyIHA9MDtwPDU7cCsrKXtmb3IodmFyIGg9MCxkPTAsbT0wO208NTttKyspe2hePShGPW5bcCs1Km1dKS5oaWdoLGRePUYubG93fXZhciB5PWxbcF07eS5oaWdoPWgseS5sb3c9ZH1mb3IocD0wO3A8NTtwKyspe3ZhciBnPWxbKHArNCklNV0sdj1sWyhwKzEpJTVdLGI9di5oaWdoLF89di5sb3c7Zm9yKGg9Zy5oaWdoXihiPDwxfF8+Pj4zMSksZD1nLmxvd14oXzw8MXxiPj4+MzEpLG09MDttPDU7bSsrKXsoRj1uW3ArNSptXSkuaGlnaF49aCxGLmxvd149ZH19Zm9yKHZhciB3PTE7dzwyNTt3Kyspe3ZhciB4PShGPW5bd10pLmhpZ2gsaz1GLmxvdyxCPWNbd107aWYoQjwzMiloPXg8PEJ8az4+PjMyLUIsZD1rPDxCfHg+Pj4zMi1CO2Vsc2UgaD1rPDxCLTMyfHg+Pj42NC1CLGQ9eDw8Qi0zMnxrPj4+NjQtQjt2YXIgUz1sW3Vbd11dO1MuaGlnaD1oLFMubG93PWR9dmFyIEE9bFswXSxDPW5bMF07QS5oaWdoPUMuaGlnaCxBLmxvdz1DLmxvdztmb3IocD0wO3A8NTtwKyspZm9yKG09MDttPDU7bSsrKXt2YXIgRj1uW3c9cCs1Km1dLE89bFt3XSxOPWxbKHArMSklNSs1Km1dLFQ9bFsocCsyKSU1KzUqbV07Ri5oaWdoPU8uaGlnaF5+Ti5oaWdoJlQuaGlnaCxGLmxvdz1PLmxvd15+Ti5sb3cmVC5sb3d9Rj1uWzBdO3ZhciBJPWZbc107Ri5oaWdoXj1JLmhpZ2gsRi5sb3dePUkubG93fX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9kYXRhLG49dC53b3JkcyxyPSh0aGlzLl9uRGF0YUJ5dGVzLDgqdC5zaWdCeXRlcyksaT0zMip0aGlzLmJsb2NrU2l6ZTtuW3I+Pj41XXw9MTw8MjQtciUzMixuWyhlLmNlaWwoKHIrMSkvaSkqaT4+PjUpLTFdfD0xMjgsdC5zaWdCeXRlcz00Km4ubGVuZ3RoLHRoaXMuX3Byb2Nlc3MoKTtmb3IodmFyIGE9dGhpcy5fc3RhdGUscz10aGlzLmNmZy5vdXRwdXRMZW5ndGgvOCxjPXMvOCx1PVtdLGY9MDtmPGM7ZisrKXt2YXIgbD1hW2ZdLHA9bC5oaWdoLGg9bC5sb3c7cD0xNjcxMTkzNSYocDw8OHxwPj4+MjQpfDQyNzgyNTUzNjAmKHA8PDI0fHA+Pj44KSxoPTE2NzExOTM1JihoPDw4fGg+Pj4yNCl8NDI3ODI1NTM2MCYoaDw8MjR8aD4+PjgpLHUucHVzaChoKSx1LnB1c2gocCl9cmV0dXJuIG5ldyBvLmluaXQodSxzKX0sY2xvbmU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9aS5jbG9uZS5jYWxsKHRoaXMpLGU9dC5fc3RhdGU9dGhpcy5fc3RhdGUuc2xpY2UoMCksbj0wO248MjU7bisrKWVbbl09ZVtuXS5jbG9uZSgpO3JldHVybiB0fX0pO24uU0hBMz1pLl9jcmVhdGVIZWxwZXIocCksbi5IbWFjU0hBMz1pLl9jcmVhdGVIbWFjSGVscGVyKHApfShNYXRoKSx0LlNIQTN9KX0seyIuL2NvcmUiOjUzLCIuL3g2NC1jb3JlIjo4NH1dLDgxOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL3g2NC1jb3JlIiksdCgiLi9zaGE1MTIiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiLCIuL3g2NC1jb3JlIiwiLi9zaGE1MTIiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQsbj1lLng2NCxyPW4uV29yZCxvPW4uV29yZEFycmF5LGk9ZS5hbGdvLGE9aS5TSEE1MTIscz1pLlNIQTM4ND1hLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyBvLmluaXQoW25ldyByLmluaXQoMzQxODA3MDM2NSwzMjM4MzcxMDMyKSxuZXcgci5pbml0KDE2NTQyNzAyNTAsOTE0MTUwNjYzKSxuZXcgci5pbml0KDI0Mzg1MjkzNzAsODEyNzAyOTk5KSxuZXcgci5pbml0KDM1NTQ2MjM2MCw0MTQ0OTEyNjk3KSxuZXcgci5pbml0KDE3MzE0MDU0MTUsNDI5MDc3NTg1NyksbmV3IHIuaW5pdCgyMzk0MTgwMjMxLDE3NTA2MDMwMjUpLG5ldyByLmluaXQoMzY3NTAwODUyNSwxNjk0MDc2ODM5KSxuZXcgci5pbml0KDEyMDMwNjI4MTMsMzIwNDA3NTQyOCldKX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgdD1hLl9kb0ZpbmFsaXplLmNhbGwodGhpcyk7cmV0dXJuIHQuc2lnQnl0ZXMtPTE2LHR9fSk7ZS5TSEEzODQ9YS5fY3JlYXRlSGVscGVyKHMpLGUuSG1hY1NIQTM4ND1hLl9jcmVhdGVIbWFjSGVscGVyKHMpfSgpLHQuU0hBMzg0fSl9LHsiLi9jb3JlIjo1MywiLi9zaGE1MTIiOjgyLCIuL3g2NC1jb3JlIjo4NH1dLDgyOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHIsbyxpKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSx0KCIuL3g2NC1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi94NjQtY29yZSJdLG8pOm8oci5DcnlwdG9KUyl9KHRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe3JldHVybiBpLmNyZWF0ZS5hcHBseShpLGFyZ3VtZW50cyl9dmFyIG49dCxyPW4ubGliLkhhc2hlcixvPW4ueDY0LGk9by5Xb3JkLGE9by5Xb3JkQXJyYXkscz1uLmFsZ28sYz1bZSgxMTE2MzUyNDA4LDM2MDk3Njc0NTgpLGUoMTg5OTQ0NzQ0MSw2MDI4OTE3MjUpLGUoMzA0OTMyMzQ3MSwzOTY0NDg0Mzk5KSxlKDM5MjEwMDk1NzMsMjE3MzI5NTU0OCksZSg5NjE5ODcxNjMsNDA4MTYyODQ3MiksZSgxNTA4OTcwOTkzLDMwNTM4MzQyNjUpLGUoMjQ1MzYzNTc0OCwyOTM3NjcxNTc5KSxlKDI4NzA3NjMyMjEsMzY2NDYwOTU2MCksZSgzNjI0MzgxMDgwLDI3MzQ4ODMzOTQpLGUoMzEwNTk4NDAxLDExNjQ5OTY1NDIpLGUoNjA3MjI1Mjc4LDEzMjM2MTA3NjQpLGUoMTQyNjg4MTk4NywzNTkwMzA0OTk0KSxlKDE5MjUwNzgzODgsNDA2ODE4MjM4MyksZSgyMTYyMDc4MjA2LDk5MTMzNjExMyksZSgyNjE0ODg4MTAzLDYzMzgwMzMxNyksZSgzMjQ4MjIyNTgwLDM0Nzk3NzQ4NjgpLGUoMzgzNTM5MDQwMSwyNjY2NjEzNDU4KSxlKDQwMjIyMjQ3NzQsOTQ0NzExMTM5KSxlKDI2NDM0NzA3OCwyMzQxMjYyNzczKSxlKDYwNDgwNzYyOCwyMDA3ODAwOTMzKSxlKDc3MDI1NTk4MywxNDk1OTkwOTAxKSxlKDEyNDkxNTAxMjIsMTg1NjQzMTIzNSksZSgxNTU1MDgxNjkyLDMxNzUyMTgxMzIpLGUoMTk5NjA2NDk4NiwyMTk4OTUwODM3KSxlKDI1NTQyMjA4ODIsMzk5OTcxOTMzOSksZSgyODIxODM0MzQ5LDc2Njc4NDAxNiksZSgyOTUyOTk2ODA4LDI1NjY1OTQ4NzkpLGUoMzIxMDMxMzY3MSwzMjAzMzM3OTU2KSxlKDMzMzY1NzE4OTEsMTAzNDQ1NzAyNiksZSgzNTg0NTI4NzExLDI0NjY5NDg5MDEpLGUoMTEzOTI2OTkzLDM3NTgzMjYzODMpLGUoMzM4MjQxODk1LDE2ODcxNzkzNiksZSg2NjYzMDcyMDUsMTE4ODE3OTk2NCksZSg3NzM1Mjk5MTIsMTU0NjA0NTczNCksZSgxMjk0NzU3MzcyLDE1MjI4MDU0ODUpLGUoMTM5NjE4MjI5MSwyNjQzODMzODIzKSxlKDE2OTUxODM3MDAsMjM0MzUyNzM5MCksZSgxOTg2NjYxMDUxLDEwMTQ0Nzc0ODApLGUoMjE3NzAyNjM1MCwxMjA2NzU5MTQyKSxlKDI0NTY5NTYwMzcsMzQ0MDc3NjI3KSxlKDI3MzA0ODU5MjEsMTI5MDg2MzQ2MCksZSgyODIwMzAyNDExLDMxNTg0NTQyNzMpLGUoMzI1OTczMDgwMCwzNTA1OTUyNjU3KSxlKDMzNDU3NjQ3NzEsMTA2MjE3MDA4KSxlKDM1MTYwNjU4MTcsMzYwNjAwODM0NCksZSgzNjAwMzUyODA0LDE0MzI3MjU3NzYpLGUoNDA5NDU3MTkwOSwxNDY3MDMxNTk0KSxlKDI3NTQyMzM0NCw4NTExNjk3MjApLGUoNDMwMjI3NzM0LDMxMDA4MjM3NTIpLGUoNTA2OTQ4NjE2LDEzNjMyNTgxOTUpLGUoNjU5MDYwNTU2LDM3NTA2ODU1OTMpLGUoODgzOTk3ODc3LDM3ODUwNTAyODApLGUoOTU4MTM5NTcxLDMzMTgzMDc0MjcpLGUoMTMyMjgyMjIxOCwzODEyNzIzNDAzKSxlKDE1MzcwMDIwNjMsMjAwMzAzNDk5NSksZSgxNzQ3ODczNzc5LDM2MDIwMzY4OTkpLGUoMTk1NTU2MjIyMiwxNTc1OTkwMDEyKSxlKDIwMjQxMDQ4MTUsMTEyNTU5MjkyOCksZSgyMjI3NzMwNDUyLDI3MTY5MDQzMDYpLGUoMjM2MTg1MjQyNCw0NDI3NzYwNDQpLGUoMjQyODQzNjQ3NCw1OTM2OTgzNDQpLGUoMjc1NjczNDE4NywzNzMzMTEwMjQ5KSxlKDMyMDQwMzE0NzksMjk5OTM1MTU3MyksZSgzMzI5MzI1Mjk4LDM4MTU5MjA0MjcpLGUoMzM5MTU2OTYxNCwzOTI4MzgzOTAwKSxlKDM1MTUyNjcyNzEsNTY2MjgwNzExKSxlKDM5NDAxODc2MDYsMzQ1NDA2OTUzNCksZSg0MTE4NjMwMjcxLDQwMDAyMzk5OTIpLGUoMTE2NDE4NDc0LDE5MTQxMzg1NTQpLGUoMTc0MjkyNDIxLDI3MzEwNTUyNzApLGUoMjg5MzgwMzU2LDMyMDM5OTMwMDYpLGUoNDYwMzkzMjY5LDMyMDYyMDMxNSksZSg2ODU0NzE3MzMsNTg3NDk2ODM2KSxlKDg1MjE0Mjk3MSwxMDg2NzkyODUxKSxlKDEwMTcwMzYyOTgsMzY1NTQzMTAwKSxlKDExMjYwMDA1ODAsMjYxODI5NzY3NiksZSgxMjg4MDMzNDcwLDM0MDk4NTUxNTgpLGUoMTUwMTUwNTk0OCw0MjM0NTA5ODY2KSxlKDE2MDcxNjc5MTUsOTg3MTY3NDY4KSxlKDE4MTY0MDIzMTYsMTI0NjE4OTU5MSldLHU9W107IWZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDw4MDt0KyspdVt0XT1lKCl9KCk7dmFyIGY9cy5TSEE1MTI9ci5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7dGhpcy5faGFzaD1uZXcgYS5pbml0KFtuZXcgaS5pbml0KDE3NzkwMzM3MDMsNDA4OTIzNTcyMCksbmV3IGkuaW5pdCgzMTQ0MTM0Mjc3LDIyMjc4NzM1OTUpLG5ldyBpLmluaXQoMTAxMzkwNDI0Miw0MjcxMTc1NzIzKSxuZXcgaS5pbml0KDI3NzM0ODA3NjIsMTU5NTc1MDEyOSksbmV3IGkuaW5pdCgxMzU5ODkzMTE5LDI5MTc1NjUxMzcpLG5ldyBpLmluaXQoMjYwMDgyMjkyNCw3MjU1MTExOTkpLG5ldyBpLmluaXQoNTI4NzM0NjM1LDQyMTUzODk1NDcpLG5ldyBpLmluaXQoMTU0MTQ1OTIyNSwzMjcwMzMyMDkpXSl9LF9kb1Byb2Nlc3NCbG9jazpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLl9oYXNoLndvcmRzLHI9blswXSxvPW5bMV0saT1uWzJdLGE9blszXSxzPW5bNF0sZj1uWzVdLGw9bls2XSxwPW5bN10saD1yLmhpZ2gsZD1yLmxvdyxtPW8uaGlnaCx5PW8ubG93LGc9aS5oaWdoLHY9aS5sb3csYj1hLmhpZ2gsXz1hLmxvdyx3PXMuaGlnaCx4PXMubG93LGs9Zi5oaWdoLEI9Zi5sb3csUz1sLmhpZ2gsQT1sLmxvdyxDPXAuaGlnaCxGPXAubG93LE89aCxOPWQsVD1tLEk9eSxQPWcsRD12LFI9YixFPV8sTT13LEg9eCxqPWsscT1CLHo9UyxMPUEsVT1DLFc9RixKPTA7Sjw4MDtKKyspe3ZhciBLPXVbSl07aWYoSjwxNil2YXIgRz1LLmhpZ2g9MHx0W2UrMipKXSxYPUsubG93PTB8dFtlKzIqSisxXTtlbHNle3ZhciAkPXVbSi0xNV0sVj0kLmhpZ2gsWj0kLmxvdyxZPShWPj4+MXxaPDwzMSleKFY+Pj44fFo8PDI0KV5WPj4+NyxRPShaPj4+MXxWPDwzMSleKFo+Pj44fFY8PDI0KV4oWj4+Pjd8Vjw8MjUpLHR0PXVbSi0yXSxldD10dC5oaWdoLG50PXR0LmxvdyxydD0oZXQ+Pj4xOXxudDw8MTMpXihldDw8M3xudD4+PjI5KV5ldD4+PjYsb3Q9KG50Pj4+MTl8ZXQ8PDEzKV4obnQ8PDN8ZXQ+Pj4yOSleKG50Pj4+NnxldDw8MjYpLGl0PXVbSi03XSxhdD1pdC5oaWdoLHN0PWl0LmxvdyxjdD11W0otMTZdLHV0PWN0LmhpZ2gsZnQ9Y3QubG93O0c9KEc9KEc9WSthdCsoKFg9UStzdCk+Pj4wPFE+Pj4wPzE6MCkpK3J0KygoWD1YK290KT4+PjA8b3Q+Pj4wPzE6MCkpK3V0KygoWD1YK2Z0KT4+PjA8ZnQ+Pj4wPzE6MCk7Sy5oaWdoPUcsSy5sb3c9WH12YXIgbHQscHQ9TSZqXn5NJnosaHQ9SCZxXn5IJkwsZHQ9TyZUXk8mUF5UJlAsbXQ9TiZJXk4mRF5JJkQseXQ9KE8+Pj4yOHxOPDw0KV4oTzw8MzB8Tj4+PjIpXihPPDwyNXxOPj4+NyksZ3Q9KE4+Pj4yOHxPPDw0KV4oTjw8MzB8Tz4+PjIpXihOPDwyNXxPPj4+NyksdnQ9KE0+Pj4xNHxIPDwxOCleKE0+Pj4xOHxIPDwxNCleKE08PDIzfEg+Pj45KSxidD0oSD4+PjE0fE08PDE4KV4oSD4+PjE4fE08PDE0KV4oSDw8MjN8TT4+PjkpLF90PWNbSl0sd3Q9X3QuaGlnaCx4dD1fdC5sb3csa3Q9VSt2dCsoKGx0PVcrYnQpPj4+MDxXPj4+MD8xOjApLEJ0PWd0K210O1U9eixXPUwsej1qLEw9cSxqPU0scT1ILE09Uisoa3Q9KGt0PShrdD1rdCtwdCsoKGx0PWx0K2h0KT4+PjA8aHQ+Pj4wPzE6MCkpK3d0KygobHQ9bHQreHQpPj4+MDx4dD4+PjA/MTowKSkrRysoKGx0PWx0K1gpPj4+MDxYPj4+MD8xOjApKSsoKEg9RStsdHwwKT4+PjA8RT4+PjA/MTowKXwwLFI9UCxFPUQsUD1ULEQ9SSxUPU8sST1OLE89a3QrKHl0K2R0KyhCdD4+PjA8Z3Q+Pj4wPzE6MCkpKygoTj1sdCtCdHwwKT4+PjA8bHQ+Pj4wPzE6MCl8MH1kPXIubG93PWQrTixyLmhpZ2g9aCtPKyhkPj4+MDxOPj4+MD8xOjApLHk9by5sb3c9eStJLG8uaGlnaD1tK1QrKHk+Pj4wPEk+Pj4wPzE6MCksdj1pLmxvdz12K0QsaS5oaWdoPWcrUCsodj4+PjA8RD4+PjA/MTowKSxfPWEubG93PV8rRSxhLmhpZ2g9YitSKyhfPj4+MDxFPj4+MD8xOjApLHg9cy5sb3c9eCtILHMuaGlnaD13K00rKHg+Pj4wPEg+Pj4wPzE6MCksQj1mLmxvdz1CK3EsZi5oaWdoPWsraisoQj4+PjA8cT4+PjA/MTowKSxBPWwubG93PUErTCxsLmhpZ2g9Uyt6KyhBPj4+MDxMPj4+MD8xOjApLEY9cC5sb3c9RitXLHAuaGlnaD1DK1UrKEY+Pj4wPFc+Pj4wPzE6MCl9LF9kb0ZpbmFsaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fZGF0YSxlPXQud29yZHMsbj04KnRoaXMuX25EYXRhQnl0ZXMscj04KnQuc2lnQnl0ZXM7ZVtyPj4+NV18PTEyODw8MjQtciUzMixlWzMwKyhyKzEyOD4+PjEwPDw1KV09TWF0aC5mbG9vcihuLzQyOTQ5NjcyOTYpLGVbMzErKHIrMTI4Pj4+MTA8PDUpXT1uLHQuc2lnQnl0ZXM9NCplLmxlbmd0aCx0aGlzLl9wcm9jZXNzKCk7cmV0dXJuIHRoaXMuX2hhc2gudG9YMzIoKX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1yLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpLHR9LGJsb2NrU2l6ZTozMn0pO24uU0hBNTEyPXIuX2NyZWF0ZUhlbHBlcihmKSxuLkhtYWNTSEE1MTI9ci5fY3JlYXRlSG1hY0hlbHBlcihmKX0oKSx0LlNIQTUxMn0pfSx7Ii4vY29yZSI6NTMsIi4veDY0LWNvcmUiOjg0fV0sODM6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvLGkpeyJvYmplY3QiPT10eXBlb2Ygbj9lLmV4cG9ydHM9bj1vKHQoIi4vY29yZSIpLHQoIi4vZW5jLWJhc2U2NCIpLHQoIi4vbWQ1IiksdCgiLi9ldnBrZGYiKSx0KCIuL2NpcGhlci1jb3JlIikpOiJmdW5jdGlvbiI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFsiLi9jb3JlIiwiLi9lbmMtYmFzZTY0IiwiLi9tZDUiLCIuL2V2cGtkZiIsIi4vY2lwaGVyLWNvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe2Z1bmN0aW9uIGUodCxlKXt2YXIgbj0odGhpcy5fbEJsb2NrPj4+dF50aGlzLl9yQmxvY2spJmU7dGhpcy5fckJsb2NrXj1uLHRoaXMuX2xCbG9ja149bjw8dH1mdW5jdGlvbiBuKHQsZSl7dmFyIG49KHRoaXMuX3JCbG9jaz4+PnRedGhpcy5fbEJsb2NrKSZlO3RoaXMuX2xCbG9ja149bix0aGlzLl9yQmxvY2tePW48PHR9dmFyIHI9dCxvPXIubGliLGk9by5Xb3JkQXJyYXksYT1vLkJsb2NrQ2lwaGVyLHM9ci5hbGdvLGM9WzU3LDQ5LDQxLDMzLDI1LDE3LDksMSw1OCw1MCw0MiwzNCwyNiwxOCwxMCwyLDU5LDUxLDQzLDM1LDI3LDE5LDExLDMsNjAsNTIsNDQsMzYsNjMsNTUsNDcsMzksMzEsMjMsMTUsNyw2Miw1NCw0NiwzOCwzMCwyMiwxNCw2LDYxLDUzLDQ1LDM3LDI5LDIxLDEzLDUsMjgsMjAsMTIsNF0sdT1bMTQsMTcsMTEsMjQsMSw1LDMsMjgsMTUsNiwyMSwxMCwyMywxOSwxMiw0LDI2LDgsMTYsNywyNywyMCwxMywyLDQxLDUyLDMxLDM3LDQ3LDU1LDMwLDQwLDUxLDQ1LDMzLDQ4LDQ0LDQ5LDM5LDU2LDM0LDUzLDQ2LDQyLDUwLDM2LDI5LDMyXSxmPVsxLDIsNCw2LDgsMTAsMTIsMTQsMTUsMTcsMTksMjEsMjMsMjUsMjcsMjhdLGw9W3swOjg0MjE4ODgsMjY4NDM1NDU2OjMyNzY4LDUzNjg3MDkxMjo4NDIxMzc4LDgwNTMwNjM2ODoyLDEwNzM3NDE4MjQ6NTEyLDEzNDIxNzcyODA6ODQyMTg5MCwxNjEwNjEyNzM2OjgzODkxMjIsMTg3OTA0ODE5Mjo4Mzg4NjA4LDIxNDc0ODM2NDg6NTE0LDI0MTU5MTkxMDQ6ODM4OTEyMCwyNjg0MzU0NTYwOjMzMjgwLDI5NTI3OTAwMTY6ODQyMTM3NiwzMjIxMjI1NDcyOjMyNzcwLDM0ODk2NjA5Mjg6ODM4ODYxMCwzNzU4MDk2Mzg0OjAsNDAyNjUzMTg0MDozMzI4MiwxMzQyMTc3Mjg6MCw0MDI2NTMxODQ6ODQyMTg5MCw2NzEwODg2NDA6MzMyODIsOTM5NTI0MDk2OjMyNzY4LDEyMDc5NTk1NTI6ODQyMTg4OCwxNDc2Mzk1MDA4OjUxMiwxNzQ0ODMwNDY0Ojg0MjEzNzgsMjAxMzI2NTkyMDoyLDIyODE3MDEzNzY6ODM4OTEyMCwyNTUwMTM2ODMyOjMzMjgwLDI4MTg1NzIyODg6ODQyMTM3NiwzMDg3MDA3NzQ0OjgzODkxMjIsMzM1NTQ0MzIwMDo4Mzg4NjEwLDM2MjM4Nzg2NTY6MzI3NzAsMzg5MjMxNDExMjo1MTQsNDE2MDc0OTU2ODo4Mzg4NjA4LDE6MzI3NjgsMjY4NDM1NDU3OjIsNTM2ODcwOTEzOjg0MjE4ODgsODA1MzA2MzY5OjgzODg2MDgsMTA3Mzc0MTgyNTo4NDIxMzc4LDEzNDIxNzcyODE6MzMyODAsMTYxMDYxMjczNzo1MTIsMTg3OTA0ODE5Mzo4Mzg5MTIyLDIxNDc0ODM2NDk6ODQyMTg5MCwyNDE1OTE5MTA1Ojg0MjEzNzYsMjY4NDM1NDU2MTo4Mzg4NjEwLDI5NTI3OTAwMTc6MzMyODIsMzIyMTIyNTQ3Mzo1MTQsMzQ4OTY2MDkyOTo4Mzg5MTIwLDM3NTgwOTYzODU6MzI3NzAsNDAyNjUzMTg0MTowLDEzNDIxNzcyOTo4NDIxODkwLDQwMjY1MzE4NTo4NDIxMzc2LDY3MTA4ODY0MTo4Mzg4NjA4LDkzOTUyNDA5Nzo1MTIsMTIwNzk1OTU1MzozMjc2OCwxNDc2Mzk1MDA5OjgzODg2MTAsMTc0NDgzMDQ2NToyLDIwMTMyNjU5MjE6MzMyODIsMjI4MTcwMTM3NzozMjc3MCwyNTUwMTM2ODMzOjgzODkxMjIsMjgxODU3MjI4OTo1MTQsMzA4NzAwNzc0NTo4NDIxODg4LDMzNTU0NDMyMDE6ODM4OTEyMCwzNjIzODc4NjU3OjAsMzg5MjMxNDExMzozMzI4MCw0MTYwNzQ5NTY5Ojg0MjEzNzh9LHswOjEwNzQyODI1MTIsMTY3NzcyMTY6MTYzODQsMzM1NTQ0MzI6NTI0Mjg4LDUwMzMxNjQ4OjEwNzQyNjYxMjgsNjcxMDg4NjQ6MTA3Mzc0MTg0MCw4Mzg4NjA4MDoxMDc0MjgyNDk2LDEwMDY2MzI5NjoxMDczNzU4MjA4LDExNzQ0MDUxMjoxNiwxMzQyMTc3Mjg6NTQwNjcyLDE1MDk5NDk0NDoxMDczNzU4MjI0LDE2Nzc3MjE2MDoxMDczNzQxODI0LDE4NDU0OTM3Njo1NDA2ODgsMjAxMzI2NTkyOjUyNDMwNCwyMTgxMDM4MDg6MCwyMzQ4ODEwMjQ6MTY0MDAsMjUxNjU4MjQwOjEwNzQyNjYxMTIsODM4ODYwODoxMDczNzU4MjA4LDI1MTY1ODI0OjU0MDY4OCw0MTk0MzA0MDoxNiw1ODcyMDI1NjoxMDczNzU4MjI0LDc1NDk3NDcyOjEwNzQyODI1MTIsOTIyNzQ2ODg6MTA3Mzc0MTgyNCwxMDkwNTE5MDQ6NTI0Mjg4LDEyNTgyOTEyMDoxMDc0MjY2MTI4LDE0MjYwNjMzNjo1MjQzMDQsMTU5MzgzNTUyOjAsMTc2MTYwNzY4OjE2Mzg0LDE5MjkzNzk4NDoxMDc0MjY2MTEyLDIwOTcxNTIwMDoxMDczNzQxODQwLDIyNjQ5MjQxNjo1NDA2NzIsMjQzMjY5NjMyOjEwNzQyODI0OTYsMjYwMDQ2ODQ4OjE2NDAwLDI2ODQzNTQ1NjowLDI4NTIxMjY3MjoxMDc0MjY2MTI4LDMwMTk4OTg4ODoxMDczNzU4MjI0LDMxODc2NzEwNDoxMDc0MjgyNDk2LDMzNTU0NDMyMDoxMDc0MjY2MTEyLDM1MjMyMTUzNjoxNiwzNjkwOTg3NTI6NTQwNjg4LDM4NTg3NTk2ODoxNjM4NCw0MDI2NTMxODQ6MTY0MDAsNDE5NDMwNDAwOjUyNDI4OCw0MzYyMDc2MTY6NTI0MzA0LDQ1Mjk4NDgzMjoxMDczNzQxODQwLDQ2OTc2MjA0ODo1NDA2NzIsNDg2NTM5MjY0OjEwNzM3NTgyMDgsNTAzMzE2NDgwOjEwNzM3NDE4MjQsNTIwMDkzNjk2OjEwNzQyODI1MTIsMjc2ODI0MDY0OjU0MDY4OCwyOTM2MDEyODA6NTI0Mjg4LDMxMDM3ODQ5NjoxMDc0MjY2MTEyLDMyNzE1NTcxMjoxNjM4NCwzNDM5MzI5Mjg6MTA3Mzc1ODIwOCwzNjA3MTAxNDQ6MTA3NDI4MjUxMiwzNzc0ODczNjA6MTYsMzk0MjY0NTc2OjEwNzM3NDE4MjQsNDExMDQxNzkyOjEwNzQyODI0OTYsNDI3ODE5MDA4OjEwNzM3NDE4NDAsNDQ0NTk2MjI0OjEwNzM3NTgyMjQsNDYxMzczNDQwOjUyNDMwNCw0NzgxNTA2NTY6MCw0OTQ5Mjc4NzI6MTY0MDAsNTExNzA1MDg4OjEwNzQyNjYxMjgsNTI4NDgyMzA0OjU0MDY3Mn0sezA6MjYwLDEwNDg1NzY6MCwyMDk3MTUyOjY3MTA5MTIwLDMxNDU3Mjg6NjU3OTYsNDE5NDMwNDo2NTU0MCw1MjQyODgwOjY3MTA4ODY4LDYyOTE0NTY6NjcxNzQ2NjAsNzM0MDAzMjo2NzE3NDQwMCw4Mzg4NjA4OjY3MTA4ODY0LDk0MzcxODQ6NjcxNzQ2NTYsMTA0ODU3NjA6NjU3OTIsMTE1MzQzMzY6NjcxNzQ0MDQsMTI1ODI5MTI6NjcxMDkxMjQsMTM2MzE0ODg6NjU1MzYsMTQ2ODAwNjQ6NCwxNTcyODY0MDoyNTYsNTI0Mjg4OjY3MTc0NjU2LDE1NzI4NjQ6NjcxNzQ0MDQsMjYyMTQ0MDowLDM2NzAwMTY6NjcxMDkxMjAsNDcxODU5Mjo2NzEwODg2OCw1NzY3MTY4OjY1NTM2LDY4MTU3NDQ6NjU1NDAsNzg2NDMyMDoyNjAsODkxMjg5Njo0LDk5NjE0NzI6MjU2LDExMDEwMDQ4OjY3MTc0NDAwLDEyMDU4NjI0OjY1Nzk2LDEzMTA3MjAwOjY1NzkyLDE0MTU1Nzc2OjY3MTA5MTI0LDE1MjA0MzUyOjY3MTc0NjYwLDE2MjUyOTI4OjY3MTA4ODY0LDE2Nzc3MjE2OjY3MTc0NjU2LDE3ODI1NzkyOjY1NTQwLDE4ODc0MzY4OjY1NTM2LDE5OTIyOTQ0OjY3MTA5MTIwLDIwOTcxNTIwOjI1NiwyMjAyMDA5Njo2NzE3NDY2MCwyMzA2ODY3Mjo2NzEwODg2OCwyNDExNzI0ODowLDI1MTY1ODI0OjY3MTA5MTI0LDI2MjE0NDAwOjY3MTA4ODY0LDI3MjYyOTc2OjQsMjgzMTE1NTI6NjU3OTIsMjkzNjAxMjg6NjcxNzQ0MDAsMzA0MDg3MDQ6MjYwLDMxNDU3MjgwOjY1Nzk2LDMyNTA1ODU2OjY3MTc0NDA0LDE3MzAxNTA0OjY3MTA4ODY0LDE4MzUwMDgwOjI2MCwxOTM5ODY1Njo2NzE3NDY1NiwyMDQ0NzIzMjowLDIxNDk1ODA4OjY1NTQwLDIyNTQ0Mzg0OjY3MTA5MTIwLDIzNTkyOTYwOjI1NiwyNDY0MTUzNjo2NzE3NDQwNCwyNTY5MDExMjo2NTUzNiwyNjczODY4ODo2NzE3NDY2MCwyNzc4NzI2NDo2NTc5NiwyODgzNTg0MDo2NzEwODg2OCwyOTg4NDQxNjo2NzEwOTEyNCwzMDkzMjk5Mjo2NzE3NDQwMCwzMTk4MTU2ODo0LDMzMDMwMTQ0OjY1NzkyfSx7MDoyMTUxNjgyMDQ4LDY1NTM2OjIxNDc0ODc4MDgsMTMxMDcyOjQxOTg0NjQsMTk2NjA4OjIxNTE2Nzc5NTIsMjYyMTQ0OjAsMzI3NjgwOjQxOTg0MDAsMzkzMjE2OjIxNDc0ODM3MTIsNDU4NzUyOjQxOTQzNjgsNTI0Mjg4OjIxNDc0ODM2NDgsNTg5ODI0OjQxOTQzMDQsNjU1MzYwOjY0LDcyMDg5NjoyMTQ3NDg3NzQ0LDc4NjQzMjoyMTUxNjc4MDE2LDg1MTk2ODo0MTYwLDkxNzUwNDo0MDk2LDk4MzA0MDoyMTUxNjgyMTEyLDMyNzY4OjIxNDc0ODc4MDgsOTgzMDQ6NjQsMTYzODQwOjIxNTE2NzgwMTYsMjI5Mzc2OjIxNDc0ODc3NDQsMjk0OTEyOjQxOTg0MDAsMzYwNDQ4OjIxNTE2ODIxMTIsNDI1OTg0OjAsNDkxNTIwOjIxNTE2Nzc5NTIsNTU3MDU2OjQwOTYsNjIyNTkyOjIxNTE2ODIwNDgsNjg4MTI4OjQxOTQzMDQsNzUzNjY0OjQxNjAsODE5MjAwOjIxNDc0ODM2NDgsODg0NzM2OjQxOTQzNjgsOTUwMjcyOjQxOTg0NjQsMTAxNTgwODoyMTQ3NDgzNzEyLDEwNDg1NzY6NDE5NDM2OCwxMTE0MTEyOjQxOTg0MDAsMTE3OTY0ODoyMTQ3NDgzNzEyLDEyNDUxODQ6MCwxMzEwNzIwOjQxNjAsMTM3NjI1NjoyMTUxNjc4MDE2LDE0NDE3OTI6MjE1MTY4MjA0OCwxNTA3MzI4OjIxNDc0ODc4MDgsMTU3Mjg2NDoyMTUxNjgyMTEyLDE2Mzg0MDA6MjE0NzQ4MzY0OCwxNzAzOTM2OjIxNTE2Nzc5NTIsMTc2OTQ3Mjo0MTk4NDY0LDE4MzUwMDg6MjE0NzQ4Nzc0NCwxOTAwNTQ0OjQxOTQzMDQsMTk2NjA4MDo2NCwyMDMxNjE2OjQwOTYsMTA4MTM0NDoyMTUxNjc3OTUyLDExNDY4ODA6MjE1MTY4MjExMiwxMjEyNDE2OjAsMTI3Nzk1Mjo0MTk4NDAwLDEzNDM0ODg6NDE5NDM2OCwxNDA5MDI0OjIxNDc0ODM2NDgsMTQ3NDU2MDoyMTQ3NDg3ODA4LDE1NDAwOTY6NjQsMTYwNTYzMjoyMTQ3NDgzNzEyLDE2NzExNjg6NDA5NiwxNzM2NzA0OjIxNDc0ODc3NDQsMTgwMjI0MDoyMTUxNjc4MDE2LDE4Njc3NzY6NDE2MCwxOTMzMzEyOjIxNTE2ODIwNDgsMTk5ODg0ODo0MTk0MzA0LDIwNjQzODQ6NDE5ODQ2NH0sezA6MTI4LDQwOTY6MTcwMzkzNjAsODE5MjoyNjIxNDQsMTIyODg6NTM2ODcwOTEyLDE2Mzg0OjUzNzEzMzE4NCwyMDQ4MDoxNjc3NzM0NCwyNDU3Njo1NTM2NDgyNTYsMjg2NzI6MjYyMjcyLDMyNzY4OjE2Nzc3MjE2LDM2ODY0OjUzNzEzMzA1Niw0MDk2MDo1MzY4NzEwNDAsNDUwNTY6NTUzOTEwNDAwLDQ5MTUyOjU1MzkxMDI3Miw1MzI0ODowLDU3MzQ0OjE3MDM5NDg4LDYxNDQwOjU1MzY0ODEyOCwyMDQ4OjE3MDM5NDg4LDYxNDQ6NTUzNjQ4MjU2LDEwMjQwOjEyOCwxNDMzNjoxNzAzOTM2MCwxODQzMjoyNjIxNDQsMjI1Mjg6NTM3MTMzMTg0LDI2NjI0OjU1MzkxMDI3MiwzMDcyMDo1MzY4NzA5MTIsMzQ4MTY6NTM3MTMzMDU2LDM4OTEyOjAsNDMwMDg6NTUzOTEwNDAwLDQ3MTA0OjE2Nzc3MzQ0LDUxMjAwOjUzNjg3MTA0MCw1NTI5Njo1NTM2NDgxMjgsNTkzOTI6MTY3NzcyMTYsNjM0ODg6MjYyMjcyLDY1NTM2OjI2MjE0NCw2OTYzMjoxMjgsNzM3Mjg6NTM2ODcwOTEyLDc3ODI0OjU1MzY0ODI1Niw4MTkyMDoxNjc3NzM0NCw4NjAxNjo1NTM5MTAyNzIsOTAxMTI6NTM3MTMzMTg0LDk0MjA4OjE2Nzc3MjE2LDk4MzA0OjU1MzkxMDQwMCwxMDI0MDA6NTUzNjQ4MTI4LDEwNjQ5NjoxNzAzOTM2MCwxMTA1OTI6NTM3MTMzMDU2LDExNDY4ODoyNjIyNzIsMTE4Nzg0OjUzNjg3MTA0MCwxMjI4ODA6MCwxMjY5NzY6MTcwMzk0ODgsNjc1ODQ6NTUzNjQ4MjU2LDcxNjgwOjE2Nzc3MjE2LDc1Nzc2OjE3MDM5MzYwLDc5ODcyOjUzNzEzMzE4NCw4Mzk2ODo1MzY4NzA5MTIsODgwNjQ6MTcwMzk0ODgsOTIxNjA6MTI4LDk2MjU2OjU1MzkxMDI3MiwxMDAzNTI6MjYyMjcyLDEwNDQ0ODo1NTM5MTA0MDAsMTA4NTQ0OjAsMTEyNjQwOjU1MzY0ODEyOCwxMTY3MzY6MTY3NzczNDQsMTIwODMyOjI2MjE0NCwxMjQ5Mjg6NTM3MTMzMDU2LDEyOTAyNDo1MzY4NzEwNDB9LHswOjI2ODQzNTQ2NCwyNTY6ODE5Miw1MTI6MjcwNTMyNjA4LDc2ODoyNzA1NDA4MDgsMTAyNDoyNjg0NDM2NDgsMTI4MDoyMDk3MTUyLDE1MzY6MjA5NzE2MCwxNzkyOjI2ODQzNTQ1NiwyMDQ4OjAsMjMwNDoyNjg0NDM2NTYsMjU2MDoyMTA1MzQ0LDI4MTY6OCwzMDcyOjI3MDUzMjYxNiwzMzI4OjIxMDUzNTIsMzU4NDo4MjAwLDM4NDA6MjcwNTQwODAwLDEyODoyNzA1MzI2MDgsMzg0OjI3MDU0MDgwOCw2NDA6OCw4OTY6MjA5NzE1MiwxMTUyOjIxMDUzNTIsMTQwODoyNjg0MzU0NjQsMTY2NDoyNjg0NDM2NDgsMTkyMDo4MjAwLDIxNzY6MjA5NzE2MCwyNDMyOjgxOTIsMjY4ODoyNjg0NDM2NTYsMjk0NDoyNzA1MzI2MTYsMzIwMDowLDM0NTY6MjcwNTQwODAwLDM3MTI6MjEwNTM0NCwzOTY4OjI2ODQzNTQ1Niw0MDk2OjI2ODQ0MzY0OCw0MzUyOjI3MDUzMjYxNiw0NjA4OjI3MDU0MDgwOCw0ODY0OjgyMDAsNTEyMDoyMDk3MTUyLDUzNzY6MjY4NDM1NDU2LDU2MzI6MjY4NDM1NDY0LDU4ODg6MjEwNTM0NCw2MTQ0OjIxMDUzNTIsNjQwMDowLDY2NTY6OCw2OTEyOjI3MDUzMjYwOCw3MTY4OjgxOTIsNzQyNDoyNjg0NDM2NTYsNzY4MDoyNzA1NDA4MDAsNzkzNjoyMDk3MTYwLDQyMjQ6OCw0NDgwOjIxMDUzNDQsNDczNjoyMDk3MTUyLDQ5OTI6MjY4NDM1NDY0LDUyNDg6MjY4NDQzNjQ4LDU1MDQ6ODIwMCw1NzYwOjI3MDU0MDgwOCw2MDE2OjI3MDUzMjYwOCw2MjcyOjI3MDU0MDgwMCw2NTI4OjI3MDUzMjYxNiw2Nzg0OjgxOTIsNzA0MDoyMTA1MzUyLDcyOTY6MjA5NzE2MCw3NTUyOjAsNzgwODoyNjg0MzU0NTYsODA2NDoyNjg0NDM2NTZ9LHswOjEwNDg1NzYsMTY6MzM1NTU0NTcsMzI6MTAyNCw0ODoxMDQ5NjAxLDY0OjM0NjA0MDMzLDgwOjAsOTY6MSwxMTI6MzQ2MDMwMDksMTI4OjMzNTU1NDU2LDE0NDoxMDQ4NTc3LDE2MDozMzU1NDQzMywxNzY6MzQ2MDQwMzIsMTkyOjM0NjAzMDA4LDIwODoxMDI1LDIyNDoxMDQ5NjAwLDI0MDozMzU1NDQzMiw4OjM0NjAzMDA5LDI0OjAsNDA6MzM1NTU0NTcsNTY6MzQ2MDQwMzIsNzI6MTA0ODU3Niw4ODozMzU1NDQzMywxMDQ6MzM1NTQ0MzIsMTIwOjEwMjUsMTM2OjEwNDk2MDEsMTUyOjMzNTU1NDU2LDE2ODozNDYwMzAwOCwxODQ6MTA0ODU3NywyMDA6MTAyNCwyMTY6MzQ2MDQwMzMsMjMyOjEsMjQ4OjEwNDk2MDAsMjU2OjMzNTU0NDMyLDI3MjoxMDQ4NTc2LDI4ODozMzU1NTQ1NywzMDQ6MzQ2MDMwMDksMzIwOjEwNDg1NzcsMzM2OjMzNTU1NDU2LDM1MjozNDYwNDAzMiwzNjg6MTA0OTYwMSwzODQ6MTAyNSw0MDA6MzQ2MDQwMzMsNDE2OjEwNDk2MDAsNDMyOjEsNDQ4OjAsNDY0OjM0NjAzMDA4LDQ4MDozMzU1NDQzMyw0OTY6MTAyNCwyNjQ6MTA0OTYwMCwyODA6MzM1NTU0NTcsMjk2OjM0NjAzMDA5LDMxMjoxLDMyODozMzU1NDQzMiwzNDQ6MTA0ODU3NiwzNjA6MTAyNSwzNzY6MzQ2MDQwMzIsMzkyOjMzNTU0NDMzLDQwODozNDYwMzAwOCw0MjQ6MCw0NDA6MzQ2MDQwMzMsNDU2OjEwNDk2MDEsNDcyOjEwMjQsNDg4OjMzNTU1NDU2LDUwNDoxMDQ4NTc3fSx7MDoxMzQyMTk4MDgsMToxMzEwNzIsMjoxMzQyMTc3MjgsMzozMiw0OjEzMTEwNCw1OjEzNDM1MDg4MCw2OjEzNDM1MDg0OCw3OjIwNDgsODoxMzQzNDg4MDAsOToxMzQyMTk3NzYsMTA6MTMzMTIwLDExOjEzNDM0ODgzMiwxMjoyMDgwLDEzOjAsMTQ6MTM0MjE3NzYwLDE1OjEzMzE1MiwyMTQ3NDgzNjQ4OjIwNDgsMjE0NzQ4MzY0OToxMzQzNTA4ODAsMjE0NzQ4MzY1MDoxMzQyMTk4MDgsMjE0NzQ4MzY1MToxMzQyMTc3MjgsMjE0NzQ4MzY1MjoxMzQzNDg4MDAsMjE0NzQ4MzY1MzoxMzMxMjAsMjE0NzQ4MzY1NDoxMzMxNTIsMjE0NzQ4MzY1NTozMiwyMTQ3NDgzNjU2OjEzNDIxNzc2MCwyMTQ3NDgzNjU3OjIwODAsMjE0NzQ4MzY1ODoxMzExMDQsMjE0NzQ4MzY1OToxMzQzNTA4NDgsMjE0NzQ4MzY2MDowLDIxNDc0ODM2NjE6MTM0MzQ4ODMyLDIxNDc0ODM2NjI6MTM0MjE5Nzc2LDIxNDc0ODM2NjM6MTMxMDcyLDE2OjEzMzE1MiwxNzoxMzQzNTA4NDgsMTg6MzIsMTk6MjA0OCwyMDoxMzQyMTk3NzYsMjE6MTM0MjE3NzYwLDIyOjEzNDM0ODgzMiwyMzoxMzEwNzIsMjQ6MCwyNToxMzExMDQsMjY6MTM0MzQ4ODAwLDI3OjEzNDIxOTgwOCwyODoxMzQzNTA4ODAsMjk6MTMzMTIwLDMwOjIwODAsMzE6MTM0MjE3NzI4LDIxNDc0ODM2NjQ6MTMxMDcyLDIxNDc0ODM2NjU6MjA0OCwyMTQ3NDgzNjY2OjEzNDM0ODgzMiwyMTQ3NDgzNjY3OjEzMzE1MiwyMTQ3NDgzNjY4OjMyLDIxNDc0ODM2Njk6MTM0MzQ4ODAwLDIxNDc0ODM2NzA6MTM0MjE3NzI4LDIxNDc0ODM2NzE6MTM0MjE5ODA4LDIxNDc0ODM2NzI6MTM0MzUwODgwLDIxNDc0ODM2NzM6MTM0MjE3NzYwLDIxNDc0ODM2NzQ6MTM0MjE5Nzc2LDIxNDc0ODM2NzU6MCwyMTQ3NDgzNjc2OjEzMzEyMCwyMTQ3NDgzNjc3OjIwODAsMjE0NzQ4MzY3ODoxMzExMDQsMjE0NzQ4MzY3OToxMzQzNTA4NDh9XSxwPVs0MTYwNzQ5NTY5LDUyODQ4MjMwNCwzMzAzMDE0NCwyMDY0Mzg0LDEyOTAyNCw4MDY0LDUwNCwyMTQ3NDgzNjc5XSxoPXMuREVTPWEuZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLl9rZXkud29yZHMsZT1bXSxuPTA7bjw1NjtuKyspe3ZhciByPWNbbl0tMTtlW25dPXRbcj4+PjVdPj4+MzEtciUzMiYxfWZvcih2YXIgbz10aGlzLl9zdWJLZXlzPVtdLGk9MDtpPDE2O2krKyl7dmFyIGE9b1tpXT1bXSxzPWZbaV07Zm9yKG49MDtuPDI0O24rKylhW24vNnwwXXw9ZVsodVtuXS0xK3MpJTI4XTw8MzEtbiU2LGFbNCsobi82fDApXXw9ZVsyOCsodVtuKzI0XS0xK3MpJTI4XTw8MzEtbiU2O2FbMF09YVswXTw8MXxhWzBdPj4+MzE7Zm9yKG49MTtuPDc7bisrKWFbbl09YVtuXT4+PjQqKG4tMSkrMzthWzddPWFbN108PDV8YVs3XT4+PjI3fXZhciBsPXRoaXMuX2ludlN1YktleXM9W107Zm9yKG49MDtuPDE2O24rKylsW25dPW9bMTUtbl19LGVuY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2RvQ3J5cHRCbG9jayh0LGUsdGhpcy5fc3ViS2V5cyl9LGRlY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2RvQ3J5cHRCbG9jayh0LGUsdGhpcy5faW52U3ViS2V5cyl9LF9kb0NyeXB0QmxvY2s6ZnVuY3Rpb24odCxyLG8pe3RoaXMuX2xCbG9jaz10W3JdLHRoaXMuX3JCbG9jaz10W3IrMV0sZS5jYWxsKHRoaXMsNCwyNTI2NDUxMzUpLGUuY2FsbCh0aGlzLDE2LDY1NTM1KSxuLmNhbGwodGhpcywyLDg1ODk5MzQ1OSksbi5jYWxsKHRoaXMsOCwxNjcxMTkzNSksZS5jYWxsKHRoaXMsMSwxNDMxNjU1NzY1KTtmb3IodmFyIGk9MDtpPDE2O2krKyl7Zm9yKHZhciBhPW9baV0scz10aGlzLl9sQmxvY2ssYz10aGlzLl9yQmxvY2ssdT0wLGY9MDtmPDg7ZisrKXV8PWxbZl1bKChjXmFbZl0pJnBbZl0pPj4+MF07dGhpcy5fbEJsb2NrPWMsdGhpcy5fckJsb2NrPXNedX12YXIgaD10aGlzLl9sQmxvY2s7dGhpcy5fbEJsb2NrPXRoaXMuX3JCbG9jayx0aGlzLl9yQmxvY2s9aCxlLmNhbGwodGhpcywxLDE0MzE2NTU3NjUpLG4uY2FsbCh0aGlzLDgsMTY3MTE5MzUpLG4uY2FsbCh0aGlzLDIsODU4OTkzNDU5KSxlLmNhbGwodGhpcywxNiw2NTUzNSksZS5jYWxsKHRoaXMsNCwyNTI2NDUxMzUpLHRbcl09dGhpcy5fbEJsb2NrLHRbcisxXT10aGlzLl9yQmxvY2t9LGtleVNpemU6MixpdlNpemU6MixibG9ja1NpemU6Mn0pO3IuREVTPWEuX2NyZWF0ZUhlbHBlcihoKTt2YXIgZD1zLlRyaXBsZURFUz1hLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9rZXkud29yZHM7dGhpcy5fZGVzMT1oLmNyZWF0ZUVuY3J5cHRvcihpLmNyZWF0ZSh0LnNsaWNlKDAsMikpKSx0aGlzLl9kZXMyPWguY3JlYXRlRW5jcnlwdG9yKGkuY3JlYXRlKHQuc2xpY2UoMiw0KSkpLHRoaXMuX2RlczM9aC5jcmVhdGVFbmNyeXB0b3IoaS5jcmVhdGUodC5zbGljZSg0LDYpKSl9LGVuY3J5cHRCbG9jazpmdW5jdGlvbih0LGUpe3RoaXMuX2RlczEuZW5jcnlwdEJsb2NrKHQsZSksdGhpcy5fZGVzMi5kZWNyeXB0QmxvY2sodCxlKSx0aGlzLl9kZXMzLmVuY3J5cHRCbG9jayh0LGUpfSxkZWNyeXB0QmxvY2s6ZnVuY3Rpb24odCxlKXt0aGlzLl9kZXMzLmRlY3J5cHRCbG9jayh0LGUpLHRoaXMuX2RlczIuZW5jcnlwdEJsb2NrKHQsZSksdGhpcy5fZGVzMS5kZWNyeXB0QmxvY2sodCxlKX0sa2V5U2l6ZTo2LGl2U2l6ZToyLGJsb2NrU2l6ZToyfSk7ci5UcmlwbGVERVM9YS5fY3JlYXRlSGVscGVyKGQpfSgpLHQuVHJpcGxlREVTfSl9LHsiLi9jaXBoZXItY29yZSI6NTIsIi4vY29yZSI6NTMsIi4vZW5jLWJhc2U2NCI6NTQsIi4vZXZwa2RmIjo1NiwiLi9tZDUiOjYxfV0sODQ6W2Z1bmN0aW9uKHQsZSxuKXshZnVuY3Rpb24ocixvKXsib2JqZWN0Ij09dHlwZW9mIG4/ZS5leHBvcnRzPW49byh0KCIuL2NvcmUiKSk6ImZ1bmN0aW9uIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoWyIuL2NvcmUiXSxvKTpvKHIuQ3J5cHRvSlMpfSh0aGlzLGZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgbj10LHI9bi5saWIsbz1yLkJhc2UsaT1yLldvcmRBcnJheSxhPW4ueDY0PXt9O2EuV29yZD1vLmV4dGVuZCh7aW5pdDpmdW5jdGlvbih0LGUpe3RoaXMuaGlnaD10LHRoaXMubG93PWV9fSksYS5Xb3JkQXJyYXk9by5leHRlbmQoe2luaXQ6ZnVuY3Rpb24odCxlKXt0PXRoaXMud29yZHM9dHx8W10sdGhpcy5zaWdCeXRlcz12b2lkIDAhPWU/ZTo4KnQubGVuZ3RofSx0b1gzMjpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLndvcmRzLGU9dC5sZW5ndGgsbj1bXSxyPTA7cjxlO3IrKyl7dmFyIG89dFtyXTtuLnB1c2goby5oaWdoKSxuLnB1c2goby5sb3cpfXJldHVybiBpLmNyZWF0ZShuLHRoaXMuc2lnQnl0ZXMpfSxjbG9uZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1vLmNsb25lLmNhbGwodGhpcyksZT10LndvcmRzPXRoaXMud29yZHMuc2xpY2UoMCksbj1lLmxlbmd0aCxyPTA7cjxuO3IrKyllW3JdPWVbcl0uY2xvbmUoKTtyZXR1cm4gdH19KX0oKSx0fSl9LHsiLi9jb3JlIjo1M31dLDg1OltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIodCl7Zm9yKHZhciBlLG4scj1bXSxvPTAsaT10Lmxlbmd0aDtvPGk7KShlPXQuY2hhckNvZGVBdChvKyspKT49NTUyOTYmJmU8PTU2MzE5JiZvPGk/NTYzMjA9PSg2NDUxMiYobj10LmNoYXJDb2RlQXQobysrKSkpP3IucHVzaCgoKDEwMjMmZSk8PDEwKSsoMTAyMyZuKSs2NTUzNik6KHIucHVzaChlKSxvLS0pOnIucHVzaChlKTtyZXR1cm4gcn1mdW5jdGlvbiBvKHQpe2lmKHQ+PTU1Mjk2JiZ0PD01NzM0Myl0aHJvdyBFcnJvcigiTG9uZSBzdXJyb2dhdGUgVSsiK3QudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkrIiBpcyBub3QgYSBzY2FsYXIgdmFsdWUiKX1mdW5jdGlvbiBpKHQsZSl7cmV0dXJuIG0odD4+ZSY2M3wxMjgpfWZ1bmN0aW9uIGEodCl7aWYoMD09KDQyOTQ5NjcxNjgmdCkpcmV0dXJuIG0odCk7dmFyIGU9IiI7cmV0dXJuIDA9PSg0Mjk0OTY1MjQ4JnQpP2U9bSh0Pj42JjMxfDE5Mik6MD09KDQyOTQ5MDE3NjAmdCk/KG8odCksZT1tKHQ+PjEyJjE1fDIyNCksZSs9aSh0LDYpKTowPT0oNDI5Mjg3MDE0NCZ0KSYmKGU9bSh0Pj4xOCY3fDI0MCksZSs9aSh0LDEyKSxlKz1pKHQsNikpLGUrPW0oNjMmdHwxMjgpfWZ1bmN0aW9uIHMoKXtpZihkPj1oKXRocm93IEVycm9yKCJJbnZhbGlkIGJ5dGUgaW5kZXgiKTt2YXIgdD0yNTUmcFtkXTtpZihkKyssMTI4PT0oMTkyJnQpKXJldHVybiA2MyZ0O3Rocm93IEVycm9yKCJJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlIil9ZnVuY3Rpb24gYygpe3ZhciB0LGUsbixyLGk7aWYoZD5oKXRocm93IEVycm9yKCJJbnZhbGlkIGJ5dGUgaW5kZXgiKTtpZihkPT1oKXJldHVybiExO2lmKHQ9MjU1JnBbZF0sZCsrLDA9PSgxMjgmdCkpcmV0dXJuIHQ7aWYoMTkyPT0oMjI0JnQpKXtpZihlPXMoKSwoaT0oMzEmdCk8PDZ8ZSk+PTEyOClyZXR1cm4gaTt0aHJvdyBFcnJvcigiSW52YWxpZCBjb250aW51YXRpb24gYnl0ZSIpfWlmKDIyND09KDI0MCZ0KSl7aWYoZT1zKCksbj1zKCksKGk9KDE1JnQpPDwxMnxlPDw2fG4pPj0yMDQ4KXJldHVybiBvKGkpLGk7dGhyb3cgRXJyb3IoIkludmFsaWQgY29udGludWF0aW9uIGJ5dGUiKX1pZigyNDA9PSgyNDgmdCkmJihlPXMoKSxuPXMoKSxyPXMoKSwoaT0oNyZ0KTw8MTh8ZTw8MTJ8bjw8NnxyKT49NjU1MzYmJmk8PTExMTQxMTEpKXJldHVybiBpO3Rocm93IEVycm9yKCJJbnZhbGlkIFVURi04IGRldGVjdGVkIil9dmFyIHU9Im9iamVjdCI9PXR5cGVvZiBuJiZuLGY9Im9iamVjdCI9PXR5cGVvZiBlJiZlJiZlLmV4cG9ydHM9PXUmJmUsbD0ib2JqZWN0Ij09dHlwZW9mIGdsb2JhbCYmZ2xvYmFsO2wuZ2xvYmFsIT09bCYmbC53aW5kb3chPT1sfHwodD1sKTt2YXIgcCxoLGQsbT1TdHJpbmcuZnJvbUNoYXJDb2RlLHk9e3ZlcnNpb246IjIuMS4yIixlbmNvZGU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXIodCksbj1lLmxlbmd0aCxvPS0xLGk9IiI7KytvPG47KWkrPWEoZVtvXSk7cmV0dXJuIGl9LGRlY29kZTpmdW5jdGlvbih0KXtwPXIodCksaD1wLmxlbmd0aCxkPTA7Zm9yKHZhciBlLG49W107ITEhPT0oZT1jKCkpOyluLnB1c2goZSk7cmV0dXJuIGZ1bmN0aW9uKHQpe2Zvcih2YXIgZSxuPXQubGVuZ3RoLHI9LTEsbz0iIjsrK3I8bjspKGU9dFtyXSk+NjU1MzUmJihvKz1tKChlLT02NTUzNik+Pj4xMCYxMDIzfDU1Mjk2KSxlPTU2MzIwfDEwMjMmZSksbys9bShlKTtyZXR1cm4gb30obil9fTtpZigiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiYib2JqZWN0Ij09dHlwZW9mIGRlZmluZS5hbWQmJmRlZmluZS5hbWQpZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIHl9KTtlbHNlIGlmKHUmJiF1Lm5vZGVUeXBlKWlmKGYpZi5leHBvcnRzPXk7ZWxzZXt2YXIgZz17fS5oYXNPd25Qcm9wZXJ0eTtmb3IodmFyIHYgaW4geSlnLmNhbGwoeSx2KSYmKHVbdl09eVt2XSl9ZWxzZSB0LnV0Zjg9eX0odGhpcyl9LHt9XSw4NjpbZnVuY3Rpb24odCxlLG4pe2UuZXhwb3J0cz1YTUxIdHRwUmVxdWVzdH0se31dLCJiaWdudW1iZXIuanMiOltmdW5jdGlvbih0LGUsbil7IWZ1bmN0aW9uKG4peyJ1c2Ugc3RyaWN0IjtmdW5jdGlvbiByKHQpe2Z1bmN0aW9uIGUodCxyKXt2YXIgbyxpLGEscyxjLHUsZj10aGlzO2lmKCEoZiBpbnN0YW5jZW9mIGUpKXJldHVybiBXJiZJKDI2LCJjb25zdHJ1Y3RvciBjYWxsIHdpdGhvdXQgbmV3Iix0KSxuZXcgZSh0LHIpO2lmKG51bGwhPXImJkoociwyLDY0LFIsImJhc2UiKSl7aWYocnw9MCx1PXQrIiIsMTA9PXIpcmV0dXJuIGY9bmV3IGUodCBpbnN0YW5jZW9mIGU/dDp1KSxQKGYsSCtmLmUrMSxqKTtpZigocz0ibnVtYmVyIj09dHlwZW9mIHQpJiYwKnQhPTB8fCFuZXcgUmVnRXhwKCJeLT8iKyhvPSJbIit4LnNsaWNlKDAscikrIl0rIikrIig/OlxcLiIrbysiKT8kIixyPDM3PyJpIjoiIikudGVzdCh1KSlyZXR1cm4gbShmLHUscyxyKTtzPyhmLnM9MS90PDA/KHU9dS5zbGljZSgxKSwtMSk6MSxXJiZ1LnJlcGxhY2UoL14wXC4wKnxcLi8sIiIpLmxlbmd0aD4xNSYmSShSLHcsdCkscz0hMSk6Zi5zPTQ1PT09dS5jaGFyQ29kZUF0KDApPyh1PXUuc2xpY2UoMSksLTEpOjEsdT1uKHUsMTAscixmLnMpfWVsc2V7aWYodCBpbnN0YW5jZW9mIGUpcmV0dXJuIGYucz10LnMsZi5lPXQuZSxmLmM9KHQ9dC5jKT90LnNsaWNlKCk6dCx2b2lkKFI9MCk7aWYoKHM9Im51bWJlciI9PXR5cGVvZiB0KSYmMCp0PT0wKXtpZihmLnM9MS90PDA/KHQ9LXQsLTEpOjEsdD09PX5+dCl7Zm9yKGk9MCxhPXQ7YT49MTA7YS89MTAsaSsrKTtyZXR1cm4gZi5lPWksZi5jPVt0XSx2b2lkKFI9MCl9dT10KyIifWVsc2V7aWYoIXkudGVzdCh1PXQrIiIpKXJldHVybiBtKGYsdSxzKTtmLnM9NDU9PT11LmNoYXJDb2RlQXQoMCk/KHU9dS5zbGljZSgxKSwtMSk6MX19Zm9yKChpPXUuaW5kZXhPZigiLiIpKT4tMSYmKHU9dS5yZXBsYWNlKCIuIiwiIikpLChhPXUuc2VhcmNoKC9lL2kpKT4wPyhpPDAmJihpPWEpLGkrPSt1LnNsaWNlKGErMSksdT11LnN1YnN0cmluZygwLGEpKTppPDAmJihpPXUubGVuZ3RoKSxhPTA7NDg9PT11LmNoYXJDb2RlQXQoYSk7YSsrKTtmb3IoYz11Lmxlbmd0aDs0OD09PXUuY2hhckNvZGVBdCgtLWMpOyk7aWYodT11LnNsaWNlKGEsYysxKSlpZihjPXUubGVuZ3RoLHMmJlcmJmM+MTUmJkkoUix3LGYucyp0KSwoaT1pLWEtMSk+VSlmLmM9Zi5lPW51bGw7ZWxzZSBpZihpPEwpZi5jPVtmLmU9MF07ZWxzZXtpZihmLmU9aSxmLmM9W10sYT0oaSsxKSVCLGk8MCYmKGErPUIpLGE8Yyl7Zm9yKGEmJmYuYy5wdXNoKCt1LnNsaWNlKDAsYSkpLGMtPUI7YTxjOylmLmMucHVzaCgrdS5zbGljZShhLGErPUIpKTt1PXUuc2xpY2UoYSksYT1CLXUubGVuZ3RofWVsc2UgYS09Yztmb3IoO2EtLTt1Kz0iMCIpO2YuYy5wdXNoKCt1KX1lbHNlIGYuYz1bZi5lPTBdO1I9MH1mdW5jdGlvbiBuKHQsbixyLG8pe3ZhciBhLHMsYyxmLHAsaCxkLG09dC5pbmRleE9mKCIuIikseT1ILGc9ajtmb3IocjwzNyYmKHQ9dC50b0xvd2VyQ2FzZSgpKSxtPj0wJiYoYz1YLFg9MCx0PXQucmVwbGFjZSgiLiIsIiIpLHA9KGQ9bmV3IGUocikpLnBvdyh0Lmxlbmd0aC1tKSxYPWMsZC5jPXUobChpKHAuYykscC5lKSwxMCxuKSxkLmU9ZC5jLmxlbmd0aCkscz1jPShoPXUodCxyLG4pKS5sZW5ndGg7MD09aFstLWNdO2gucG9wKCkpO2lmKCFoWzBdKXJldHVybiIwIjtpZihtPDA/LS1zOihwLmM9aCxwLmU9cyxwLnM9byxoPShwPUQocCxkLHksZyxuKSkuYyxmPXAucixzPXAuZSksYT1zK3krMSxtPWhbYV0sYz1uLzIsZj1mfHxhPDB8fG51bGwhPWhbYSsxXSxmPWc8ND8obnVsbCE9bXx8ZikmJigwPT1nfHxnPT0ocC5zPDA/MzoyKSk6bT5jfHxtPT1jJiYoND09Z3x8Znx8Nj09ZyYmMSZoW2EtMV18fGc9PShwLnM8MD84OjcpKSxhPDF8fCFoWzBdKXQ9Zj9sKCIxIiwteSk6IjAiO2Vsc2V7aWYoaC5sZW5ndGg9YSxmKWZvcigtLW47KytoWy0tYV0+bjspaFthXT0wLGF8fCgrK3MsaC51bnNoaWZ0KDEpKTtmb3IoYz1oLmxlbmd0aDshaFstLWNdOyk7Zm9yKG09MCx0PSIiO208PWM7dCs9eC5jaGFyQXQoaFttKytdKSk7dD1sKHQscyl9cmV0dXJuIHR9ZnVuY3Rpb24gaCh0LG4scixvKXt2YXIgYSxzLGMsdSxwO2lmKHI9bnVsbCE9ciYmSihyLDAsOCxvLF8pPzB8cjpqLCF0LmMpcmV0dXJuIHQudG9TdHJpbmcoKTtpZihhPXQuY1swXSxjPXQuZSxudWxsPT1uKXA9aSh0LmMpLHA9MTk9PW98fDI0PT1vJiZjPD1xP2YocCxjKTpsKHAsYyk7ZWxzZSBpZih0PVAobmV3IGUodCksbixyKSxzPXQuZSxwPWkodC5jKSx1PXAubGVuZ3RoLDE5PT1vfHwyND09byYmKG48PXN8fHM8PXEpKXtmb3IoO3U8bjtwKz0iMCIsdSsrKTtwPWYocCxzKX1lbHNlIGlmKG4tPWMscD1sKHAscykscysxPnUpe2lmKC0tbj4wKWZvcihwKz0iLiI7bi0tO3ArPSIwIik7fWVsc2UgaWYoKG4rPXMtdSk+MClmb3IocysxPT11JiYocCs9Ii4iKTtuLS07cCs9IjAiKTtyZXR1cm4gdC5zPDAmJmE/Ii0iK3A6cH1mdW5jdGlvbiBPKHQsbil7dmFyIHIsbyxpPTA7Zm9yKGModFswXSkmJih0PXRbMF0pLHI9bmV3IGUodFswXSk7KytpPHQubGVuZ3RoOyl7aWYoIShvPW5ldyBlKHRbaV0pKS5zKXtyPW87YnJlYWt9bi5jYWxsKHIsbykmJihyPW8pfXJldHVybiByfWZ1bmN0aW9uIE4odCxlLG4scixvKXtyZXR1cm4odDxlfHx0Pm58fHQhPXAodCkpJiZJKHIsKG98fCJkZWNpbWFsIHBsYWNlcyIpKyh0PGV8fHQ+bj8iIG91dCBvZiByYW5nZSI6IiBub3QgYW4gaW50ZWdlciIpLHQpLCEwfWZ1bmN0aW9uIFQodCxlLG4pe2Zvcih2YXIgcj0xLG89ZS5sZW5ndGg7IWVbLS1vXTtlLnBvcCgpKTtmb3Iobz1lWzBdO28+PTEwO28vPTEwLHIrKyk7cmV0dXJuKG49cituKkItMSk+VT90LmM9dC5lPW51bGw6bjxMP3QuYz1bdC5lPTBdOih0LmU9bix0LmM9ZSksdH1mdW5jdGlvbiBJKHQsZSxuKXt2YXIgcj1uZXcgRXJyb3IoWyJuZXcgQmlnTnVtYmVyIiwiY21wIiwiY29uZmlnIiwiZGl2IiwiZGl2VG9JbnQiLCJlcSIsImd0IiwiZ3RlIiwibHQiLCJsdGUiLCJtaW51cyIsIm1vZCIsInBsdXMiLCJwcmVjaXNpb24iLCJyYW5kb20iLCJyb3VuZCIsInNoaWZ0IiwidGltZXMiLCJ0b0RpZ2l0cyIsInRvRXhwb25lbnRpYWwiLCJ0b0ZpeGVkIiwidG9Gb3JtYXQiLCJ0b0ZyYWN0aW9uIiwicG93IiwidG9QcmVjaXNpb24iLCJ0b1N0cmluZyIsIkJpZ051bWJlciJdW3RdKyIoKSAiK2UrIjogIituKTt0aHJvdyByLm5hbWU9IkJpZ051bWJlciBFcnJvciIsUj0wLHJ9ZnVuY3Rpb24gUCh0LGUsbixyKXt2YXIgbyxpLGEscyxjLHUsZixsPXQuYyxwPUE7aWYobCl7dDp7Zm9yKG89MSxzPWxbMF07cz49MTA7cy89MTAsbysrKTtpZigoaT1lLW8pPDApaSs9QixhPWUsZj0oYz1sW3U9MF0pL3Bbby1hLTFdJTEwfDA7ZWxzZSBpZigodT1nKChpKzEpL0IpKT49bC5sZW5ndGgpe2lmKCFyKWJyZWFrIHQ7Zm9yKDtsLmxlbmd0aDw9dTtsLnB1c2goMCkpO2M9Zj0wLG89MSxhPShpJT1CKS1CKzF9ZWxzZXtmb3IoYz1zPWxbdV0sbz0xO3M+PTEwO3MvPTEwLG8rKyk7Zj0oYT0oaSU9QiktQitvKTwwPzA6Yy9wW28tYS0xXSUxMHwwfWlmKHI9cnx8ZTwwfHxudWxsIT1sW3UrMV18fChhPDA/YzpjJXBbby1hLTFdKSxyPW48ND8oZnx8cikmJigwPT1ufHxuPT0odC5zPDA/MzoyKSk6Zj41fHw1PT1mJiYoND09bnx8cnx8Nj09biYmKGk+MD9hPjA/Yy9wW28tYV06MDpsW3UtMV0pJTEwJjF8fG49PSh0LnM8MD84OjcpKSxlPDF8fCFsWzBdKXJldHVybiBsLmxlbmd0aD0wLHI/KGUtPXQuZSsxLGxbMF09cFtlJUJdLHQuZT0tZXx8MCk6bFswXT10LmU9MCx0O2lmKDA9PWk/KGwubGVuZ3RoPXUscz0xLHUtLSk6KGwubGVuZ3RoPXUrMSxzPXBbQi1pXSxsW3VdPWE+MD92KGMvcFtvLWFdJXBbYV0pKnM6MCkscilmb3IoOzspe2lmKDA9PXUpe2ZvcihpPTEsYT1sWzBdO2E+PTEwO2EvPTEwLGkrKyk7Zm9yKGE9bFswXSs9cyxzPTE7YT49MTA7YS89MTAscysrKTtpIT1zJiYodC5lKyssbFswXT09ayYmKGxbMF09MSkpO2JyZWFrfWlmKGxbdV0rPXMsbFt1XSE9aylicmVhaztsW3UtLV09MCxzPTF9Zm9yKGk9bC5sZW5ndGg7MD09PWxbLS1pXTtsLnBvcCgpKTt9dC5lPlU/dC5jPXQuZT1udWxsOnQuZTxMJiYodC5jPVt0LmU9MF0pfXJldHVybiB0fXZhciBELFI9MCxFPWUucHJvdG90eXBlLE09bmV3IGUoMSksSD0yMCxqPTQscT0tNyx6PTIxLEw9LTFlNyxVPTFlNyxXPSEwLEo9TixLPSExLEc9MSxYPTEwMCwkPXtkZWNpbWFsU2VwYXJhdG9yOiIuIixncm91cFNlcGFyYXRvcjoiLCIsZ3JvdXBTaXplOjMsc2Vjb25kYXJ5R3JvdXBTaXplOjAsZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjoiwqAiLGZyYWN0aW9uR3JvdXBTaXplOjB9O3JldHVybiBlLmFub3RoZXI9cixlLlJPVU5EX1VQPTAsZS5ST1VORF9ET1dOPTEsZS5ST1VORF9DRUlMPTIsZS5ST1VORF9GTE9PUj0zLGUuUk9VTkRfSEFMRl9VUD00LGUuUk9VTkRfSEFMRl9ET1dOPTUsZS5ST1VORF9IQUxGX0VWRU49NixlLlJPVU5EX0hBTEZfQ0VJTD03LGUuUk9VTkRfSEFMRl9GTE9PUj04LGUuRVVDTElEPTksZS5jb25maWc9ZnVuY3Rpb24oKXt2YXIgdCxlLG49MCxyPXt9LG89YXJndW1lbnRzLGk9b1swXSxhPWkmJiJvYmplY3QiPT10eXBlb2YgaT9mdW5jdGlvbigpe2lmKGkuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuIG51bGwhPSh0PWlbZV0pfTpmdW5jdGlvbigpe2lmKG8ubGVuZ3RoPm4pcmV0dXJuIG51bGwhPSh0PW9bbisrXSl9O3JldHVybiBhKGU9IkRFQ0lNQUxfUExBQ0VTIikmJkoodCwwLEYsMixlKSYmKEg9MHx0KSxyW2VdPUgsYShlPSJST1VORElOR19NT0RFIikmJkoodCwwLDgsMixlKSYmKGo9MHx0KSxyW2VdPWosYShlPSJFWFBPTkVOVElBTF9BVCIpJiYoYyh0KT9KKHRbMF0sLUYsMCwyLGUpJiZKKHRbMV0sMCxGLDIsZSkmJihxPTB8dFswXSx6PTB8dFsxXSk6Sih0LC1GLEYsMixlKSYmKHE9LSh6PTB8KHQ8MD8tdDp0KSkpKSxyW2VdPVtxLHpdLGEoZT0iUkFOR0UiKSYmKGModCk/Sih0WzBdLC1GLC0xLDIsZSkmJkoodFsxXSwxLEYsMixlKSYmKEw9MHx0WzBdLFU9MHx0WzFdKTpKKHQsLUYsRiwyLGUpJiYoMHx0P0w9LShVPTB8KHQ8MD8tdDp0KSk6VyYmSSgyLGUrIiBjYW5ub3QgYmUgemVybyIsdCkpKSxyW2VdPVtMLFVdLGEoZT0iRVJST1JTIikmJih0PT09ISF0fHwxPT09dHx8MD09PXQ/KFI9MCxKPShXPSEhdCk/TjpzKTpXJiZJKDIsZStiLHQpKSxyW2VdPVcsYShlPSJDUllQVE8iKSYmKHQ9PT0hIXR8fDE9PT10fHwwPT09dD8oSz0hKCF0fHwhZHx8Im9iamVjdCIhPXR5cGVvZiBkKSx0JiYhSyYmVyYmSSgyLCJjcnlwdG8gdW5hdmFpbGFibGUiLGQpKTpXJiZJKDIsZStiLHQpKSxyW2VdPUssYShlPSJNT0RVTE9fTU9ERSIpJiZKKHQsMCw5LDIsZSkmJihHPTB8dCkscltlXT1HLGEoZT0iUE9XX1BSRUNJU0lPTiIpJiZKKHQsMCxGLDIsZSkmJihYPTB8dCkscltlXT1YLGEoZT0iRk9STUFUIikmJigib2JqZWN0Ij09dHlwZW9mIHQ/JD10OlcmJkkoMixlKyIgbm90IGFuIG9iamVjdCIsdCkpLHJbZV09JCxyfSxlLm1heD1mdW5jdGlvbigpe3JldHVybiBPKGFyZ3VtZW50cyxFLmx0KX0sZS5taW49ZnVuY3Rpb24oKXtyZXR1cm4gTyhhcmd1bWVudHMsRS5ndCl9LGUucmFuZG9tPWZ1bmN0aW9uKCl7dmFyIHQ9OTAwNzE5OTI1NDc0MDk5MipNYXRoLnJhbmRvbSgpJjIwOTcxNTE/ZnVuY3Rpb24oKXtyZXR1cm4gdig5MDA3MTk5MjU0NzQwOTkyKk1hdGgucmFuZG9tKCkpfTpmdW5jdGlvbigpe3JldHVybiA4Mzg4NjA4KigxMDczNzQxODI0Kk1hdGgucmFuZG9tKCl8MCkrKDgzODg2MDgqTWF0aC5yYW5kb20oKXwwKX07cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciByLG8saSxhLHMsYz0wLHU9W10sZj1uZXcgZShNKTtpZihuPW51bGwhPW4mJkoobiwwLEYsMTQpPzB8bjpILGE9ZyhuL0IpLEspaWYoZCYmZC5nZXRSYW5kb21WYWx1ZXMpe2ZvcihyPWQuZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShhKj0yKSk7YzxhOykocz0xMzEwNzIqcltjXSsocltjKzFdPj4+MTEpKT49OWUxNT8obz1kLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpLHJbY109b1swXSxyW2MrMV09b1sxXSk6KHUucHVzaChzJTFlMTQpLGMrPTIpO2M9YS8yfWVsc2UgaWYoZCYmZC5yYW5kb21CeXRlcyl7Zm9yKHI9ZC5yYW5kb21CeXRlcyhhKj03KTtjPGE7KShzPTI4MTQ3NDk3NjcxMDY1NiooMzEmcltjXSkrMTA5OTUxMTYyNzc3NipyW2MrMV0rNDI5NDk2NzI5NipyW2MrMl0rMTY3NzcyMTYqcltjKzNdKyhyW2MrNF08PDE2KSsocltjKzVdPDw4KStyW2MrNl0pPj05ZTE1P2QucmFuZG9tQnl0ZXMoNykuY29weShyLGMpOih1LnB1c2gocyUxZTE0KSxjKz03KTtjPWEvN31lbHNlIFcmJkkoMTQsImNyeXB0byB1bmF2YWlsYWJsZSIsZCk7aWYoIWMpZm9yKDtjPGE7KShzPXQoKSk8OWUxNSYmKHVbYysrXT1zJTFlMTQpO2ZvcihhPXVbLS1jXSxuJT1CLGEmJm4mJihzPUFbQi1uXSx1W2NdPXYoYS9zKSpzKTswPT09dVtjXTt1LnBvcCgpLGMtLSk7aWYoYzwwKXU9W2k9MF07ZWxzZXtmb3IoaT0tMTswPT09dVswXTt1LnNoaWZ0KCksaS09Qik7Zm9yKGM9MSxzPXVbMF07cz49MTA7cy89MTAsYysrKTtjPEImJihpLT1CLWMpfXJldHVybiBmLmU9aSxmLmM9dSxmfX0oKSxEPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gdCh0LGUsbil7dmFyIHIsbyxpLGEscz0wLGM9dC5sZW5ndGgsdT1lJUMsZj1lL0N8MDtmb3IodD10LnNsaWNlKCk7Yy0tOylzPSgobz11KihpPXRbY10lQykrKHI9ZippKyhhPXRbY10vQ3wwKSp1KSVDKkMrcykvbnwwKSsoci9DfDApK2YqYSx0W2NdPW8lbjtyZXR1cm4gcyYmdC51bnNoaWZ0KHMpLHR9ZnVuY3Rpb24gbih0LGUsbixyKXt2YXIgbyxpO2lmKG4hPXIpaT1uPnI/MTotMTtlbHNlIGZvcihvPWk9MDtvPG47bysrKWlmKHRbb10hPWVbb10pe2k9dFtvXT5lW29dPzE6LTE7YnJlYWt9cmV0dXJuIGl9ZnVuY3Rpb24gcih0LGUsbixyKXtmb3IodmFyIG89MDtuLS07KXRbbl0tPW8sbz10W25dPGVbbl0/MTowLHRbbl09bypyK3Rbbl0tZVtuXTtmb3IoOyF0WzBdJiZ0Lmxlbmd0aD4xO3Quc2hpZnQoKSk7fXJldHVybiBmdW5jdGlvbihpLGEscyxjLHUpe3ZhciBmLGwscCxoLGQsbSx5LGcsYixfLHcseCxTLEEsQyxGLE8sTj1pLnM9PWEucz8xOi0xLFQ9aS5jLEk9YS5jO2lmKCEoVCYmVFswXSYmSSYmSVswXSkpcmV0dXJuIG5ldyBlKGkucyYmYS5zJiYoVD8hSXx8VFswXSE9SVswXTpJKT9UJiYwPT1UWzBdfHwhST8wKk46Ti8wOk5hTik7Zm9yKGI9KGc9bmV3IGUoTikpLmM9W10sTj1zKyhsPWkuZS1hLmUpKzEsdXx8KHU9ayxsPW8oaS5lL0IpLW8oYS5lL0IpLE49Ti9CfDApLHA9MDtJW3BdPT0oVFtwXXx8MCk7cCsrKTtpZihJW3BdPihUW3BdfHwwKSYmbC0tLE48MCliLnB1c2goMSksaD0hMDtlbHNle2ZvcihBPVQubGVuZ3RoLEY9SS5sZW5ndGgscD0wLE4rPTIsKGQ9dih1LyhJWzBdKzEpKSk+MSYmKEk9dChJLGQsdSksVD10KFQsZCx1KSxGPUkubGVuZ3RoLEE9VC5sZW5ndGgpLFM9Rix3PShfPVQuc2xpY2UoMCxGKSkubGVuZ3RoO3c8RjtfW3crK109MCk7KE89SS5zbGljZSgpKS51bnNoaWZ0KDApLEM9SVswXSxJWzFdPj11LzImJkMrKztkb3tpZihkPTAsKGY9bihJLF8sRix3KSk8MCl7aWYoeD1fWzBdLEYhPXcmJih4PXgqdSsoX1sxXXx8MCkpLChkPXYoeC9DKSk+MSlmb3IoZD49dSYmKGQ9dS0xKSx5PShtPXQoSSxkLHUpKS5sZW5ndGgsdz1fLmxlbmd0aDsxPT1uKG0sXyx5LHcpOylkLS0scihtLEY8eT9POkkseSx1KSx5PW0ubGVuZ3RoLGY9MTtlbHNlIDA9PWQmJihmPWQ9MSkseT0obT1JLnNsaWNlKCkpLmxlbmd0aDtpZih5PHcmJm0udW5zaGlmdCgwKSxyKF8sbSx3LHUpLHc9Xy5sZW5ndGgsLTE9PWYpZm9yKDtuKEksXyxGLHcpPDE7KWQrKyxyKF8sRjx3P086SSx3LHUpLHc9Xy5sZW5ndGh9ZWxzZSAwPT09ZiYmKGQrKyxfPVswXSk7YltwKytdPWQsX1swXT9fW3crK109VFtTXXx8MDooXz1bVFtTXV0sdz0xKX13aGlsZSgoUysrPEF8fG51bGwhPV9bMF0pJiZOLS0pO2g9bnVsbCE9X1swXSxiWzBdfHxiLnNoaWZ0KCl9aWYodT09ayl7Zm9yKHA9MSxOPWJbMF07Tj49MTA7Ti89MTAscCsrKTtQKGcscysoZy5lPXArbCpCLTEpKzEsYyxoKX1lbHNlIGcuZT1sLGcucj0raDtyZXR1cm4gZ319KCksbT1mdW5jdGlvbigpe3ZhciB0PS9eKC0/KTAoW3hib10pL2ksbj0vXihbXi5dKylcLiQvLHI9L15cLihbXi5dKykkLyxvPS9eLT8oSW5maW5pdHl8TmFOKSQvLGk9L15ccypcK3xeXHMrfFxzKyQvZztyZXR1cm4gZnVuY3Rpb24oYSxzLGMsdSl7dmFyIGYsbD1jP3M6cy5yZXBsYWNlKGksIiIpO2lmKG8udGVzdChsKSlhLnM9aXNOYU4obCk/bnVsbDpsPDA/LTE6MTtlbHNle2lmKCFjJiYobD1sLnJlcGxhY2UodCxmdW5jdGlvbih0LGUsbil7cmV0dXJuIGY9IngiPT0obj1uLnRvTG93ZXJDYXNlKCkpPzE2OiJiIj09bj8yOjgsdSYmdSE9Zj90OmV9KSx1JiYoZj11LGw9bC5yZXBsYWNlKG4sIiQxIikucmVwbGFjZShyLCIwLiQxIikpLHMhPWwpKXJldHVybiBuZXcgZShsLGYpO1cmJkkoUiwibm90IGEiKyh1PyIgYmFzZSAiK3U6IiIpKyIgbnVtYmVyIixzKSxhLnM9bnVsbH1hLmM9YS5lPW51bGwsUj0wfX0oKSxFLmFic29sdXRlVmFsdWU9RS5hYnM9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgZSh0aGlzKTtyZXR1cm4gdC5zPDAmJih0LnM9MSksdH0sRS5jZWlsPWZ1bmN0aW9uKCl7cmV0dXJuIFAobmV3IGUodGhpcyksdGhpcy5lKzEsMil9LEUuY29tcGFyZWRUbz1FLmNtcD1mdW5jdGlvbih0LG4pe3JldHVybiBSPTEsYSh0aGlzLG5ldyBlKHQsbikpfSxFLmRlY2ltYWxQbGFjZXM9RS5kcD1mdW5jdGlvbigpe3ZhciB0LGUsbj10aGlzLmM7aWYoIW4pcmV0dXJuIG51bGw7aWYodD0oKGU9bi5sZW5ndGgtMSktbyh0aGlzLmUvQikpKkIsZT1uW2VdKWZvcig7ZSUxMD09MDtlLz0xMCx0LS0pO3JldHVybiB0PDAmJih0PTApLHR9LEUuZGl2aWRlZEJ5PUUuZGl2PWZ1bmN0aW9uKHQsbil7cmV0dXJuIFI9MyxEKHRoaXMsbmV3IGUodCxuKSxILGopfSxFLmRpdmlkZWRUb0ludGVnZXJCeT1FLmRpdlRvSW50PWZ1bmN0aW9uKHQsbil7cmV0dXJuIFI9NCxEKHRoaXMsbmV3IGUodCxuKSwwLDEpfSxFLmVxdWFscz1FLmVxPWZ1bmN0aW9uKHQsbil7cmV0dXJuIFI9NSwwPT09YSh0aGlzLG5ldyBlKHQsbikpfSxFLmZsb29yPWZ1bmN0aW9uKCl7cmV0dXJuIFAobmV3IGUodGhpcyksdGhpcy5lKzEsMyl9LEUuZ3JlYXRlclRoYW49RS5ndD1mdW5jdGlvbih0LG4pe3JldHVybiBSPTYsYSh0aGlzLG5ldyBlKHQsbikpPjB9LEUuZ3JlYXRlclRoYW5PckVxdWFsVG89RS5ndGU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gUj03LDE9PT0obj1hKHRoaXMsbmV3IGUodCxuKSkpfHwwPT09bn0sRS5pc0Zpbml0ZT1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5jfSxFLmlzSW50ZWdlcj1FLmlzSW50PWZ1bmN0aW9uKCl7cmV0dXJuISF0aGlzLmMmJm8odGhpcy5lL0IpPnRoaXMuYy5sZW5ndGgtMn0sRS5pc05hTj1mdW5jdGlvbigpe3JldHVybiF0aGlzLnN9LEUuaXNOZWdhdGl2ZT1FLmlzTmVnPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuczwwfSxFLmlzWmVybz1mdW5jdGlvbigpe3JldHVybiEhdGhpcy5jJiYwPT10aGlzLmNbMF19LEUubGVzc1RoYW49RS5sdD1mdW5jdGlvbih0LG4pe3JldHVybiBSPTgsYSh0aGlzLG5ldyBlKHQsbikpPDB9LEUubGVzc1RoYW5PckVxdWFsVG89RS5sdGU9ZnVuY3Rpb24odCxuKXtyZXR1cm4gUj05LC0xPT09KG49YSh0aGlzLG5ldyBlKHQsbikpKXx8MD09PW59LEUubWludXM9RS5zdWI9ZnVuY3Rpb24odCxuKXt2YXIgcixpLGEscyxjPXRoaXMucztpZihSPTEwLHQ9bmV3IGUodCxuKSxuPXQucywhY3x8IW4pcmV0dXJuIG5ldyBlKE5hTik7aWYoYyE9bilyZXR1cm4gdC5zPS1uLHRoaXMucGx1cyh0KTt2YXIgdT10aGlzLmUvQixmPXQuZS9CLGw9dGhpcy5jLHA9dC5jO2lmKCF1fHwhZil7aWYoIWx8fCFwKXJldHVybiBsPyh0LnM9LW4sdCk6bmV3IGUocD90aGlzOk5hTik7aWYoIWxbMF18fCFwWzBdKXJldHVybiBwWzBdPyh0LnM9LW4sdCk6bmV3IGUobFswXT90aGlzOjM9PWo/LTA6MCl9aWYodT1vKHUpLGY9byhmKSxsPWwuc2xpY2UoKSxjPXUtZil7Zm9yKChzPWM8MCk/KGM9LWMsYT1sKTooZj11LGE9cCksYS5yZXZlcnNlKCksbj1jO24tLTthLnB1c2goMCkpO2EucmV2ZXJzZSgpfWVsc2UgZm9yKGk9KHM9KGM9bC5sZW5ndGgpPChuPXAubGVuZ3RoKSk/YzpuLGM9bj0wO248aTtuKyspaWYobFtuXSE9cFtuXSl7cz1sW25dPHBbbl07YnJlYWt9aWYocyYmKGE9bCxsPXAscD1hLHQucz0tdC5zKSwobj0oaT1wLmxlbmd0aCktKHI9bC5sZW5ndGgpKT4wKWZvcig7bi0tO2xbcisrXT0wKTtmb3Iobj1rLTE7aT5jOyl7aWYobFstLWldPHBbaV0pe2ZvcihyPWk7ciYmIWxbLS1yXTtsW3JdPW4pOy0tbFtyXSxsW2ldKz1rfWxbaV0tPXBbaV19Zm9yKDswPT1sWzBdO2wuc2hpZnQoKSwtLWYpO3JldHVybiBsWzBdP1QodCxsLGYpOih0LnM9Mz09aj8tMToxLHQuYz1bdC5lPTBdLHQpfSxFLm1vZHVsbz1FLm1vZD1mdW5jdGlvbih0LG4pe3ZhciByLG87cmV0dXJuIFI9MTEsdD1uZXcgZSh0LG4pLCF0aGlzLmN8fCF0LnN8fHQuYyYmIXQuY1swXT9uZXcgZShOYU4pOiF0LmN8fHRoaXMuYyYmIXRoaXMuY1swXT9uZXcgZSh0aGlzKTooOT09Rz8obz10LnMsdC5zPTEscj1EKHRoaXMsdCwwLDMpLHQucz1vLHIucyo9byk6cj1EKHRoaXMsdCwwLEcpLHRoaXMubWludXMoci50aW1lcyh0KSkpfSxFLm5lZ2F0ZWQ9RS5uZWc9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgZSh0aGlzKTtyZXR1cm4gdC5zPS10LnN8fG51bGwsdH0sRS5wbHVzPUUuYWRkPWZ1bmN0aW9uKHQsbil7dmFyIHIsaT10aGlzLnM7aWYoUj0xMix0PW5ldyBlKHQsbiksbj10LnMsIWl8fCFuKXJldHVybiBuZXcgZShOYU4pO2lmKGkhPW4pcmV0dXJuIHQucz0tbix0aGlzLm1pbnVzKHQpO3ZhciBhPXRoaXMuZS9CLHM9dC5lL0IsYz10aGlzLmMsdT10LmM7aWYoIWF8fCFzKXtpZighY3x8IXUpcmV0dXJuIG5ldyBlKGkvMCk7aWYoIWNbMF18fCF1WzBdKXJldHVybiB1WzBdP3Q6bmV3IGUoY1swXT90aGlzOjAqaSl9aWYoYT1vKGEpLHM9byhzKSxjPWMuc2xpY2UoKSxpPWEtcyl7Zm9yKGk+MD8ocz1hLHI9dSk6KGk9LWkscj1jKSxyLnJldmVyc2UoKTtpLS07ci5wdXNoKDApKTtyLnJldmVyc2UoKX1mb3IoKGk9Yy5sZW5ndGgpLShuPXUubGVuZ3RoKTwwJiYocj11LHU9YyxjPXIsbj1pKSxpPTA7bjspaT0oY1stLW5dPWNbbl0rdVtuXStpKS9rfDAsY1tuXSU9aztyZXR1cm4gaSYmKGMudW5zaGlmdChpKSwrK3MpLFQodCxjLHMpfSxFLnByZWNpc2lvbj1FLnNkPWZ1bmN0aW9uKHQpe3ZhciBlLG4scj10aGlzLmM7aWYobnVsbCE9dCYmdCE9PSEhdCYmMSE9PXQmJjAhPT10JiYoVyYmSSgxMywiYXJndW1lbnQiK2IsdCksdCE9ISF0JiYodD1udWxsKSksIXIpcmV0dXJuIG51bGw7aWYobj1yLmxlbmd0aC0xLGU9bipCKzEsbj1yW25dKXtmb3IoO24lMTA9PTA7bi89MTAsZS0tKTtmb3Iobj1yWzBdO24+PTEwO24vPTEwLGUrKyk7fXJldHVybiB0JiZ0aGlzLmUrMT5lJiYoZT10aGlzLmUrMSksZX0sRS5yb3VuZD1mdW5jdGlvbih0LG4pe3ZhciByPW5ldyBlKHRoaXMpO3JldHVybihudWxsPT10fHxKKHQsMCxGLDE1KSkmJlAocix+fnQrdGhpcy5lKzEsbnVsbCE9biYmSihuLDAsOCwxNSxfKT8wfG46aikscn0sRS5zaGlmdD1mdW5jdGlvbih0KXtyZXR1cm4gSih0LC1TLFMsMTYsImFyZ3VtZW50Iik/dGhpcy50aW1lcygiMWUiK3AodCkpOm5ldyBlKHRoaXMuYyYmdGhpcy5jWzBdJiYodDwtU3x8dD5TKT90aGlzLnMqKHQ8MD8wOjEvMCk6dGhpcyl9LEUuc3F1YXJlUm9vdD1FLnNxcnQ9ZnVuY3Rpb24oKXt2YXIgdCxuLHIsYSxzLGM9dGhpcy5jLHU9dGhpcy5zLGY9dGhpcy5lLGw9SCs0LHA9bmV3IGUoIjAuNSIpO2lmKDEhPT11fHwhY3x8IWNbMF0pcmV0dXJuIG5ldyBlKCF1fHx1PDAmJighY3x8Y1swXSk/TmFOOmM/dGhpczoxLzApO2lmKDA9PSh1PU1hdGguc3FydCgrdGhpcykpfHx1PT0xLzA/KCgobj1pKGMpKS5sZW5ndGgrZiklMj09MCYmKG4rPSIwIiksdT1NYXRoLnNxcnQobiksZj1vKChmKzEpLzIpLShmPDB8fGYlMikscj1uZXcgZShuPXU9PTEvMD8iMWUiK2Y6KG49dS50b0V4cG9uZW50aWFsKCkpLnNsaWNlKDAsbi5pbmRleE9mKCJlIikrMSkrZikpOnI9bmV3IGUodSsiIiksci5jWzBdKWZvcigodT0oZj1yLmUpK2wpPDMmJih1PTApOzspaWYocz1yLHI9cC50aW1lcyhzLnBsdXMoRCh0aGlzLHMsbCwxKSkpLGkocy5jKS5zbGljZSgwLHUpPT09KG49aShyLmMpKS5zbGljZSgwLHUpKXtpZihyLmU8ZiYmLS11LCI5OTk5IiE9KG49bi5zbGljZSh1LTMsdSsxKSkmJihhfHwiNDk5OSIhPW4pKXsrbiYmKCtuLnNsaWNlKDEpfHwiNSIhPW4uY2hhckF0KDApKXx8KFAocixyLmUrSCsyLDEpLHQ9IXIudGltZXMocikuZXEodGhpcykpO2JyZWFrfWlmKCFhJiYoUChzLHMuZStIKzIsMCkscy50aW1lcyhzKS5lcSh0aGlzKSkpe3I9czticmVha31sKz00LHUrPTQsYT0xfXJldHVybiBQKHIsci5lK0grMSxqLHQpfSxFLnRpbWVzPUUubXVsPWZ1bmN0aW9uKHQsbil7dmFyIHIsaSxhLHMsYyx1LGYsbCxwLGgsZCxtLHksZyx2LGI9dGhpcy5jLF89KFI9MTcsdD1uZXcgZSh0LG4pKS5jO2lmKCEoYiYmXyYmYlswXSYmX1swXSkpcmV0dXJuIXRoaXMuc3x8IXQuc3x8YiYmIWJbMF0mJiFffHxfJiYhX1swXSYmIWI/dC5jPXQuZT10LnM9bnVsbDoodC5zKj10aGlzLnMsYiYmXz8odC5jPVswXSx0LmU9MCk6dC5jPXQuZT1udWxsKSx0O2ZvcihpPW8odGhpcy5lL0IpK28odC5lL0IpLHQucyo9dGhpcy5zLChmPWIubGVuZ3RoKTwoaD1fLmxlbmd0aCkmJih5PWIsYj1fLF89eSxhPWYsZj1oLGg9YSksYT1mK2gseT1bXTthLS07eS5wdXNoKDApKTtmb3IoZz1rLHY9QyxhPWg7LS1hPj0wOyl7Zm9yKHI9MCxkPV9bYV0ldixtPV9bYV0vdnwwLHM9YSsoYz1mKTtzPmE7KXI9KChsPWQqKGw9YlstLWNdJXYpKyh1PW0qbCsocD1iW2NdL3Z8MCkqZCkldip2K3lbc10rcikvZ3wwKSsodS92fDApK20qcCx5W3MtLV09bCVnO3lbc109cn1yZXR1cm4gcj8rK2k6eS5zaGlmdCgpLFQodCx5LGkpfSxFLnRvRGlnaXRzPWZ1bmN0aW9uKHQsbil7dmFyIHI9bmV3IGUodGhpcyk7cmV0dXJuIHQ9bnVsbCE9dCYmSih0LDEsRiwxOCwicHJlY2lzaW9uIik/MHx0Om51bGwsbj1udWxsIT1uJiZKKG4sMCw4LDE4LF8pPzB8bjpqLHQ/UChyLHQsbik6cn0sRS50b0V4cG9uZW50aWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGgodGhpcyxudWxsIT10JiZKKHQsMCxGLDE5KT8xK35+dDpudWxsLGUsMTkpfSxFLnRvRml4ZWQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaCh0aGlzLG51bGwhPXQmJkoodCwwLEYsMjApP35+dCt0aGlzLmUrMTpudWxsLGUsMjApfSxFLnRvRm9ybWF0PWZ1bmN0aW9uKHQsZSl7dmFyIG49aCh0aGlzLG51bGwhPXQmJkoodCwwLEYsMjEpP35+dCt0aGlzLmUrMTpudWxsLGUsMjEpO2lmKHRoaXMuYyl7dmFyIHIsbz1uLnNwbGl0KCIuIiksaT0rJC5ncm91cFNpemUsYT0rJC5zZWNvbmRhcnlHcm91cFNpemUscz0kLmdyb3VwU2VwYXJhdG9yLGM9b1swXSx1PW9bMV0sZj10aGlzLnM8MCxsPWY/Yy5zbGljZSgxKTpjLHA9bC5sZW5ndGg7aWYoYSYmKHI9aSxpPWEsYT1yLHAtPXIpLGk+MCYmcD4wKXtmb3Iocj1wJWl8fGksYz1sLnN1YnN0cigwLHIpO3I8cDtyKz1pKWMrPXMrbC5zdWJzdHIocixpKTthPjAmJihjKz1zK2wuc2xpY2UocikpLGYmJihjPSItIitjKX1uPXU/YyskLmRlY2ltYWxTZXBhcmF0b3IrKChhPSskLmZyYWN0aW9uR3JvdXBTaXplKT91LnJlcGxhY2UobmV3IFJlZ0V4cCgiXFxkeyIrYSsifVxcQiIsImciKSwiJCYiKyQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvcik6dSk6Y31yZXR1cm4gbn0sRS50b0ZyYWN0aW9uPWZ1bmN0aW9uKHQpe3ZhciBuLHIsbyxhLHMsYyx1LGYsbCxwPVcsaD10aGlzLmMsZD1uZXcgZShNKSxtPXI9bmV3IGUoTSkseT11PW5ldyBlKE0pO2lmKG51bGwhPXQmJihXPSExLGM9bmV3IGUodCksVz1wLChwPWMuaXNJbnQoKSkmJiFjLmx0KE0pfHwoVyYmSSgyMiwibWF4IGRlbm9taW5hdG9yICIrKHA/Im91dCBvZiByYW5nZSI6Im5vdCBhbiBpbnRlZ2VyIiksdCksdD0hcCYmYy5jJiZQKGMsYy5lKzEsMSkuZ3RlKE0pP2M6bnVsbCkpLCFoKXJldHVybiB0aGlzLnRvU3RyaW5nKCk7Zm9yKGw9aShoKSxhPWQuZT1sLmxlbmd0aC10aGlzLmUtMSxkLmNbMF09QVsocz1hJUIpPDA/QitzOnNdLHQ9IXR8fGMuY21wKGQpPjA/YT4wP2Q6bTpjLHM9VSxVPTEvMCxjPW5ldyBlKGwpLHUuY1swXT0wO2Y9RChjLGQsMCwxKSwxIT0obz1yLnBsdXMoZi50aW1lcyh5KSkpLmNtcCh0KTspcj15LHk9byxtPXUucGx1cyhmLnRpbWVzKG89bSkpLHU9byxkPWMubWludXMoZi50aW1lcyhvPWQpKSxjPW87cmV0dXJuIG89RCh0Lm1pbnVzKHIpLHksMCwxKSx1PXUucGx1cyhvLnRpbWVzKG0pKSxyPXIucGx1cyhvLnRpbWVzKHkpKSx1LnM9bS5zPXRoaXMucyxhKj0yLG49RChtLHksYSxqKS5taW51cyh0aGlzKS5hYnMoKS5jbXAoRCh1LHIsYSxqKS5taW51cyh0aGlzKS5hYnMoKSk8MT9bbS50b1N0cmluZygpLHkudG9TdHJpbmcoKV06W3UudG9TdHJpbmcoKSxyLnRvU3RyaW5nKCldLFU9cyxufSxFLnRvTnVtYmVyPWZ1bmN0aW9uKCl7cmV0dXJuK3RoaXN8fCh0aGlzLnM/MCp0aGlzLnM6TmFOKX0sRS50b1Bvd2VyPUUucG93PWZ1bmN0aW9uKHQpe3ZhciBuLHIsbz12KHQ8MD8tdDordCksaT10aGlzO2lmKCFKKHQsLVMsUywyMywiZXhwb25lbnQiKSYmKCFpc0Zpbml0ZSh0KXx8bz5TJiYodC89MCl8fHBhcnNlRmxvYXQodCkhPXQmJiEodD1OYU4pKSlyZXR1cm4gbmV3IGUoTWF0aC5wb3coK2ksdCkpO2ZvcihuPVg/ZyhYL0IrMik6MCxyPW5ldyBlKE0pOzspe2lmKG8lMil7aWYoIShyPXIudGltZXMoaSkpLmMpYnJlYWs7biYmci5jLmxlbmd0aD5uJiYoci5jLmxlbmd0aD1uKX1pZighKG89dihvLzIpKSlicmVhaztpPWkudGltZXMoaSksbiYmaS5jJiZpLmMubGVuZ3RoPm4mJihpLmMubGVuZ3RoPW4pfXJldHVybiB0PDAmJihyPU0uZGl2KHIpKSxuP1AocixYLGopOnJ9LEUudG9QcmVjaXNpb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gaCh0aGlzLG51bGwhPXQmJkoodCwxLEYsMjQsInByZWNpc2lvbiIpPzB8dDpudWxsLGUsMjQpfSxFLnRvU3RyaW5nPWZ1bmN0aW9uKHQpe3ZhciBlLHI9dGhpcy5zLG89dGhpcy5lO3JldHVybiBudWxsPT09bz9yPyhlPSJJbmZpbml0eSIscjwwJiYoZT0iLSIrZSkpOmU9Ik5hTiI6KGU9aSh0aGlzLmMpLGU9bnVsbCE9dCYmSih0LDIsNjQsMjUsImJhc2UiKT9uKGwoZSxvKSwwfHQsMTAscik6bzw9cXx8bz49ej9mKGUsbyk6bChlLG8pLHI8MCYmdGhpcy5jWzBdJiYoZT0iLSIrZSkpLGV9LEUudHJ1bmNhdGVkPUUudHJ1bmM9ZnVuY3Rpb24oKXtyZXR1cm4gUChuZXcgZSh0aGlzKSx0aGlzLmUrMSwxKX0sRS52YWx1ZU9mPUUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9TdHJpbmcoKX0sbnVsbCE9dCYmZS5jb25maWcodCksZX1mdW5jdGlvbiBvKHQpe3ZhciBlPTB8dDtyZXR1cm4gdD4wfHx0PT09ZT9lOmUtMX1mdW5jdGlvbiBpKHQpe2Zvcih2YXIgZSxuLHI9MSxvPXQubGVuZ3RoLGk9dFswXSsiIjtyPG87KXtmb3IoZT10W3IrK10rIiIsbj1CLWUubGVuZ3RoO24tLTtlPSIwIitlKTtpKz1lfWZvcihvPWkubGVuZ3RoOzQ4PT09aS5jaGFyQ29kZUF0KC0tbyk7KTtyZXR1cm4gaS5zbGljZSgwLG8rMXx8MSl9ZnVuY3Rpb24gYSh0LGUpe3ZhciBuLHIsbz10LmMsaT1lLmMsYT10LnMscz1lLnMsYz10LmUsdT1lLmU7aWYoIWF8fCFzKXJldHVybiBudWxsO2lmKG49byYmIW9bMF0scj1pJiYhaVswXSxufHxyKXJldHVybiBuP3I/MDotczphO2lmKGEhPXMpcmV0dXJuIGE7aWYobj1hPDAscj1jPT11LCFvfHwhaSlyZXR1cm4gcj8wOiFvXm4/MTotMTtpZighcilyZXR1cm4gYz51Xm4/MTotMTtmb3Iocz0oYz1vLmxlbmd0aCk8KHU9aS5sZW5ndGgpP2M6dSxhPTA7YTxzO2ErKylpZihvW2FdIT1pW2FdKXJldHVybiBvW2FdPmlbYV1ebj8xOi0xO3JldHVybiBjPT11PzA6Yz51Xm4/MTotMX1mdW5jdGlvbiBzKHQsZSxuKXtyZXR1cm4odD1wKHQpKT49ZSYmdDw9bn1mdW5jdGlvbiBjKHQpe3JldHVybiJbb2JqZWN0IEFycmF5XSI9PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1mdW5jdGlvbiB1KHQsZSxuKXtmb3IodmFyIHIsbyxpPVswXSxhPTAscz10Lmxlbmd0aDthPHM7KXtmb3Iobz1pLmxlbmd0aDtvLS07aVtvXSo9ZSk7Zm9yKGlbcj0wXSs9eC5pbmRleE9mKHQuY2hhckF0KGErKykpO3I8aS5sZW5ndGg7cisrKWlbcl0+bi0xJiYobnVsbD09aVtyKzFdJiYoaVtyKzFdPTApLGlbcisxXSs9aVtyXS9ufDAsaVtyXSU9bil9cmV0dXJuIGkucmV2ZXJzZSgpfWZ1bmN0aW9uIGYodCxlKXtyZXR1cm4odC5sZW5ndGg+MT90LmNoYXJBdCgwKSsiLiIrdC5zbGljZSgxKTp0KSsoZTwwPyJlIjoiZSsiKStlfWZ1bmN0aW9uIGwodCxlKXt2YXIgbixyO2lmKGU8MCl7Zm9yKHI9IjAuIjsrK2U7cis9IjAiKTt0PXIrdH1lbHNlIGlmKG49dC5sZW5ndGgsKytlPm4pe2ZvcihyPSIwIixlLT1uOy0tZTtyKz0iMCIpO3QrPXJ9ZWxzZSBlPG4mJih0PXQuc2xpY2UoMCxlKSsiLiIrdC5zbGljZShlKSk7cmV0dXJuIHR9ZnVuY3Rpb24gcCh0KXtyZXR1cm4odD1wYXJzZUZsb2F0KHQpKTwwP2codCk6dih0KX12YXIgaCxkLG0seT0vXi0/KFxkKyhcLlxkKik/fFwuXGQrKShlWystXT9cZCspPyQvaSxnPU1hdGguY2VpbCx2PU1hdGguZmxvb3IsYj0iIG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0IixfPSJyb3VuZGluZyBtb2RlIix3PSJudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0cyIseD0iMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVokXyIsaz0xZTE0LEI9MTQsUz05MDA3MTk5MjU0NzQwOTkxLEE9WzEsMTAsMTAwLDFlMywxZTQsMWU1LDFlNiwxZTcsMWU4LDFlOSwxZTEwLDFlMTEsMWUxMiwxZTEzXSxDPTFlNyxGPTFlOTtpZihoPXIoKSwiZnVuY3Rpb24iPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShmdW5jdGlvbigpe3JldHVybiBofSk7ZWxzZSBpZih2b2lkIDAhPT1lJiZlLmV4cG9ydHMpe2lmKGUuZXhwb3J0cz1oLCFkKXRyeXtkPXQoImNyeXB0byIpfWNhdGNoKHQpe319ZWxzZSBuLkJpZ051bWJlcj1ofSh0aGlzKX0se2NyeXB0bzo1MH1dLHdlYjM6W2Z1bmN0aW9uKHQsZSxuKXt2YXIgcj10KCIuL2xpYi93ZWIzIik7InVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJnZvaWQgMD09PXdpbmRvdy5XZWIzJiYod2luZG93LldlYjM9ciksZS5leHBvcnRzPXJ9LHsiLi9saWIvd2ViMyI6MjJ9XX0se30sWyJ3ZWIzIl0pOwp9KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gInVuZGVmaW5lZCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gInVuZGVmaW5lZCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgPyB3aW5kb3cgOiB7fSxfZGVyZXFfKCJidWZmZXIiKS5CdWZmZXIpCn0seyJidWZmZXIiOjIwfV0sMTQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKLy8gUmV0dXJucyBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgd3JhcHBlZCBjYWxsYmFjawovLyBUaGUgd3JhcHBlciBmdW5jdGlvbiBzaG91bGQgZG8gc29tZSBzdHVmZiwgYW5kIHJldHVybiBhCi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLgovLyBUaGlzIG1ha2VzIHN1cmUgdGhhdCBvd24gcHJvcGVydGllcyBhcmUgcmV0YWluZWQsIHNvIHRoYXQKLy8gZGVjb3JhdGlvbnMgYW5kIHN1Y2ggYXJlIG5vdCBsb3N0IGFsb25nIHRoZSB3YXkuCm1vZHVsZS5leHBvcnRzID0gd3JhcHB5CmZ1bmN0aW9uIHdyYXBweSAoZm4sIGNiKSB7CiAgaWYgKGZuICYmIGNiKSByZXR1cm4gd3JhcHB5KGZuKShjYikKCiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25lZWQgd3JhcHBlciBmdW5jdGlvbicpCgogIE9iamVjdC5rZXlzKGZuKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7CiAgICB3cmFwcGVyW2tdID0gZm5ba10KICB9KQoKICByZXR1cm4gd3JhcHBlcgoKICBmdW5jdGlvbiB3cmFwcGVyKCkgewogICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCkKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykgewogICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldCiAgICB9CiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncykKICAgIHZhciBjYiA9IGFyZ3NbYXJncy5sZW5ndGgtMV0KICAgIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nICYmIHJldCAhPT0gY2IpIHsKICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHsKICAgICAgICByZXRba10gPSBjYltrXQogICAgICB9KQogICAgfQogICAgcmV0dXJuIHJldAogIH0KfQoKfSx7fV0sMTQxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsKbW9kdWxlLmV4cG9ydHMgPSBleHRlbmQKCnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7CgpmdW5jdGlvbiBleHRlbmQoKSB7CiAgICB2YXIgdGFyZ2V0ID0ge30KCiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0KCiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgewogICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsKICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KCiAgICByZXR1cm4gdGFyZ2V0Cn0KCn0se31dfSx7fSxbMV0pOwo=","base64").toString();
var inpageSuffix = '//# sourceURL=' + extension.extension.getURL('scripts/inpage.js') + '\n';
var inpageBundle = inpageContent + inpageSuffix;

// Eventually this streaming injection could be replaced with:
// https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.exportFunction
//
// But for now that is only Firefox
// If we create a FireFox-only code path using that API,
// MetaMask will be much faster loading and performant on Firefox.

if (shouldInjectWeb3()) {
  setupInjection();
  setupStreams();
}

function setupInjection() {
  try {
    // inject in-page script
    var scriptTag = document.createElement('script');
    scriptTag.textContent = inpageBundle;
    scriptTag.onload = function () {
      this.parentNode.removeChild(this);
    };
    var container = document.head || document.documentElement;
    // append as first child
    container.insertBefore(scriptTag, container.children[0]);
  } catch (e) {
    console.error('Metamask injection failed.', e);
  }
}

function setupStreams() {
  // setup communication to page and plugin
  var pageStream = new LocalMessageDuplexStream({
    name: 'contentscript',
    target: 'inpage'
  });
  var pluginPort = extension.runtime.connect({ name: 'contentscript' });
  var pluginStream = new PortStream(pluginPort);

  // forward communication plugin->inpage
  pump(pageStream, pluginStream, pageStream, function (err) {
    return logStreamDisconnectWarning('MetaMask Contentscript Forwarding', err);
  });

  // setup local multistream channels
  var mux = new ObjectMultiplex();
  mux.setMaxListeners(25);

  pump(mux, pageStream, mux, function (err) {
    return logStreamDisconnectWarning('MetaMask Inpage', err);
  });
  pump(mux, pluginStream, mux, function (err) {
    return logStreamDisconnectWarning('MetaMask Background', err);
  });

  // connect ping stream
  var pongStream = new PongStream({ objectMode: true });
  pump(mux, pongStream, mux, function (err) {
    return logStreamDisconnectWarning('MetaMask PingPongStream', err);
  });

  // connect phishing warning stream
  var phishingStream = mux.createStream('phishing');
  phishingStream.once('data', redirectToPhishingWarning);

  // ignore unused channels (handled by background, inpage)
  mux.ignoreStream('provider');
  mux.ignoreStream('publicConfig');
}

function logStreamDisconnectWarning(remoteLabel, err) {
  var warningMsg = 'MetamaskContentscript - lost connection to ' + remoteLabel;
  if (err) warningMsg += '\n' + err.stack;
  console.warn(warningMsg);
}

function shouldInjectWeb3() {
  return doctypeCheck() && suffixCheck() && documentElementCheck();
}

function doctypeCheck() {
  var doctype = window.document.doctype;
  if (doctype) {
    return doctype.name === 'html';
  } else {
    return true;
  }
}

function suffixCheck() {
  var prohibitedTypes = ['xml', 'pdf'];
  var currentUrl = window.location.href;
  var currentRegex;
  for (var i = 0; i < prohibitedTypes.length; i++) {
    currentRegex = new RegExp('\\.' + prohibitedTypes[i] + '$');
    if (currentRegex.test(currentUrl)) {
      return false;
    }
  }
  return true;
}

function documentElementCheck() {
  var documentElement = document.documentElement.nodeName;
  if (documentElement) {
    return documentElement.toLowerCase() === 'html';
  }
  return true;
}

function redirectToPhishingWarning() {
  console.log('MetaMask - redirecting to phishing warning');
  window.location.href = 'https://metamask.io/phishing.html';
}

}).call(this,_dereq_("buffer").Buffer)
},{"./lib/port-stream.js":2,"buffer":6,"extensionizer":11,"obj-multiplex":16,"path":18,"ping-pong-stream/pong":19,"post-message-stream":20,"pump":22}],2:[function(_dereq_,module,exports){
(function (Buffer){
'use strict';

var Duplex = _dereq_('readable-stream').Duplex;
var inherits = _dereq_('util').inherits;
var noop = function noop() {};

module.exports = PortDuplexStream;

inherits(PortDuplexStream, Duplex);

function PortDuplexStream(port) {
  Duplex.call(this, {
    objectMode: true
  });
  this._port = port;
  port.onMessage.addListener(this._onMessage.bind(this));
  port.onDisconnect.addListener(this._onDisconnect.bind(this));
}

// private

PortDuplexStream.prototype._onMessage = function (msg) {
  if (Buffer.isBuffer(msg)) {
    delete msg._isBuffer;
    var data = new Buffer(msg);
    this.push(data);
  } else {
    this.push(msg);
  }
};

PortDuplexStream.prototype._onDisconnect = function () {
  this.destroy();
};

// stream plumbing

PortDuplexStream.prototype._read = noop;

PortDuplexStream.prototype._write = function (msg, encoding, cb) {
  try {
    if (Buffer.isBuffer(msg)) {
      var data = msg.toJSON();
      data._isBuffer = true;
      this._port.postMessage(data);
    } else {
      this._port.postMessage(msg);
    }
  } catch (err) {
    return cb(new Error('PortDuplexStream - disconnected'));
  }
  cb();
};

}).call(this,_dereq_("buffer").Buffer)
},{"buffer":6,"readable-stream":31,"util":37}],3:[function(_dereq_,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],4:[function(_dereq_,module,exports){

},{}],5:[function(_dereq_,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],6:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":3,"ieee754":12}],7:[function(_dereq_,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":_dereq_("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":14}],8:[function(_dereq_,module,exports){
var once = _dereq_('once');

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		if (readable && !(rs && rs.ended)) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && ws.ended)) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;

},{"once":17}],9:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],10:[function(_dereq_,module,exports){
const apis = [
  'alarms',
  'bookmarks',
  'browserAction',
  'commands',
  'contextMenus',
  'cookies',
  'downloads',
  'events',
  'extension',
  'extensionTypes',
  'history',
  'i18n',
  'idle',
  'notifications',
  'pageAction',
  'runtime',
  'storage',
  'tabs',
  'webNavigation',
  'webRequest',
  'windows',
]

function Extension () {
  const _this = this

  apis.forEach(function (api) {

    _this[api] = null

    try {
      if (chrome[api]) {
        _this[api] = chrome[api]
      }
    } catch (e) {}

    try {
      if (window[api]) {
        _this[api] = window[api]
      }
    } catch (e) {}

    try {
      if (browser[api]) {
        _this[api] = browser[api]
      }
    } catch (e) {}
    try {
      _this.api = browser.extension[api]
    } catch (e) {}
  })

  try {
    if (browser && browser.runtime) {
      this.runtime = browser.runtime
    }
  } catch (e) {}

  try {
    if (browser && browser.browserAction) {
      this.browserAction = browser.browserAction
    }
  } catch (e) {}

}

module.exports = Extension

},{}],11:[function(_dereq_,module,exports){
/* Extension.js
 *
 * A module for unifying browser differences in the WebExtension API.
 *
 * Initially implemented because Chrome hides all of their WebExtension API
 * behind a global `chrome` variable, but we'd like to start grooming
 * the code-base for cross-browser extension support.
 *
 * You can read more about the WebExtension API here:
 * https://developer.mozilla.org/en-US/Add-ons/WebExtensions
 */

const Extension = _dereq_('./extension-instance')
module.exports = new Extension()

},{"./extension-instance":10}],12:[function(_dereq_,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],13:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],14:[function(_dereq_,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],15:[function(_dereq_,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],16:[function(_dereq_,module,exports){
const { Duplex } = _dereq_('readable-stream')
const endOfStream = _dereq_('end-of-stream')
const once = _dereq_('once')
const noop = () => {}

const IGNORE_SUBSTREAM = {}


class ObjectMultiplex extends Duplex {

  constructor(_opts = {}) {
    const opts = Object.assign({}, _opts, {
      objectMode: true,
    })
    super(opts)

    this._substreams = {}
  }

  createStream (name) {
    // validate name
    if (!name) throw new Error('ObjectMultiplex - name must not be empty')
    if (this._substreams[name]) throw new Error('ObjectMultiplex - Substream for name "${name}" already exists')

    // create substream
    const substream = new Substream({ parent: this, name: name })
    this._substreams[name] = substream

    // listen for parent stream to end
    anyStreamEnd(this, (err) => {
      substream.destroy(err)
    })

    return substream
  }

  // ignore streams (dont display orphaned data warning)
  ignoreStream (name) {
    // validate name
    if (!name) throw new Error('ObjectMultiplex - name must not be empty')
    if (this._substreams[name]) throw new Error('ObjectMultiplex - Substream for name "${name}" already exists')
    // set
    this._substreams[name] = IGNORE_SUBSTREAM
  }

  // stream plumbing

  _read () {}

  _write(chunk, encoding, callback) {
    // parse message
    const name = chunk.name
    const data = chunk.data
    if (!name) {
      console.warn(`ObjectMultiplex - malformed chunk without name "${chunk}"`)
      return callback()
    }

    // get corresponding substream
    const substream = this._substreams[name]
    if (!substream) {
      console.warn(`ObjectMultiplex - orphaned data for stream "${name}"`)
      return callback()
    }

    // push data into substream
    if (substream !== IGNORE_SUBSTREAM) {
      substream.push(data)
    }

    callback()
  }

}


class Substream extends Duplex {

  constructor ({ parent, name }) {
    super({
      objectMode: true,
    })

    this._parent = parent
    this._name = name
  }

  _read () {}

  _write (chunk, enc, callback) {
    this._parent.push({
      name: this._name,
      data: chunk,
    })
    callback()
  }

}

module.exports = ObjectMultiplex

// util

function anyStreamEnd(stream, _cb) {
  const cb = once(_cb)
  endOfStream(stream, { readable: false }, cb)
  endOfStream(stream, { writable: false }, cb)
}
},{"end-of-stream":8,"once":17,"readable-stream":31}],17:[function(_dereq_,module,exports){
var wrappy = _dereq_('wrappy')
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}

},{"wrappy":38}],18:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,_dereq_('_process'))
},{"_process":5}],19:[function(_dereq_,module,exports){
const Duplex = _dereq_('readable-stream').Duplex
const inherits = _dereq_('util').inherits

module.exports = PongStream

inherits(PongStream, Duplex)

function PongStream (opts) {
  const self = this
  opts = opts || {}
  Duplex.call(this, opts)
  self._heartbeatRequest = opts.heartbeatRequest || 'ping'
  self._heartbeatResponse = opts.heartbeatResponse || 'pong'
}

// private

PongStream.prototype._sendResponse = function (msg) {
  const self = this
  self.push(self._heartbeatResponse)
}

// stream plumbing

PongStream.prototype._read = noop

PongStream.prototype._write = function (msg, encoding, cb) {
  const self = this
  if (msg.toString() === self._heartbeatRequest.toString()) {
    // heartbeat heard
    self._sendResponse()
    cb()
  } else {
    // unknown message
    cb(new Error('PongStream - unknown request'))
  }
  
}

// util

function noop() {}
},{"readable-stream":31,"util":37}],20:[function(_dereq_,module,exports){
const DuplexStream = _dereq_('readable-stream').Duplex
const inherits = _dereq_('util').inherits

module.exports = PostMessageStream

inherits(PostMessageStream, DuplexStream)

function PostMessageStream (opts) {
  DuplexStream.call(this, {
    objectMode: true,
  })

  this._name = opts.name
  this._target = opts.target
  this._targetWindow = opts.targetWindow || window
  this._origin = (opts.targetWindow ? '*' : location.origin)

  // initialization flags
  this._init = false
  this._haveSyn = false

  window.addEventListener('message', this._onMessage.bind(this), false)
  // send syncorization message
  this._write('SYN', null, noop)
  this.cork()
}

// private
PostMessageStream.prototype._onMessage = function (event) {
  var msg = event.data

  // validate message
  if (this._origin !== '*' && event.origin !== this._origin) return
  if (event.source !== this._targetWindow) return
  if (typeof msg !== 'object') return
  if (msg.target !== this._name) return
  if (!msg.data) return

  if (!this._init) {
    if (msg.data === 'SYN') {
      this._haveSyn = true
      this._write('ACK', null, noop)
    } else if (msg.data === 'ACK') {
      this._init = true
      if (!this._haveSyn) {
        this._write('ACK', null, noop)
      }
      this.uncork()
    }
  } else {
    // forward message
    try {
      this.push(msg.data)
    } catch (err) {
      this.emit('error', err)
    }
  }
}

// stream plumbing
PostMessageStream.prototype._read = noop

PostMessageStream.prototype._write = function (data, encoding, cb) {
  var message = {
    target: this._target,
    data: data,
  }
  this._targetWindow.postMessage(message, this._origin)
  cb()
}

// util

function noop () {}

},{"readable-stream":31,"util":37}],21:[function(_dereq_,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,_dereq_('_process'))
},{"_process":5}],22:[function(_dereq_,module,exports){
var once = _dereq_('once')
var eos = _dereq_('end-of-stream')
var fs = _dereq_('fs') // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump

},{"end-of-stream":8,"fs":4,"once":17}],23:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Readable = _dereq_('./_stream_readable');
var Writable = _dereq_('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":25,"./_stream_writable":27,"core-util-is":7,"inherits":13,"process-nextick-args":21}],24:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = _dereq_('./_stream_transform');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":26,"core-util-is":7,"inherits":13}],25:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = _dereq_('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = _dereq_('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = _dereq_('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = _dereq_('./internal/streams/BufferList');
var destroyImpl = _dereq_('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = _dereq_('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":23,"./internal/streams/BufferList":28,"./internal/streams/destroy":29,"./internal/streams/stream":30,"_process":5,"core-util-is":7,"events":9,"inherits":13,"isarray":15,"process-nextick-args":21,"safe-buffer":32,"string_decoder/":33,"util":4}],26:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = _dereq_('./_stream_duplex');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":23,"core-util-is":7,"inherits":13}],27:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: _dereq_('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = _dereq_('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/
var Buffer = _dereq_('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = _dereq_('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || _dereq_('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":23,"./internal/streams/destroy":29,"./internal/streams/stream":30,"_process":5,"core-util-is":7,"inherits":13,"process-nextick-args":21,"safe-buffer":32,"util-deprecate":34}],28:[function(_dereq_,module,exports){
'use strict';

/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = _dereq_('safe-buffer').Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();
},{"safe-buffer":32}],29:[function(_dereq_,module,exports){
'use strict';

/*<replacement>*/

var processNextTick = _dereq_('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":21}],30:[function(_dereq_,module,exports){
module.exports = _dereq_('events').EventEmitter;

},{"events":9}],31:[function(_dereq_,module,exports){
exports = module.exports = _dereq_('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = _dereq_('./lib/_stream_writable.js');
exports.Duplex = _dereq_('./lib/_stream_duplex.js');
exports.Transform = _dereq_('./lib/_stream_transform.js');
exports.PassThrough = _dereq_('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":23,"./lib/_stream_passthrough.js":24,"./lib/_stream_readable.js":25,"./lib/_stream_transform.js":26,"./lib/_stream_writable.js":27}],32:[function(_dereq_,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = _dereq_('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":6}],33:[function(_dereq_,module,exports){
'use strict';

var Buffer = _dereq_('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":32}],34:[function(_dereq_,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],35:[function(_dereq_,module,exports){
arguments[4][13][0].apply(exports,arguments)
},{"dup":13}],36:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],37:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":36,"_process":5,"inherits":35}],38:[function(_dereq_,module,exports){
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

},{}]},{},[1]);
